create or replace package body mgr_oschad is

  -- Copyryight : UNITY-BARS
  -- Author     : SERG
  -- Created    : 19.10.2011
  -- Purpose    : Пакет процедур для миграции одно-мфо в мульти-мфо в Ощадбанке
  ----
  -- Работает с конкретным МФО через таблицы kf<mfo>.<table>
  ----

  -- global consts
  G_BODY_VERSION constant varchar2(64 char)  := 'version 1.2.0 08/04/2017';

  G_PKG constant varchar2(30 char) := 'mgr_oschad';

  -- Код модуля для ошибок и сообщений
    MODCODE           constant varchar2(3 char) := 'ADM';
    PARAMV_SKIPLIC    constant varchar2(1 char)  := 'Y';
    PARAM_SKIPLIC     constant varchar2(8 char)  := '_SKIPLIC';


  -- global variables

  -- МФО мигрируемого филиала
  g_kf  varchar2(6 char);
  -- RU мигрируемого филиала
  g_ru  varchar2(6 char);

  g_glb_mfo varchar2(6 char);

  g_branch_mask varchar2(9 char);

   -- текущее значение SCHEMA
  g_schema  varchar2(30);

  -- текущее значение DBLINK
  g_dblink  varchar2(30);

 -- Наименование мигрируемого филиала
  --g_sync_name  varchar2(250);
  -- Банковская дата
  --g_sync_bankdate varchar2(10 char);

  ----
  -- header_version - возвращает версию заголовка пакета
  --
  function header_version return varchar2 is
  begin
    return 'Package header mgr_oschad '||G_HEADER_VERSION;
  end header_version;

  ----
  -- body_version - возвращает версию тела пакета
  --
  function body_version return varchar2 is
  begin
    return 'Package body mgr_oschad '||G_BODY_VERSION;
  end body_version;

  function get_param(p_parname in params.par%type) return params.val%type
    is
   l_res   params.val%type;   /* установленное значение */

    begin
        select val into l_res
          from params
         where par = p_parname;

        return l_res;
    exception
        when NO_DATA_FOUND then return null;
    end get_param;

    ----
    --   Запись трассировочного сообщения в протокол
    --
    --
     procedure trace(
         p_msg  in  varchar2,
         p_arg1 in  varchar2  default null,
         p_arg2 in  varchar2  default null,
         p_arg3 in  varchar2  default null,
         p_arg4 in  varchar2  default null,
         p_arg5 in  varchar2  default null,
         p_arg6 in  varchar2  default null,
         p_arg7 in  varchar2  default null,
         p_arg8 in  varchar2  default null,
         p_arg9 in  varchar2  default null
    )
    is
    begin
        --
        mgr_utl.trace(p_msg, p_arg1, p_arg2, p_arg3, p_arg4, p_arg5, p_arg6, p_arg7, p_arg8, p_arg9);
        --
    end trace;

  ----
  -- pkf - облочка над mgr_utl.pkf()
  --
  function pkf(p_object varchar2, p_schema varchar2 default null,  p_dblink varchar2 default null) 
    return varchar2
  is
  begin
    --
    return mgr_utl.pkf(p_object, p_schema, p_dblink);
    --
  end pkf;

  ----
  -- инициализация
  --
  procedure init
  is
  begin
    -- GLB-MFO
    g_glb_mfo := mgr_utl.get_glb_mfo();
    -- MFO
    g_kf := mgr_utl.get_kf();
    -- RU
    g_ru := mgr_utl.get_ru();
    -- текущее значение SCHEMA
    g_schema := mgr_utl.get_schema();

    -- текущее значение DBLINK
    g_dblink := mgr_utl.get_dblink();

    -- NAME
--    execute immediate 'select substr(val,1,250) from '||pkf('params$base')||' where par=''NAME'''
       --into g_sync_name;
    -- BANKDATE
--    execute immediate 'select substr(val,1,10) from '||pkf('params$base')||' where par=''BANKDATE'''
      -- into g_sync_bankdate;
    --
    g_branch_mask := '/'||g_kf||'/%';
    --
  end init;

  ----
  -- get_kf - возвращает МФО мигрируемого филиала
  --
  function get_kf return varchar2
  is
    p   constant varchar2(62) := G_PKG||'.get_kf';
  begin
    trace('%s: call', p);
    return g_kf;
  end get_kf;

  ----
  -- get_rowcount - возвращает кол-во строк в таблице p_table
  --
  function get_rowcount(p_table in varchar2)
  return number
  is
  begin
    --
    return mgr_utl.get_rowcount(p_table);
    --
  end get_rowcount;

  ----
  -- get_errinfo - возвращает описание типовых ошибок в таблице err$_*
  --
  function get_errinfo(p_errtable in varchar2)
  return varchar2
  is
  begin
    --
    return mgr_utl.get_errinfo(p_errtable);
    --
  end get_errinfo;

  ----
  -- get_check_order - возвращает номер следующей проверки
  --
  function get_check_order
  return integer
  is
    l_checkorder    integer;
  begin
    --
    select nvl(max(check_order),0)+1
      into l_checkorder
      from mgr_checks
     where kf = g_kf;
    --
    return l_checkorder;
    --
  end get_check_order;

  ----
  -- get_max_idupd - возвращает максимальное(+1)значение idupd в таблице p_table
  --
  function get_max_idupd(p_table in varchar2)
  return number deterministic
  is
    l_max_idupd  number;
  begin
    execute immediate 'select trunc(nvl(max(idupd / 100), 0)) + 1 
                         from bars.'||p_table||'
                        where mod(idupd, 100) = mgr_utl.get_ru()' 
                       into l_max_idupd ;
    --
    return l_max_idupd;
    --
  end get_max_idupd;

  ----------------------------------------------------------------------------------------------------------------------
  -- Начало: процедуры проверки перед миграцией
  ----------------------------------------------------------------------------------------------------------------------

  ----
  -- check_user_bars_exists - пользователь BARS существует с ID=1
  --
  procedure check_user_bars_exists
  is
    l_num   number;
  begin
    execute immediate 'select 1 from '||pkf('staff$base')||' where id=1 and logname=''BARS'''
       into l_num;
  exception
    when no_data_found then
        raise_application_error(-20000,
        'Пользователь BARS не найден или его ID не равен 1');
  end check_user_bars_exists;

  ----
  -- check_user_dummy_exists - пользователь DUMMY существует с ID=-1
  --
  procedure check_user_dummy_exists
  is
    l_num   number;
  begin
    execute immediate 'select 1 from '||pkf('staff$base')||' where id=-1'
    into l_num;
  exception
    when no_data_found then
        raise_application_error(-20000, 'Пользователь с ID=-1 не найден');
  end check_user_dummy_exists;

  ----
  -- check_tabn_exists - проверка на существование идентификаторов ключей
  --
  procedure check_tabn_exists
  is
    l_num   number;
  begin
    execute immediate
    'select 1
      from staff$base a, '||pkf('staff$base')||' b
     where a.tabn is not null
       and b.tabn is not null
       and trim(a.tabn) = trim(b.tabn)
       and a.branch not like ''/''||:g_kf||''/%''
       and rownum = 1'
       into l_num
       using g_kf;
    --
    raise_application_error(-20000,
    'Импортируемые идентификаторы ключей уже зарегистрированы');
  exception
    when no_data_found then
        null;
  end check_tabn_exists;

  ----
  -- check_tabn_length_6 - проверка длины идентификатора ключа
  --
  procedure check_tabn_length_6
  is
    l_cnt   number;
  begin
    execute immediate 'select count(*) from '||pkf('staff$base')||' where tabn is not null and length(trim(tabn))<>6'
    into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'Кол-во некорректно заполненных идент. ключей = '||l_cnt);
    end if;
  end check_tabn_length_6;

  ----
  -- check_tabn_unique - проверка уникальности идентификаторов ключей
  --
  procedure check_tabn_unique
  is
    l_cnt   number;
  begin
    execute immediate
    'select count(*)
      from (select trim(tabn), count(*)
              from '||pkf('staff$base')||'
             where trim(tabn) is not null
             group by trim(tabn)
            having count(*)>1
           )'
    into l_cnt
    ;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'Кол-во неуникальных идент. ключей = '||l_cnt);
    end if;
  end check_tabn_unique;

  ----
  -- check_meta_tables_unique - проверка уникальности имен таблиц в META_TABLES
  --
  procedure check_meta_tables_unique
  is
    l_cnt    number;
  begin
    execute immediate
    'select count(*)
      from (select trim(tabname), count(*)
              from '||pkf('meta_tables')||'
             where trim(tabname) is not null
             group by trim(tabname)
            having count(*)>1
           )'
    into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'Кол-во неуникальных имен таблиц в БМД = '||l_cnt);
    end if;
  end check_meta_tables_unique;

  ----
  -- check_customer_sab_unique - проверка уникальности customer.sab
  --
  procedure check_customer_sab_unique
  is
    l_cnt   number;
  begin
        execute immediate
        'select count(*)

          from (select sab, count(*)
                  from '||pkf('customer')||'
                 where sab is not null
                 group by sab
                having count(*)>1
               )'
        into l_cnt;
        --
        if l_cnt > 0
        then
            raise_application_error(-20000,
            'Кол-во неуникальных значений поля SAB = '||l_cnt);
        end if;
  end check_customer_sab_unique;

  ----
  -- check_rang_absent - проверка полноты таблицы RANG
  --
  procedure check_rang_absent
  is
    l_cnt   number;
  begin
    execute immediate
    'select count(rang)
      from '||pkf('rang')||'
     where rang not in (select rang from rang)'
    into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'В таблице RANG обнаружены отсутствующие значения в кол-ве '||l_cnt);
    end if;
  end check_rang_absent;

  ----
  -- check_ps_absent - проверка полноты таблицы PS
  --
  procedure check_ps_absent
  is
    l_cnt   number;
  begin
    execute immediate
    'select count(nbs)
      from '||pkf('ps')||'
     where nbs not in (select nbs from ps)'
    into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'В таблице PS обнаружены отсутствующие значения в кол-ве '||l_cnt);
    end if;
  end check_ps_absent;

  ----
  -- check_tips_absent - проверка полноты таблицы TIPS
  --
  procedure check_tips_absent
  is
    l_cnt   number;
  begin
    execute immediate
    'select count(tip)
      from '||pkf('tips')||'
     where tip not in (select tip from tips)'
    into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'В таблице TIPS обнаружены отсутствующие значения в кол-ве '||l_cnt);
    end if;
    --
  end check_tips_absent;

  ----
  -- check_vids_absent - проверка полноты таблицы VIDS
  --
  procedure check_vids_absent
  is
    l_cnt   number;
  begin
    execute immediate
    'select count(vid)
      from '||pkf('vids')||'
     where vid not in (select vid from vids)'
    into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'В таблице VIDS обнаружены отсутствующие значения в кол-ве '||l_cnt);
    end if;
  end check_vids_absent;

  ----
  -- check_tabval_absent - проверка полноты таблицы TABVAL
  --
  procedure check_tabval_absent
  is
    l_cnt   number;
  begin
    execute immediate
    'select count(kv)
      from '||pkf('tabval')||'
     where kv not in (select kv from tabval$global)'
     into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'В таблице TABVAL обнаружены отсутствующие значения в кол-ве '||l_cnt);
    end if;
  end check_tabval_absent;

  ----
  -- check_accounts_field - проверка полноты таблицы ACCOUNTS_FIELD
  --
  procedure check_accounts_field
  is
    l_cnt   number;
    obj_not_exist  exception;
    pragma exception_init(obj_not_exist, -942);
  begin
    begin
        execute immediate
        'select count(*)
           from '||pkf('accounts_field')||'
          where tag not in (select tag from accounts_field)'
           into l_cnt;
    exception
        when obj_not_exist then
            l_cnt := 0;
    end;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'В таблице ACCOUNTS_FIELD обнаружены отсутствующие значения в кол-ве '||l_cnt);
    end if;
  end check_accounts_field;

  ----
  -- check_accounts_rnk_null - проверка ACCOUNTS.RNK is null
  --
  procedure check_accounts_rnk_null
  is
    l_cnt   number;
  begin
    execute immediate
    'select count(*)
      from '||pkf('accounts')||'
     where rnk is null'
     into l_cnt;
    --
    if l_cnt > 0
    then
        raise_application_error(-20000,
        'В таблице ACCOUNTS найдено '||to_char(l_cnt)||' записей с пустым RNK');
    end if;
  end check_accounts_rnk_null;

  ----
  -- do_checks - выполняет проверки перед миграцией
  --
  procedure do_checks
  is
    p   constant varchar2(62) := G_PKG||'.do_checks';
    l_check     mgr_checks%rowtype;
    ----
    -- log_check - запись в журнал инфо по проверке
    --
    procedure log_check(p_check in mgr_checks%rowtype)
    is
    pragma autonomous_transaction;
    begin
        trace('%s: %s. %s - %s, %s', p, lpad(to_char(p_check.check_order),2), rpad(p_check.check_proc,30),
            p_check.check_status, case when p_check.check_status='FAILED' then chr(10)||rpad(' ',12)||p_check.check_comment else null end);
        insert
          into mgr_checks
        values p_check;
        commit;
    end log_check;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    -- чистим таблицу проверок
    delete
      from mgr_checks
     where kf = g_kf;
    --
    trace('%s: %s rows deleted from mgr_checks', p, to_char(sql%rowcount));
    --
    commit;
    --
    l_check.kf              := g_kf;
    --
    for c in (select *
                from mgr_check_proc
               order by creation_time, proc_name
             )
    loop
        l_check.check_order := get_check_order();
        l_check.check_proc  := c.proc_name;
        begin
            execute immediate 'begin '||c.proc_name||'; end;';
            l_check.check_status := 'SUCCEEDED';
            l_check.check_comment := null;
        exception when others then
            l_check.check_status := 'FAILED';
            l_check.check_comment := dbms_utility.format_error_stack;
        end;
        log_check(l_check);
    end loop;
    --
    bc.home;
    --
    trace('%s: finished', p);
    --
  end do_checks;

 procedure check_tab_column_exist(ip_tab varchar2)
   is
   l_user         varchar2(30 char);
   l_tab          varchar2(30 char);
   v_counter      pls_integer := 0;
   ip_ack         number;

   cursor cur is
    select utc.column_name
    from user_tab_columns utc, user_tables ut
    where utc.table_name = ut.table_name
      and utc.table_name = l_tab;
    type t_cur_utc is table of user_tab_columns.column_name%type index by pls_integer;
    l_cur_utc t_cur_utc;

  begin
  l_user    := 'KF'||g_kf;
  l_tab     := ip_tab;

   mgr_utl.p_table_exists_kf(l_tab,l_user,ip_ack);
     case when ip_ack = 1 then
             for rec in cur loop
             v_counter := v_counter + 1;
             l_cur_utc(v_counter) := rec.column_name;
             mgr_utl.p_table_column_exists_kf(l_tab,l_cur_utc(v_counter),l_user);
             end loop;
          else null;
     end case;
  exception when others then
    raise;
     mgr_utl.save_error();
  end check_tab_column_exist;

  procedure check_mgr_table
  is
  cursor cur is
    select table_name
      from mgr_tbl_queue
     where 1=1
       /*and table_name not in ('STAFF_BRANCH', 'BIRJA', 'NOSTRO_DEAL', 'WCS_PARTNERS', 'V2_CP_TAG', 'V3_CP_TAG', 'V1_CP_TAG',
                              'V_CP_RETEIL', 'V_CUST_RISK', 'FM_YESNO', 'FM_SAILOR', 'FM_VSN')*/
        and migration = '1'
       and owner = 'BARS'
     order by migration_ord;
    type t_cur_ut is table of user_tables.table_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter pls_integer := 0;
    begin
        for rec in cur loop
            v_counter := v_counter + 1;
            l_cur_ut(v_counter) := rec.table_name;
            --
            mgr_oschad.check_tab_column_exist (l_cur_ut(v_counter));
            --
        end loop;
    exception when others then
       mgr_utl.save_error();
       raise;
  end check_mgr_table;

  procedure check_disable_trigger
    as
    csql_text clob;
      begin
      for cur in
      (
        select ut.trigger_name, ut.table_name
          from user_triggers ut
         where ut.status = 'DISABLED'
       )
      loop
         csql_text := mgr_utl.f_trigger_get_metadata(cur.trigger_name);
         mgr_utl.p_object_save(cur.table_name, cur.trigger_name,'TRIGGER_DISABLED', csql_text);
      end loop;
      exception when others
        then raise;
  end check_disable_trigger;

  ----------------------------------------------------------------------------------------------------------------------
  -- Окончание: процедуры проверки перед миграцией
  ----------------------------------------------------------------------------------------------------------------------
  procedure clean_table_w_copy_obj
    is
      cursor cur is
      select mtq.table_name
        from mgr_tbl_queue mtq, user_tables ut
       where mtq.table_name = ut.table_name
         and mtq.clean = '1'
         and mtq.owner = 'BARS'
         and mtq.table_name not in('STAFF$BASE', 'STO_LST', 'STO_DET', 'STO_DET_AGR', 'STO_OPERW', 'STO_DAT', 'STO_DET_UPDATE', 'STO_DAT_UPDATE', 'STO_PRODUCT',
                                   'STO_PAYMENT_DOCUMENT_LINK', 'STO_PAYMENT_TRACKING', 'STO_PAYMENT', 'STO_PROD_EXTRA_ATTRIBUTES', 'STO_SBON_ORDER_CONTR',
                                   'STO_SBON_ORDER_FREE', 'STO_SBON_ORDER_NO_CONTR', 'STO_SBON_PRODUCT', 'STO_SEP_ORDER', 'STO_TYPE', 'STO_ORDER',
                                   'STO_ORDER_EXTRA_ATTRIBUTES', 'STO_PAYMENT_QUE',
                                   'CC_DOCS', 'CUSTOMER_IMAGES', 'DPT_AGREEMENTS', 'EAD_DOCS', 'EAD_SYNC_QUEUE', 'INS_ADD_AGREEMENTS',
                                   'INS_DEAL_SCANS', 'MWAY_LOG', 'OW_FILES', 'OW_IMPFILE', 'OW_LOCPAY_MATCH', 'OW_OIC_DOCUMENTS_DATA',
                                   'OW_OIC_DOCUMENTS_HIST', 'OW_QUERY_LOG', 'OW_SALARY_DATA', 'SW_MESSAGES', 'WCS_BCK_REPORTS', 'CP_ARCH',
                                   'WCS_ANSWERS', 'WCS_SUBPRODUCT_MACS', 'WCS_PRINT_SCANS',
                                   'WCS_ANSWERS_HISTORY', 'WCS_BID_GPK', 'WCS_BID_STATES', 'WCS_BID_STATES_BACKUP', 'WCS_BID_STATES_HISTORY', 'WCS_BIDS', 'WCS_LOGS') --clean of another procedure clean_table_with_lob
         --and mtq.migr_nsup_col_type is null
       order by mtq.clean_ord;

    type t_cur_ut is table of user_tables.table_name%type index by pls_integer;
    l_cur_ut t_cur_ut;

    v_counter pls_integer := 0;

      begin
          for rec in cur loop
          v_counter := v_counter + 1;
          l_cur_ut(v_counter) := rec.table_name;
          
              --mgr_utl.p_triggers_disable            (l_cur_ut(v_counter));
              mgr_utl.p_constraints_disable         (l_cur_ut(v_counter));
              mgr_utl.p_ref_constraints_disable     (l_cur_ut(v_counter));
              mgr_utl.p_indexes_save                (l_cur_ut(v_counter));
              mgr_utl.p_triggers_save               (l_cur_ut(v_counter));
              mgr_utl.p_ref_constraints_save        (l_cur_ut(v_counter));
              mgr_utl.p_constraints_save            (l_cur_ut(v_counter));
              mgr_utl.p_constraints_pk_save         (l_cur_ut(v_counter));
              mgr_utl.p_table_save                  (l_cur_ut(v_counter));
              mgr_utl.p_tbl_col_com_save            (l_cur_ut(v_counter));
              --mgr_utl.p_constraints_drop            (l_cur_ut(v_counter));
              --mgr_utl.p_indexes_drop                (l_cur_ut(v_counter));
              begin
                mgr_utl.mantain_error_table           (l_cur_ut(v_counter));
                      exception when others then
                      -- ORA-20069: Unsupported column type(s) found:  
                        if sqlcode in (-20069) then mgr_utl.save_error();
                          else raise;
                        end if;
              end;
              mgr_utl.p_table_truncate              (l_cur_ut(v_counter));
          end loop;

      exception when others then
      -- -20103 Table '||ip_table||' not exists
        if sqlcode in (-20103) then mgr_utl.save_error();
          else raise;
        end if;
      mgr_utl.save_error();
  end clean_table_w_copy_obj;

  procedure restore_table_obj
    is
      cursor cur is
      select mtq.table_name
        from mgr_tbl_queue mtq, user_tables ut
       where mtq.table_name = ut.table_name
         and mtq.clean = '1'
         and mtq.owner = 'BARS'
         order by mtq.clean_ord;

    type t_cur_ut is table of user_tables.table_name%type index by pls_integer;
    l_cur_ut t_cur_ut;

    v_counter pls_integer := 0;

      begin
          for rec in cur loop
          v_counter := v_counter + 1;
          l_cur_ut(v_counter) := rec.table_name;
              mgr_utl.p_constraints_pk_restore      (l_cur_ut(v_counter));
              mgr_utl.p_constraints_restore         (l_cur_ut(v_counter));
              mgr_utl.p_ref_constraints_restore     (l_cur_ut(v_counter));
              mgr_utl.p_constraints_chk_en_novalid  (l_cur_ut(v_counter));
              mgr_utl.p_constraints_fk_en_novalid   (l_cur_ut(v_counter));
              mgr_utl.p_ref_constraints_en_novalid  (l_cur_ut(v_counter));
              mgr_utl.p_indexes_restore             (l_cur_ut(v_counter));
              mgr_utl.p_triggers_restore            (l_cur_ut(v_counter));
              mgr_utl.enable_table_triggers         (l_cur_ut(v_counter));
          end loop;

      exception when others then
      -- -20103 Table '||ip_table||' not exists
        if sqlcode=(-20103) then mgr_utl.save_error();
          else raise;
        end if;
      mgr_utl.save_error();
  end restore_table_obj;


  procedure clean_table_with_lob
    is
      cursor cur is
      select mtq.table_name
        from mgr_tbl_queue mtq, user_tables ut
       where mtq.table_name = ut.table_name
         and mtq.clean = '1'
         and mtq.owner = 'BARS'
         and mtq.table_name in('STO_LST', 'STO_DET', 'STO_DET_AGR', 'STO_OPERW', 'STO_DAT', 'STO_DET_UPDATE', 'STO_DAT_UPDATE', 'STO_PRODUCT',
                               'STO_PAYMENT_DOCUMENT_LINK', 'STO_PAYMENT_TRACKING', 'STO_PAYMENT', 'STO_PROD_EXTRA_ATTRIBUTES', 'STO_SBON_ORDER_CONTR',
                               'STO_SBON_ORDER_FREE', 'STO_SBON_ORDER_NO_CONTR', 'STO_SBON_PRODUCT', 'STO_SEP_ORDER', 'STO_TYPE', 'STO_ORDER',
                               'STO_ORDER_EXTRA_ATTRIBUTES', 'STO_PAYMENT_QUE',
                               'CC_DOCS', 'CUSTOMER_IMAGES', 'DPT_AGREEMENTS', 'EAD_DOCS', 'EAD_SYNC_QUEUE', 'INS_ADD_AGREEMENTS',
                               'INS_DEAL_SCANS', 'MWAY_LOG', 'OW_FILES', 'OW_IMPFILE', 'OW_LOCPAY_MATCH', 'OW_OIC_DOCUMENTS_DATA',
                               'OW_OIC_DOCUMENTS_HIST', 'OW_QUERY_LOG', 'OW_SALARY_DATA', 'SW_MESSAGES', 'WCS_BCK_REPORTS','CP_ARCH',
                               'WCS_SUBPRODUCT_MACS', 'WCS_PRINT_SCANS'
                               )
       order by mtq.clean_ord;

    type t_cur_ut is table of user_tables.table_name%type index by pls_integer;
    l_cur_ut t_cur_ut;

    v_counter pls_integer := 0;

      begin
          for rec in cur loop
          v_counter := v_counter + 1;
          l_cur_ut(v_counter) := rec.table_name;
              mgr_utl.p_triggers_disable            (l_cur_ut(v_counter));
              mgr_utl.p_constraints_disable         (l_cur_ut(v_counter));
              mgr_utl.p_ref_constraints_disable     (l_cur_ut(v_counter));
              mgr_utl.p_indexes_save                (l_cur_ut(v_counter));
              mgr_utl.p_triggers_save               (l_cur_ut(v_counter));
              mgr_utl.p_ref_constraints_save        (l_cur_ut(v_counter));
              mgr_utl.p_constraints_save            (l_cur_ut(v_counter));
              mgr_utl.p_constraints_pk_save         (l_cur_ut(v_counter));
              mgr_utl.p_table_save                  (l_cur_ut(v_counter));
              mgr_utl.p_tbl_col_com_save            (l_cur_ut(v_counter));
              -- mgr_utl.clean                         (l_cur_ut(v_counter));
              mgr_utl.p_table_truncate              (l_cur_ut(v_counter));
           end loop;

      exception when others then
        -- -20103 Table '||ip_table||' not exists
        if sqlcode=(-20103) then mgr_utl.save_error();
          else raise;
        end if;
      mgr_utl.save_error();
  end clean_table_with_lob;

  ----
  -- clean_params - очищает таблицу params$base по мигрируемому МФО
  --
  procedure clean_params
  is
      l_mfo_mask varchar2(9 char);
  begin
      l_mfo_mask := bars_context.make_branch_mask(get_kf());

      bc.home();

      mgr_utl.before_clean('branch_attribute_value');

      begin
          delete branch_attribute_value t
          where  t.branch_code like l_mfo_mask;

          commit;
      exception
          when others then
               rollback;
               mgr_utl.save_error();
      end;

      mgr_utl.finalize();
  end;

/*  procedure clean_params
  is
    l_tab          VARCHAR2(30) DEFAULT 'PARAMS$BASE';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

  begin
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        -- чистим данные по мигрируемому МФО
        delete
          from params$base
         where kf = g_kf;
        --
        commit;
        --
    exception when others then
        rollback;
        mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_params;
*/
  ----
  -- fill_params - заполняет таблицу params$base
  --
  procedure fill_params
  is
      l_mfo_mask varchar2(9 char);
  begin
      bc.home();

      mgr_utl.before_fill('branch_attribute, branch_attribute_value');

      begin
          execute_statement(
          'insert into branch_attribute (attribute_code, attribute_desc, attribute_datatype, attribute_format, attribute_module)
           select par, comm, ''C'', null, null from ' || pkf('params$global') || ' t
           where not exists (select 1 from branch_attribute a where a.attribute_code = t.par)',
          'mgr_oschad.fill_params (branch_attribute) : PARAMS$GLOBAL');

          execute_statement(
          'insert into branch_attribute (attribute_code, attribute_desc, attribute_datatype, attribute_format, attribute_module)
           select par, comm, ''C'', null, null from ' || pkf('params$base') || ' t
           where not exists (select 1 from branch_attribute a where a.attribute_code = t.par)',
          'mgr_oschad.fill_params (branch_attribute) : PARAMS$BASE');

          execute_statement(
          'insert into branch_attribute (attribute_code, attribute_desc, attribute_datatype, attribute_format, attribute_module)
           select tag, name, ''C'', null, null from ' || pkf('branch_tags') || ' t
           where not exists (select 1 from branch_attribute a where a.attribute_code = t.tag)',
          'mgr_oschad.fill_params (branch_attribute) : BRANCH_TAGS');

          l_mfo_mask := bars_context.make_branch_mask(get_kf());

          delete branch_attribute_value t
          where  t.branch_code like l_mfo_mask;

          execute_statement(
          'insert into branch_attribute_value (attribute_code, branch_code, attribute_value)
           select t.tag, t.branch, t.val
           from ' || pkf('branch_parameters') || ' t
           where t.branch = ''\'' and
                 not exists (select 1 from branch_attribute_value a where a.attribute_code = t.tag and a.branch_code = t.branch)',
          'mgr_oschad.fill_params (branch_attribute_value) : branch_parameters ''\''',
          'BRANCH_PARAMETERS');

          execute_statement(
          'insert into branch_attribute_value (attribute_code, branch_code, attribute_value)
           select t.tag, t.branch, t.val
           from ' || pkf('branch_parameters') || ' t
           where t.branch like ''' || l_mfo_mask || '''',
          'mgr_oschad.fill_params (branch_attribute_value) : branch_parameters ''\' || g_kf || '\''',
          'BRANCH_PARAMETERS');

          execute_statement(
          'insert into branch_attribute_value (attribute_code, branch_code, attribute_value)
           select t.par, bars_context.make_branch(t.kf), t.val
           from ' || pkf('params$base') || ' t
           where t.kf = ''' || g_kf || ''' and
                 t.par not in (''BANKDATE'', ''RRPDAY'') and
                 not exists (select 1 from branch_attribute_value a
                             where  a.attribute_code = t.par and
                                    a.branch_code = bars_context.make_branch(t.kf))',
          'mgr_oschad.fill_params (branch_attribute_value) : params$base',
          'PARAMS$BASE');

          execute_statement(
          'insert into branch_attribute_value (attribute_code, branch_code, attribute_value)
           select t.par, ''\'', t.val
           from ' || pkf('params$global') || ' t
           where not exists (select 1 from branch_attribute_value a
                             where  a.attribute_code = t.par and
                                    a.branch_code = ''\'')',
          'mgr_oschad.fill_params (branch_attribute_value) : params$global',
          'PARAMS$GLOBAL');

          --
          -- перекодировки
          --
          execute_statement('
          update branch_attribute_value t
          set    t.attribute_value = rukey(t.attribute_value)
          where  t.attribute_code = ''OUR_RNK'' and
                 t.branch_code like ''' || l_mfo_mask || '''',
          'mgr_oschad.fill_params : перекодировка (''OUR_RNK'')',
          'BRANCH_ATTRIBUTE_VALUE', 'N');

          execute_statement('
          update branch_attribute_value t
          set    t.attribute_value = rukey(t.attribute_value)
          where  t.attribute_code = ''RNK_CP'' and
                 t.branch_code like ''' || l_mfo_mask || '''',
          'mgr_oschad.fill_params : перекодировка (''RNK_CP'')',
          'BRANCH_ATTRIBUTE_VALUE', 'N');
          
          execute_statement('
          update branch_attribute_value t
          set    t.attribute_value = rukey(t.attribute_value)
          where  t.attribute_code = ''AVTO_ISP'' and
                 t.branch_code like ''' || l_mfo_mask || '''',
          'mgr_oschad.fill_params : перекодировка (''AVTO_ISP'')',
          'BRANCH_ATTRIBUTE_VALUE', 'N');
          
          execute_statement('
          update branch_attribute_value t
          set    t.attribute_value = rukey(t.attribute_value)
          where  t.attribute_code = ''RNK'' and
                 t.branch_code like ''' || l_mfo_mask || '''',
          'mgr_oschad.fill_params : перекодировка (''RNK'')',
          'BRANCH_ATTRIBUTE_VALUE', 'N');
          
          execute_statement('
          update branch_attribute_value t
          set    t.attribute_value = ''1''
          where  t.attribute_code = ''IS_MMFO'' and
                 t.branch_code like ''' || l_mfo_mask || '''',
          'mgr_oschad.fill_params : перекодировка (''IS_MMFO'')',
          'BRANCH_ATTRIBUTE_VALUE', 'N');
      exception when others then
          rollback;
          mgr_utl.save_error();
      end;

      mgr_utl.finalize();
  end fill_params;
/*
  procedure fill_params
  is
    l_tab                    VARCHAR2(30) DEFAULT 'PARAMS$BASE';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time   date default sysdate;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);
  begin
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_fill('params$base, params$global');
    --
    begin
       l_migration_start_time := sysdate;
       l_start_time := current_timestamp;
       --
        if g_kf=g_glb_mfo
        then
            delete
              from params$base
             where kf=g_kf;
        end if;
        --
        execute immediate
        'insert
           into params$base(par, val, comm, kf)
         select par, val, comm, :g_kf
           from '||pkf('params$base')||'
          where par not in (select par
                              from params$global
                           )
                           and par not in(select par
                              from '||pkf('params$global')||'     )'
        using g_kf;

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

        --
        -- перекодировки
        --
        update params$base
           set val=rukey(val)
         where par='OUR_RNK'
           and kf=g_kf;
        --
        update params$base
           set val=val||g_ru
         where par='RNK_CP'
           and kf=g_kf;

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

        --
        commit;
        --
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_params;
*/
  ----
  -- clean_branch - очищает таблицу branch по мигрируемому МФО
  --
  procedure clean_branch
  is
    l_tab          VARCHAR2(30) DEFAULT 'BRANCH';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        -- чистим свою часть
        delete
          from branch
         where branch like '/'||g_kf||'/%';
        --
        commit;
        --
    exception when others then
        --
        rollback;
        --
        mgr_utl.save_error();
        --
    end;
    --
    mgr_utl.finalize();
    --
    dbms_mview.refresh('mv_kf');
    --
    trace('%s: finished', p);
    --
  end clean_branch;

  ----
  -- fill_branch - заполняет таблицу branch
  --
  --
  procedure fill_branch
  is
    l_tab                    VARCHAR2(30) DEFAULT 'BRANCH';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;


   begin
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_fill(l_tab);
    --
    begin
        -- наполняем
           execute_statement(
              'merge into branch a using (select branch, name, b040, description, idpdr, date_opened, date_closed, deleted, sab, NULL as tobo, null as name_alt
               from ' ||pkf('branch')||' where branch !=''/''' || ') s on (a.branch = s.branch)
               when not matched then insert (branch, name, b040, description, idpdr, date_opened, date_closed, deleted, sab, tobo, name_alt)
               values (s.branch, s.name, s.b040, s.description, s.idpdr, s.date_opened, s.date_closed, s.deleted, s.sab, s.tobo, s.name_alt)',
              'Доповнення новими значеннями '||l_tab);
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
    mgr_utl.finalize();
    --
    dbms_mview.refresh('mv_kf');
    --
    trace('%s: finished', p);
    --
  end fill_branch;

  ----
  -- fill_branch_tags - заполняет таблицу  branch_tags
  --
  --
  procedure fill_branch_tags
  is
    l_tab          VARCHAR2(30) DEFAULT 'BRANCH_TAGS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;

   begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    bpa.disable_policies(l_tab);

    begin
       execute_statement(
              'merge into branch_tags a using (select * from ' ||pkf('branch_tags') || ') s on (a.tag = s.tag)
               when not matched then insert
               values (s.tag, s.name, s.nbs, s.ob22)',
              'Доповнення новими значеннями '||l_tab);

        --
        commit;

    exception when others then
        rollback;
        mgr_utl.save_error();
    end;
    --
    bpa.enable_policies(l_tab);
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_branch_tags;

  ----
  -- fill_branch_parameters - заполняет таблицу  branch_parameters
  --
  --
  procedure fill_branch_parameters
  is
    l_tab          VARCHAR2(30) DEFAULT 'BRANCH_PARAMETERS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_clear_flag   boolean default true;
   begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    bpa.disable_policies(l_tab);

      begin

      if (l_clear_flag) then
          execute_statement(
              'delete branch_parameters a
               where a.branch like ''/' || g_kf || '%''',
              'Очистка значень з branch_parameters для МФО: ' || g_kf ||' таблиця '||l_tab, null, 'N');
      end if;

      execute_statement(
          'merge into branch_parameters a using (select * from ' || pkf('branch_parameters') || ') s on (a.tag = s.tag and a.branch = s.branch)
           when matched then update
                set a.val = s.val
           when not matched then insert
                values (s.branch, s.tag, s.val)',
          'Оновлення значень в '||l_tab);

        --
        commit;
        --
      exception when others then
          rollback;
            mgr_utl.save_error();

      end;
    --
    bpa.enable_policies(l_tab);
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_branch_parameters;

  ----
  -- clean_fdat - очищает fdat
  --
  procedure clean_fdat
  is
    l_tab          VARCHAR2(30) DEFAULT 'FDAT';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        -- чистим свою часть
        delete
          from fdat;
        --
        commit;
        --
    exception when others then
        rollback;
          mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_fdat;

  ----
  -- fill_fdat - заполняет fdat
  --
  --
  procedure fill_fdat
  is
    l_tab                    VARCHAR2(30) DEFAULT 'FDAT';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time   date default sysdate;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    begin
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
        -- наполняем

        case when g_kf = g_glb_mfo then
        begin
        execute immediate
        'merge
          into fdat fd
          using (select fdat, stat from '||pkf('fdat')||' ) fd_kf
          on (fd.fdat = fd_kf.fdat)
          when not matched then insert (fdat, stat)
                           values(fd_kf.fdat, fd_kf.stat)';
        end;
        else null;
        end case;

    --
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);
    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

    end;
    --
    commit;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_fdat;

  ---
  -- Удаление пользователей
  --

  procedure drop_user_novalidate(
   p_userid    in  staff$base.id%type )
   is

    l_usrlogname staff$base.logname%type;    /*       имя учетной записи в БД */
    --l_cnt        number;                     /*       признак налич. таблицы  */
    l_skiplic    params.val%type;            /* парам.: не вып. пересчет лиц. */

    begin
        bars_audit.trace('useradm.usrdrp: entry point par[0]=>%s', to_char(p_userid));

        -- получаем имя учетной записи
        begin
            select logname into l_usrlogname
              from staff$base
             where id = p_userid;
        exception
            when NO_DATA_FOUND then
                bars_error.raise_nerror(MODCODE, 'USER_NOT_FOUND', to_char(p_userid));
        end;

        -- Проверяем чтобы не удалили наши схемы
        if (l_usrlogname in ('BARS', 'HIST', 'FINMON')) then
            bars_error.raise_nerror(MODCODE, 'CANT_DELETE_SPECIAL_USER', l_usrlogname);
        end if;

        -- Если отклоняем запрос на создание
        delete from staff_storage
         where id = p_userid;

        begin
            execute immediate 'drop user "' || l_usrlogname || '" cascade';
            bars_audit.trace('useradm.rmusr: user account in db removed.');
        exception
            when OTHERS then
                if (sqlcode = -1918) then
                    bars_audit.trace('useradm.rmusr: user account in db already removed');
                else raise;
                end if;
        end;

        -- устанавливаем признак удаления
        update staff$base
           set active = USER_STATE_DELETED
         where id = p_userid;
        bars_audit.trace('useradm.rmusr: user state is set (deleted).');

        bars_lic.set_user_license(l_usrlogname);
        bars_audit.trace('useradm.rmusr: user license revoked.');
        commit;

        bars_audit.security(bars_msg.get_msg(MODCODE, 'USER_ACCOUNT_DELETED', l_usrlogname));

        --
        -- выполняем обновление лицензионной инф. пользователей
        -- (в это время временные учетные записи могут стать постоянными)
        --
        l_skiplic := get_param(PARAM_SKIPLIC);

        if (l_skiplic is not null and l_skiplic = PARAMV_SKIPLIC) then
            bars_audit.trace('useradm.rmusr: skip lic rvld.');
        else
            bars_audit.trace('useradm.rmusr: revalidate usr lics ...');
            -- NONONO   bars_lic.revalidate_lic;
            bars_audit.trace('useradm.rmusr: revalidate usr lics completed.');
        end if;

        bars_audit.trace('useradm.rmusr: succ end');

  end drop_user_novalidate;

  ----
  -- clean_staff - удаление пользователей по мигрируемому МФО
  --
  procedure clean_staff
  is
    l_tab          VARCHAR2(30) DEFAULT 'STAFF$BASE';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

  begin
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    mgr_utl.p_ref_constraints_disable(l_tab);
    begin
        ---
        -- 15/11/2012 12:25 их условие не удалять корневых юзеров
        -- branch<>'/'
        --
        for c in (select * from staff$base where (branch like '/'||g_kf||'/%' or id like '%'||g_ru) and branch<>'/')
        loop
            drop_user_novalidate(c.id);
        end loop;

        --bars_lic.revalidate_lic;
        --
        delete
          from staff$base
         where (branch like '/'||g_kf||'/%' or id like '%'||g_ru) and branch<>'/';
        --
        commit;
        --
    exception when others then
        rollback;
        mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    mgr_utl.p_ref_constraints_en_novalid(l_tab);
    --
    trace('%s: finished', p);
    --
  end clean_staff;

  ----
  -- fill_staff - создание пользователей
  --
  --
  procedure fill_staff
  is
    l_tab                   VARCHAR2(30) DEFAULT 'STAFF$BASE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_staff                 staff$base%rowtype;
    l_max_id                staff$base.id%type;
    --l_errtab                constant varchar2(30) := 'ERR$_STAFF$BASE';
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   type t_staff_row is record
    (id                number,
    fio                varchar2(60),
    logname            varchar2(30),
    type               integer,
    tabn               varchar2(10),
    bax                number(1), --0 - LOCK, 1- UNLOCK  -- ABS Level
    tbax               date,
    disable            number(1),
    adate1             date,
    adate2             date,
    rdate1             date,
    rdate2             date,
    clsid              number,
    blk                char(1),
    tblk               date,
    countconn          integer,
    countpass          integer,
    web_profile        varchar2(30),
    profile            varchar2(30),
    approve            number(1),
    usearc             number(1),
    cschema            varchar2(30),
    branch             varchar2(30),
    policy_group       varchar2(30),
    active             number(1),
    created            date,
    expired            date,
    chksum             varchar2(50),
    usegtw             number(1),
    templ_id           number(38),
    can_select_branch  varchar2(1),
    chgpwd             char(1),
    tip                number(22),
    current_branch     varchar2(30)
     );
    c                  t_staff_row;
    l_cursor           sys_refcursor;
    l_web_profile      varchar2(30);

  begin
    trace('%s: entry point', p);
    --
    bc.go(get_kf());
    --
    mgr_utl.before_fill(l_tab);

    mgr_utl.mantain_error_table(l_tab);
    --
    begin
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
        -- поле WEB_PROFILE есть не у всех, обрабатываем эту ситуацию
        begin
            select column_name
              into l_web_profile
              from all_tab_columns
             where owner=g_kf
               and table_name='STAFF'
               and column_name='WEB_PROFILE';
        exception
            when no_data_found then
                l_web_profile := '''DEFAULT_PROFILE''';
        end;
        open l_cursor for
                 'select  id,
                          fio,
                          nvl(logname,''UNDEFINED''||id) as logname,
                          type,
                          tabn,
                          0 as bax,
                          tbax,
                          disable,
                          adate1,
                          adate2,
                          rdate1,
                          rdate2,
                          clsid,
                          blk,
                          tblk,
                          countconn,
                          countpass,
                          '||l_web_profile||',
                          profile,
                          approve,
                          usearc,
                          case when substr(logname,1,4) = ''SBON'' then ''SBON'' else cschema end as  cschema,
                          case when logname = ''BARSUPL'' then ''/'' else branch end as branch,
                          case when logname = ''BARSUPL'' then ''WHOLE'' else policy_group end as policy_group
                          ,active
                          ,created
                          ,expired
                          ,chksum
                          ,usegtw
                          ,templ_id
                          ,can_select_branch
                          ,chgpwd
                          ,tip
                          ,current_branch
                    from '||pkf('staff$base')||'
                   where id > 0
                     and nvl(logname,''UNDEFINED''||id) not in (''DUMMY'',''BARS'',''BARSAQ'',''BARS_DM'',''RS_DUMP'',''JBOSS_USR'',''QOWNER'')
                     and branch <> ''/''
                     and ruuser(id) not in
                                   (select s.id
                                      from staff$base s
                                   -- Почали переносити юзерив на коринь тому ця умова не годиться
                                   --  where s.branch like ''/''||:g_kf||''/%''
                                   )
                   order by id';
             --using g_kf;
        --
        while true
        loop
            fetch l_cursor into c;
            exit when l_cursor%notfound;

/*      case when c.branch is not null and c.branch = '/'
      then execute immediate 'insert into ERR$_STAFF$BASE values (:fio, :logname, :branch) ' using c.fio, c.logname, c.branch;
      else    */

             -- id and logname
            l_staff.id                    := ruuser(c.id);
            l_staff.logname               := ruuser(trim(c.logname));
            l_staff.fio                   := c.fio;
            l_staff.tabn                  := trim(c.tabn);
            l_staff.clsid                 := nvl(c.clsid,0);
            l_staff.type                  := nvl(c.type,0);
            l_staff.usearc                := c.usearc;
            l_staff.usegtw                := 0;
            l_staff.web_profile           := 'DEFAULT_PROFILE';
            l_staff.profile               := null;
            l_staff.branch                := c.branch;
            l_staff.can_select_branch     := c.can_select_branch;

            -- создаем пользователя
            bars_useradm.create_user(
                p_usrfio          =>  l_staff.fio,
                p_usrtabn         =>  l_staff.tabn,
                p_usrtype         =>  l_staff.clsid,
                p_usraccown       =>  l_staff.type,
                p_usrbranch       =>  l_staff.branch,
                p_usrusearc       =>  l_staff.usearc,
                p_usrusegtw       =>  l_staff.usegtw,
                p_usrwprof        =>  l_staff.web_profile,
                p_reclogname      =>  l_staff.logname,
                p_recpasswd       =>  'qwerty',
                p_recappauth      =>  'APPSERVER',
                p_recprof         =>  null,
                p_recdefrole      =>  'BARS_CONNECT',
                p_recrsgrp        =>  null,
                p_usrid           =>  l_staff.id,
                p_gtwpasswd       =>  null,
                p_canselectbranch =>  l_staff.can_select_branch,
                p_chgpwd          =>  null,
                p_tipid           =>  null );
            --
         commit;
            --
            -- TODO: обработать закрытых пользователей
            --
 -- end case;

        end loop;
        l_rowcount := l_cursor%rowcount;
        --
        close l_cursor;
        --
        l_end_time := current_timestamp;
        l_time_duration:= (l_end_time - l_start_time);
        mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                     ,ip_migration_start_time          => l_migration_start_time
                                     ,ip_table_name                    => l_tab
                                     ,ip_operation                     => p
                                     ,ip_row_count                     => l_rowcount
                                     ,ip_task_start_time               => l_start_time
                                     ,ip_task_end_time                 => l_end_time
                                     ,ip_time_duration                 => l_time_duration
                                     ,ip_log_message                   => 'Done'
                                      );
        --
        -- подстраиваем сиквенс под максимальное значение
        --
        bc.home();
        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_id
          from staff$base;
        --
        mgr_utl.reset_sequence('S_STAFF', l_max_id);
        --
    exception when others then
        rollback;
        mgr_log.p_save_log_error(ip_migration_id                        => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
        mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_staff;

  ----
  -- fill_staff - создание пользователей
  --
  --
  procedure fill_staff_id (p_id in staff$base.id%type )
  is
    l_tab                   VARCHAR2(30) DEFAULT 'STAFF$BASE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_staff                 staff$base%rowtype;
    l_max_id                staff$base.id%type;
    --l_errtab                constant varchar2(30) := 'ERR$_STAFF$BASE';
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   type t_staff_row is record
    (id                number,
    fio                varchar2(60),
    logname            varchar2(30),
    type               integer,
    tabn               varchar2(10),
    bax                number(1), --0 - LOCK, 1- UNLOCK  -- ABS Level
    tbax               date,
    disable            number(1),
    adate1             date,
    adate2             date,
    rdate1             date,
    rdate2             date,
    clsid              number,
    blk                char(1),
    tblk               date,
    countconn          integer,
    countpass          integer,
    web_profile        varchar2(30),
    profile            varchar2(30),
    approve            number(1),
    usearc             number(1),
    cschema            varchar2(30),
    branch             varchar2(30),
    policy_group       varchar2(30),
    active             number(1),
    created            date,
    expired            date,
    chksum             varchar2(50),
    usegtw             number(1),
    templ_id           number(38),
    can_select_branch  varchar2(1),
    chgpwd             char(1),
    tip                number(22),
    current_branch     varchar2(30)
     );
    c                  t_staff_row;
    l_cursor           sys_refcursor;
    l_web_profile      varchar2(30);

  begin
    trace('%s: entry point', p);
    --
    bc.go(get_kf());
    --
    mgr_utl.before_fill(l_tab);

    mgr_utl.mantain_error_table(l_tab);
    --
    begin
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
        -- поле WEB_PROFILE есть не у всех, обрабатываем эту ситуацию
        begin
            select column_name
              into l_web_profile
              from all_tab_columns
             where owner=g_kf
               and table_name='STAFF'
               and column_name='WEB_PROFILE';
        exception
            when no_data_found then
                l_web_profile := '''DEFAULT_PROFILE''';
        end;
        open l_cursor for
                 'select  id,
                          fio,
                          nvl(logname,''UNDEFINED''||id) as logname,
                          type,
                          tabn,
                          0 as bax,
                          tbax,
                          disable,
                          adate1,
                          adate2,
                          rdate1,
                          rdate2,
                          clsid,
                          blk,
                          tblk,
                          countconn,
                          countpass,
                          '||l_web_profile||',
                          profile,
                          approve,
                          usearc,
                          case when substr(logname,1,4) = ''SBON'' then ''SBON'' else cschema end as  cschema,
                          case when logname = ''BARSUPL'' then ''/'' else branch end as branch,
                          case when logname = ''BARSUPL'' then ''WHOLE'' else policy_group end as policy_group
                          ,active
                          ,created
                          ,expired
                          ,chksum
                          ,usegtw
                          ,templ_id
                          ,can_select_branch
                          ,chgpwd
                          ,tip
                          ,current_branch
                    from '||pkf('staff$base')||'
                   where id = '||p_id||'
                     and nvl(logname,''UNDEFINED''||id) not in (''DUMMY'',''BARS'',''BARSAQ'',''BARS_DM'',''RS_DUMP'',''JBOSS_USR'',''QOWNER'')
                     and branch <> ''/''
                     and ruuser(id) not in
                                   (select s.id
                                      from staff$base s
                                   -- Почали переносити юзерив на коринь тому ця умова не годиться
                                   --  where s.branch like ''/''||:g_kf||''/%''
                                   )
                   order by id';
             --using g_kf;
        --
        while true
        loop
            fetch l_cursor into c;
            exit when l_cursor%notfound;

/*      case when c.branch is not null and c.branch = '/'
      then execute immediate 'insert into ERR$_STAFF$BASE values (:fio, :logname, :branch) ' using c.fio, c.logname, c.branch;
      else    */

             -- id and logname
            l_staff.id                    := ruuser(c.id);
            l_staff.logname               := ruuser(trim(c.logname));
            l_staff.fio                   := c.fio;
            l_staff.tabn                  := trim(c.tabn);
            l_staff.clsid                 := nvl(c.clsid,0);
            l_staff.type                  := nvl(c.type,0);
            l_staff.usearc                := c.usearc;
            l_staff.usegtw                := 0;
            l_staff.web_profile           := 'DEFAULT_PROFILE';
            l_staff.profile               := null;
            l_staff.branch                := c.branch;
            l_staff.can_select_branch     := c.can_select_branch;

            -- создаем пользователя
            bars_useradm.create_user(
                p_usrfio          =>  l_staff.fio,
                p_usrtabn         =>  l_staff.tabn,
                p_usrtype         =>  l_staff.clsid,
                p_usraccown       =>  l_staff.type,
                p_usrbranch       =>  l_staff.branch,
                p_usrusearc       =>  l_staff.usearc,
                p_usrusegtw       =>  l_staff.usegtw,
                p_usrwprof        =>  l_staff.web_profile,
                p_reclogname      =>  l_staff.logname,
                p_recpasswd       =>  'qwerty',
                p_recappauth      =>  'APPSERVER',
                p_recprof         =>  null,
                p_recdefrole      =>  'BARS_CONNECT',
                p_recrsgrp        =>  null,
                p_usrid           =>  l_staff.id,
                p_gtwpasswd       =>  null,
                p_canselectbranch =>  l_staff.can_select_branch,
                p_chgpwd          =>  null,
                p_tipid           =>  null );
            --
         commit;
            --
            -- TODO: обработать закрытых пользователей
            --
 -- end case;

        end loop;
        l_rowcount := l_cursor%rowcount;
        --
        close l_cursor;
        --
        l_end_time := current_timestamp;
        l_time_duration:= (l_end_time - l_start_time);
        mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                     ,ip_migration_start_time          => l_migration_start_time
                                     ,ip_table_name                    => l_tab
                                     ,ip_operation                     => p
                                     ,ip_row_count                     => l_rowcount
                                     ,ip_task_start_time               => l_start_time
                                     ,ip_task_end_time                 => l_end_time
                                     ,ip_time_duration                 => l_time_duration
                                     ,ip_log_message                   => 'Done'
                                      );
        --
        -- подстраиваем сиквенс под максимальное значение
        --
        bc.home();
        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_id
          from staff$base;
        --
        mgr_utl.reset_sequence('S_STAFF', l_max_id);
        --
    exception when others then
        rollback;
        mgr_log.p_save_log_error(ip_migration_id                        => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
        mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_staff_id;

  ----
  -- clean_customers - очистка клиентов
  --
  --
  procedure clean_customers
  is
    l_tab          VARCHAR2(30) DEFAULT 'CUSTOMER';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;
    l_max_rnk      integer;

    cursor cur is
      select table_name as tab_name
      from user_tables
      where lower(table_name) in ('custbank', 'custbank_update', 'corps', 'corps_update', 'corps_acc', 'person', 'person_update', 'customer_address', 'customer_address_update',
                                  'customer_buss', 'customer_category', 'customer_extern', 'customer_extern_update', 'customer_rel',
                                  'customer_rel_update', 'customer_ri', 'customer_risk', 'customerw_update', 'customerw', 'customer_update'
                                  );
    type t_cur_ut is table of user_tables.table_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;

  begin
  -- execute immediate 'alter table BARSAQ.IBANK_RNK disable constraint FK_IBANKRNK_CUSTOMER';
  trace('%s: entry point', p);
  --
  bc.go(g_kf);
  --
    case when g_kf = g_glb_mfo then
        begin
           for rec in cur loop
                v_counter            := v_counter + 1;
                l_cur_ut(v_counter)  := rec.tab_name;

                mgr_utl.disable_table_triggers   (l_cur_ut(v_counter));
                mgr_utl.disable_foreign_keys     (l_cur_ut(v_counter));
                mgr_utl.mantain_error_table      (l_cur_ut(v_counter));
                mgr_utl.p_ref_constraints_disable(l_cur_ut(v_counter));
                mgr_utl.p_table_truncate         (l_cur_ut(v_counter));
           end loop;

                   begin
                     --обрабатываем отдельно для customer
                     execute immediate 'alter table BARSAQ.IBANK_RNK disable constraint FK_IBANKRNK_CUSTOMER';
                     bars_policy_adm.disable_policies  (l_tab);
                     mgr_utl.disable_table_triggers   (l_tab);
                     mgr_utl.disable_foreign_keys     (l_tab);
                     mgr_utl.mantain_error_table      (l_tab);
                     mgr_utl.p_ref_constraints_disable(l_tab);
                     mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab );
                     commit;
                     execute immediate 'alter table BARSAQ.IBANK_RNK enable constraint FK_IBANKRNK_CUSTOMER';
                     mgr_utl.p_ref_constraints_en_novalid  (l_tab);
                     mgr_utl.enable_foreign_keys           (l_tab);
                     mgr_utl.enable_table_triggers         (l_tab);
                     bars_policy_adm.enable_policies        (l_tab);
                   end;

         end;

    else
          begin
          v_counter:= 0;
            for rec_del in cur loop
                v_counter                        := v_counter + 1;
                l_cur_ut(v_counter)              := rec_del.tab_name;
                --под вопросом  customer_extern_update, customer_ri нет поля rnk, протестить отработку
                mgr_utl.disable_table_triggers   (l_cur_ut(v_counter));
                mgr_utl.disable_foreign_keys     (l_cur_ut(v_counter));
                mgr_utl.mantain_error_table      (l_cur_ut(v_counter));
                mgr_utl.p_ref_constraints_disable(l_cur_ut(v_counter));

                mgr_utl.execute_immediate(ip_sql =>'delete from '|| l_cur_ut(v_counter)||'  where rnk like ''%'''||g_ru );
                commit;
            end loop;
            end;

    end case;

  exception
    when others then
         rollback;
           mgr_utl.save_error();
  bc.home();
  --
  -- подстраиваем сиквенс под максимальное значение
  --
  select trunc(nvl(max(rnk / 100), 0)) + 1 into l_max_rnk
  from customer;
  --
  mgr_utl.reset_sequence('S_CUSTOMER', l_max_rnk);
  trace('новое значение последовательности s_customer: %s', to_char(l_max_rnk));
  -- mgr_utl.finalize();
               begin
               v_counter:= 0;
                 for rec in cur loop
                     v_counter                        := v_counter + 1;
                     l_cur_ut(v_counter)              := rec.tab_name;

                     mgr_utl.enable_table_triggers    (l_cur_ut(v_counter));
                     mgr_utl.enable_foreign_keys      (l_cur_ut(v_counter));
                     mgr_utl.p_ref_constraints_enable (l_cur_ut(v_counter));
                 end loop;
               end;
  --
  trace('%s: finished', p);
  --
  end clean_customers;

  ----
  -- fill_customers - импорт клиентов
  --
  procedure fill_customers_frl
  is
    l_tab                    VARCHAR2(30) DEFAULT 'CUSTOMER';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                  pls_integer := 0;
    c_limit                  pls_integer := 50000;
    l_cur                    sys_refcursor;
    c_n                      pls_integer := 0;

    l_max_idupd              number(30);
    l_max_rnk                customer.rnk%TYPE;

    l_errtab                 varchar2(30);
    l_id                     customer_extern.id%type;
    l_max_id                 corps_acc.id%type;
    l_migration_start_time   date default sysdate;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);

    cursor cur is
          select table_name as tab_name
          from user_tables
          where lower(table_name) in ('customer', 'custbank', 'custbank_update', 'corps', 'corps_update', 'corps_acc', 'person', 'person_update', 'customer_address', 'customer_address_update',
                                      'customer_buss', 'customer_category', 'customer_extern', 'customer_extern_update', 'customer_rel',
                                      'customer_rel_update', 'customer_ri', 'customer_risk', 'customerw_update', 'customerw', 'customer_update'
                                      );
    type t_cur_ut is table of user_tables.table_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;
    --l_rel_id                  customer_rel.rel_id%type;
    --l_risk_id                 customer_risk.risk_id%type;

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

   /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
   */
   TYPE t_customer_row IS TABLE OF customer%ROWTYPE;
   v_curs t_customer_row;

   TYPE t_customer_update_row IS TABLE OF customer_update%ROWTYPE;
   v_cursu t_customer_update_row;

   TYPE t_customerw_row IS TABLE OF customerw%ROWTYPE;
   vv_cw t_customerw_row;

   TYPE t_customerw_update_row IS TABLE OF customerw_update%ROWTYPE;
   v_cwu t_customerw_update_row;

   TYPE t_corps_update_row IS TABLE OF corps_update%ROWTYPE;
   vv_cru t_corps_update_row;

   TYPE t_person_update_row IS TABLE OF person_update%ROWTYPE;
   vv_cpu t_person_update_row;

   TYPE t_customer_address_row IS TABLE OF customer_address%ROWTYPE;
   vv_ca t_customer_address_row;

   TYPE t_customer_address_update_row IS TABLE OF customer_address_update%ROWTYPE;
   vv_cau t_customer_address_update_row;

 ---------------------------------------------------------------------------------
  /*local procedure for save error to err$table*/
   PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CUSTOMER%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$         := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$           := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$            := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$          := 'I';
         v_cur_exceptions (i).isp                     := v_curs (v_indx).isp;
         v_cur_exceptions (i).rnk                     := v_curs (v_indx).rnk;
         --v_cur_exceptions (i).kf                    := v_curs (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CUSTOMER
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging;

   ---------------------------------------------------------------------------------
  /*local procedure for save error to err$table*/
   PROCEDURE error_logging_upd IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CUSTOMER_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).isp                   := v_cursu (v_indx).isp;
         v_cur_exceptions (i).rnk                   := v_cursu (v_indx).rnk;
         v_cur_exceptions (i).idupd                 := v_cursu (v_indx).idupd;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CUSTOMER_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_upd;
   ---------------------------------------------------------------------------------
  /*local procedure for save error to err$table*/
  PROCEDURE error_logging_cw IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CUSTOMERW%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).rnk                   := vv_cw (v_indx).rnk;
         v_cur_exceptions (i).tag                   := vv_cw (v_indx).tag;
         v_cur_exceptions (i).value                 := vv_cw (v_indx).value;
         v_cur_exceptions (i).isp                   := vv_cw (v_indx).isp;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CUSTOMERW
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_cw;

  ---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_cwu IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CUSTOMERW_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).rnk                    := v_cwu (v_indx).rnk;
         v_cur_exceptions (i).isp                    := v_cwu (v_indx).isp;
         v_cur_exceptions (i).chgdate                := v_cwu (v_indx).chgdate;
         v_cur_exceptions (i).effectdate             := v_cwu (v_indx).effectdate;
         v_cur_exceptions (i).doneby                 := v_cwu (v_indx).doneby;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CUSTOMERW_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_cwu;

  ---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_cu IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CORPS_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).idupd                 := vv_cru (v_indx).idupd;
         v_cur_exceptions (i).rnk                   := vv_cru (v_indx).rnk;
         v_cur_exceptions (i).nmk                   := vv_cru (v_indx).nmk;
         v_cur_exceptions (i).effectdate            := vv_cru (v_indx).effectdate;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CORPS_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_cu;

   ---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_pu IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_PERSON_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$      := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$        := SQLERRM(SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$         := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$       := 'I';
         v_cur_exceptions (i).idupd                := vv_cpu(v_indx).idupd;
         v_cur_exceptions (i).rnk                  := vv_cpu (v_indx).rnk;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_PERSON_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_pu;

    ---------------------------------------------------------------------------------
  /*local procedure for save error to err$table*/
   PROCEDURE error_logging_ca IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CUSTOMER_ADDRESS%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).rnk                   := vv_ca (v_indx).rnk;
         v_cur_exceptions (i).type_id               := vv_ca (v_indx).type_id;
         v_cur_exceptions (i).address               := vv_ca (v_indx).address;
         --v_cur_exceptions (i).isp                 := vv_ca (v_indx).isp;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CUSTOMER_ADDRESS
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_ca;

---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_cau IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CUSTOMER_ADDRESS_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$      := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$        := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$         := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$       := 'I';
         v_cur_exceptions (i).idupd                := vv_cau (v_indx).idupd;
         v_cur_exceptions (i).rnk                  := vv_cau (v_indx).rnk;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CUSTOMER_ADDRESS_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_cau;

  ---------------------------------------------------------------------------------

  begin

    begin
       for rec in cur loop
           v_counter                  := v_counter + 1;
           l_cur_ut(v_counter)        := rec.tab_name;

           mgr_utl.p_triggers_disable            (l_cur_ut(v_counter));
           mgr_utl.p_constraints_fk_disable      (l_cur_ut(v_counter));
           mgr_utl.p_ref_constraints_disable     (l_cur_ut(v_counter));
       end loop;
    end;
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
       BEGIN
         l_errtab := 'ERR$_CUSTOMER';
         l_tab    := 'CUSTOMER';
         l_migration_start_time := sysdate;
         l_start_time := current_timestamp;

         OPEN l_cur FOR
              'select
                     rukey(rnk) as rnk
                     ,tgr
                     ,custtype
                     ,country
                     ,nmk
                     ,nmkv
                     ,nmkk
                     ,codcagent
                     ,prinsider
                     ,okpo
                     ,adr
                     ,sab
                     ,c_reg
                     ,c_dst
                     ,rgtax
                     ,datet
                     ,adm
                     ,datea
                     ,stmt
                     ,case when date_on is null then to_date(''01.01.1970'',''dd.mm.yyyy'') else date_on end as date_on
                     ,date_off
                     ,notes
                     ,notesec
                     ,crisk
                     ,pincode
                     ,nd
                     ,rukey(rnkp) as rnkp
                     ,ise
                     ,fs
                     ,oe
                     ,ved
                     ,sed
                     ,lim
                     ,mb
                     ,rgadm
                     ,bc
                     ,branch
                     ,tobo
                     ,ruuser(isp) as isp
                     ,taxf
                     ,nompdv
                     ,k050
                     ,nrezid_code
                     ,'''||g_kf||''' as kf
              from '||pkf('customer');
         LOOP
           FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
             EXIT WHEN v_curs.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
            INSERT INTO bars.customer
                                      VALUES v_curs(indx);
          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
        v_curs.delete;
        END;
  ---------------------------------------------------------------------------------
      BEGIN
        --
        l_errtab := 'ERR$_CUSTOMER_UPDATE';
        l_tab    := 'CUSTOMER_UPDATE';
        --
        v_count  := 0;
        c_n      := 0;

        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;

          OPEN l_cur FOR
             'select
                      rukey(rnk) as rnk
                     ,custtype
                     ,country
                     ,nmk
                     ,nmkv
                     ,nmkk
                     ,codcagent
                     ,prinsider
                     ,okpo
                     ,adr
                     ,sab
                     ,c_reg
                     ,c_dst
                     ,rgtax
                     ,datet
                     ,adm
                     ,datea
                     ,stmt
                     ,case when date_on is null then trunc(sysdate) else date_on end as date_on
                     ,date_off
                     ,notes
                     ,notesec
                     ,crisk
                     ,pincode
                     ,chgdate
                     ,case when chgaction is null then 2 else chgaction end as chgaction
                     ,tgr
                     ,rukey(idupd) as idupd
                     ,ruuser(doneby) as doneby
                     ,branch
                     ,nd
                     ,rukey(rnkp) as rnkp
                     ,ise
                     ,fs
                     ,oe
                     ,ved
                     ,sed
                     ,lim
                     ,mb
                     ,rgadm
                     ,bc
                     ,tobo
                     ,ruuser(isp) as isp
                     ,taxf
                     ,nompdv
                     ,k050
                     ,effectdate
                     ,global_bdate
                     ,nrezid_code
                     ,'''||g_kf||''' as kf
              from '||pkf('customer_update');
                --
         LOOP
           FETCH l_cur BULK COLLECT INTO v_cursu LIMIT c_limit;
             EXIT WHEN v_cursu.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF v_cursu SAVE EXCEPTIONS
            INSERT INTO bars.customer_update
                                      VALUES v_cursu(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_upd ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
      -- Clear collection for v_cursu
          v_cursu.delete;
      END;
    --
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.customer_update;

    mgr_utl.reset_sequence('s_customer_update', l_max_idupd);
    --
 ---------------------------------------------------------------------------------
    BEGIN
      l_errtab   := 'ERR$_CUSTOMERW';
      l_tab      := 'CUSTOMERW';
      v_count    := 0;
      c_n        := 0;
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;
      --
      bc.go(g_kf);
      --
      OPEN l_cur FOR
          'select rukey(rnk) as rnk, tag, value, ruuser(isp) as isp
           from '||pkf('customerw');
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO vv_cw LIMIT c_limit;
           EXIT WHEN vv_cw.count = 0;

       BEGIN
        FORALL indx IN INDICES OF vv_cw SAVE EXCEPTIONS
          INSERT INTO bars.customerw
                                    VALUES vv_cw(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging_cw ();
       END;
        COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for vv_cw
       vv_cw.delete;
    END;
  ---------------------------------------------------------------------------------
    BEGIN
      l_errtab    := 'ERR$_CUSTOMERW_UPDATE';
      l_tab       := 'CUSTOMERW_UPDATE';
      v_count     := 0;
      c_n         := 0;
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

      -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
      mgr_utl.mantain_error_table(l_tab);

        OPEN l_cur FOR
           'select
                   rukey(rnk) as rnk
                   ,tag
                   ,value
                   ,ruuser(isp) as isp
                   ,chgdate
                   ,chgaction
                   ,ruuser(doneby) as doneby
                   ,rukey(idupd) as idupd
                   ,effectdate
                   ,'''||g_kf||''' as kf
            from '||pkf('customerw_update');
                --
         LOOP
           FETCH l_cur BULK COLLECT INTO v_cwu LIMIT c_limit;
             EXIT WHEN v_cwu.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF v_cwu SAVE EXCEPTIONS
            INSERT INTO bars.CUSTOMERW_UPDATE
                                      VALUES v_cwu(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_cwu ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
          dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
          dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for v_cwu
         v_cwu.delete;
    END;
      --
      bc.home();
      --
      select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.customerw_update;

      mgr_utl.reset_sequence('s_customerw_update', l_max_idupd);
      --
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTBANK';
    l_tab       := 'CUSTBANK';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    bc.go(g_kf);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate
             'insert
                  into custbank(
                       rnk,
                       mfo,
                       alt_bic,
                       bic,
                       rating,
                       kod_b,
                       dat_nd,
                       ruk,
                       telr,
                       buh,
                       telb,
                       num_nd)
              select
                       rukey(rnk) as rnk,
                       mfo,
                       alt_bic,
                       bic,
                       rating,
                       kod_b,
                       null,
                       ruk,
                       telr,
                       buh,
                       telb,
                       num_nd
              from '||pkf('custbank')||'  log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CORPS';
    l_tab       := 'CORPS';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate
              'insert
                  into corps(
                       rnk,
                       nmku,
                       ruk,
                       telr,
                       buh,
                       telb,
                       dov,
                       bdov,
                       edov,
                       nlsnew,
                       mainnls,
                       mainmfo,
                       mfonew,
                       tel_fax,
                       e_mail,
                       seal_id,
                       nmk)
                select rukey(rnk) as rnk,
                       nmku,
                       ruk,
                       telr,
                       buh,
                       telb,
                       dov,
                       bdov,
                       edov,
                       nlsnew,
                       mainnls,
                       mainmfo,
                       mfonew,
                       tel_fax,
                       e_mail,
                       seal_id,
                       nmk
                  from '||pkf('corps')||'  log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_PERSON';
    l_tab       := 'PERSON';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
     execute immediate
              'insert
                  into person(
                       rnk,
                       sex,
                       passp,
                       ser,
                       numdoc,
                       pdate,
                       organ,
                       bday,
                       bplace,
                       teld,
                       telw,
                       dov,
                       bdov,
                       edov,
                       cellphone,
                       date_photo,
                       cellphone_confirmed)
              select
                       rukey(rnk) as rnk,
                       sex,
                       passp,
                       ser,
                       numdoc,
                       pdate,
                       organ,
                       bday,
                       bplace,
                       teld,
                       telw,
                       dov,
                       bdov,
                       edov,
                       cellphone,
                       date_photo,
                       cellphone_confirmed
              from '||pkf('person')||' log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTBANK_UPDATE';
    l_tab       := 'CUSTBANK_UPDATE';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate
              'insert
                  into custbank_update
                    (idupd
                     ,chgaction
                     ,effectdate
                     ,chgdate
                     ,doneby
                     ,rnk
                     ,mfo
                     ,alt_bic
                     ,bic
                     ,rating
                     ,kod_b
                     ,dat_nd
                     ,ruk
                     ,telr
                     ,buh
                     ,telb
                     ,num_nd
                     ,kf)
              select
                      rukey(idupd) as idupd,
                      chgaction,
                      effectdate,
                      chgdate,
                      ruuser(doneby) as doneby,
                      rukey(rnk) as rnk,
                      mfo,
                      alt_bic,
                      bic,
                      rating,
                      kod_b,
                      dat_nd,
                      ruk,
                      telr,
                      buh,
                      telb,
                      num_nd,
                      '''||g_kf||''' as kf
              from '||pkf('custbank_update')||' log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    --
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.custbank_update;

    mgr_utl.reset_sequence('s_custbank_update', l_max_idupd);
    --
    trace('%s', get_errinfo(l_errtab));
    --
    end;
  ---------------------------------------------------------------------------------
    BEGIN
      l_errtab := 'ERR$_CORPS_UPDATE';
      l_tab    := 'CORPS_UPDATE';

      v_count  := 0;
      c_n      := 0;
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;
      --
      bc.go(g_kf);
      --
      mgr_utl.mantain_error_table('CORPS_UPDATE');
      --
           OPEN l_cur FOR
              'select
                     rukey(idupd) as idupd
                    ,chgaction
                    ,effectdate
                    ,chgdate
                    ,doneby
                    ,rukey(rnk) as rnk
                    ,nmku
                    ,ruk
                    ,telr
                    ,buh
                    ,telb
                    ,dov
                    ,bdov
                    ,edov
                    ,nlsnew
                    ,mainnls
                    ,mainmfo
                    ,mfonew
                    ,tel_fax
                    ,e_mail
                    ,seal_id
                    ,nmk
                    ,'''||g_kf||''' as kf
              from '||pkf('corps_update');

             LOOP
                FETCH l_cur BULK COLLECT INTO vv_cru LIMIT c_limit;
                 EXIT WHEN vv_cru.count = 0;

             BEGIN
              FORALL indx IN INDICES OF vv_cru SAVE EXCEPTIONS
                INSERT INTO bars.corps_update
                                          VALUES vv_cru(indx);

              EXCEPTION
                     WHEN bulk_exceptions THEN
                        c_n := c_n + SQL%ROWCOUNT;
                        error_logging_cu ();
             END;
              COMMIT;
                v_count := v_count + c_limit;
                dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
                dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

             END LOOP;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
             -- Clear collection for vv_cur_oper
             vv_cru.delete;
      END;
      --
      bc.home();
      --
      select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.corps_update;

      mgr_utl.reset_sequence('s_corps_update', l_max_idupd);
      --
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CORPS_ACC';
    l_tab       := 'CORPS_ACC';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    bc.home();
    --
    select nvl(max(id),0)+1 into l_max_id from bars.corps_acc;

    mgr_utl.reset_sequence('s_corps_acc', l_max_id);
    --
    bc.go(g_kf);
    --
    execute immediate
              'insert
                  into corps_acc
                    (id
                    ,rnk
                    ,mfo
                    ,nls
                    ,kv
                    ,comments
                    ,sw56_name
                    ,sw56_adr
                    ,sw56_code
                    ,sw57_name
                    ,sw57_adr
                    ,sw57_code
                    ,sw57_acc
                    ,sw59_name
                    ,sw59_adr
                    ,sw59_acc)
              select
                    s_corps_acc.nextval as id
                   ,rukey(rnk) as rnk
                   ,mfo
                   ,nls
                   ,kv
                   ,comments
                   ,sw56_name
                   ,sw56_adr
                   ,sw56_code
                   ,sw57_name
                   ,sw57_adr
                   ,sw57_code
                   ,sw57_acc
                   ,sw59_name
                   ,sw59_adr
                   ,sw59_acc
              from '||pkf('corps_acc')||' log errors reject limit unlimited';
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
   BEGIN
     l_errtab    := 'ERR$_PERSON_UPDATE';
     l_tab       := 'PERSON_UPDATE';
     v_count     := 0;
     c_n         := 0;
     l_migration_start_time := sysdate;
     l_start_time := current_timestamp;

      mgr_utl.mantain_error_table(l_tab);
      --
        OPEN l_cur FOR
              'select
                     rukey(idupd) as idupd
                    ,chgaction
                    ,effectdate
                    ,chgdate
                    ,doneby
                    ,rukey(rnk) as rnk
                    ,sex
                    ,passp
                    ,ser
                    ,numdoc
                    ,pdate
                    ,organ
                    ,bday
                    ,bplace
                    ,teld
                    ,telw
                    ,cellphone
                    ,bdov
                    ,edov
                    ,date_photo
                    ,actual_date
                    ,eddr_id
                    ,'''||g_kf||''' as kf
              from '||pkf('person_update');
       --
       LOOP
         FETCH l_cur BULK COLLECT INTO vv_cpu LIMIT c_limit;
           EXIT WHEN vv_cpu.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF vv_cpu SAVE EXCEPTIONS
          INSERT INTO bars.person_update
                                    VALUES vv_cpu(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging_pu ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
          dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
          dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
       vv_cpu.delete;
    END;
      --
      bc.home();
      --
      select trunc(nvl(max(idupd / 100), 0)) + 1 into  l_max_idupd from bars.person_update;

      mgr_utl.reset_sequence('s_person_update', l_max_idupd);
      --
      bc.go(g_kf);
      --
  ---------------------------------------------------------------------------------
    BEGIN
      l_errtab       := 'ERR$_CUSTOMER_ADDRESS';
      l_tab          := 'CUSTOMER_ADDRESS';
      v_count        := 0;
      c_n            := 0;
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

      mgr_utl.mantain_error_table(l_tab);
      --
      bc.go(g_kf);
      --
          OPEN l_cur FOR
              'select  to_number(rukey(rnk)) as rnk
                      ,type_id
                      ,country
                      ,zip
                      ,domain
                      ,region
                      ,locality
                      ,address
                      ,territory_id
                      ,locality_type
                      ,street_type
                      ,street
                      ,home_type
                      ,home
                      ,homepart_type
                      ,homepart
                      ,room_type
                      ,room
                      ,comm
              from '||pkf('customer_address');
                --
         LOOP
           FETCH l_cur BULK COLLECT INTO vv_ca LIMIT c_limit;
             EXIT WHEN vv_ca.count = 0;

         BEGIN
          FORALL indx IN INDICES OF vv_ca SAVE EXCEPTIONS
            INSERT INTO bars.customer_address
                                      VALUES vv_ca(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_ca();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for vv_ca
         vv_ca.delete;
     END;
  ---------------------------------------------------------------------------------
    BEGIN
      l_errtab    := 'ERR$_CUSTOMER_ADDRESS_UPDATE';
      l_tab       := 'CUSTOMER_ADDRESS_UPDATE';
      v_count     := 0;
      c_n         := 0;
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

      mgr_utl.mantain_error_table(l_tab);
      --
         OPEN l_cur FOR
              'select
                     rukey(idupd) as idupd
                    ,chgaction
                    ,effectdate
                    ,chgdate
                    ,ruuser(doneby) as doneby
                    ,rukey(rnk) as rnk
                    ,type_id
                    ,country
                    ,zip
                    ,domain
                    ,region
                    ,locality
                    ,address
                    ,territory_id
                    ,locality_type
                    ,street_type
                    ,street
                    ,home_type
                    ,home
                    ,homepart_type
                    ,homepart
                    ,room_type
                    ,room
                    ,'''||g_kf||''' as kf
              from '||pkf('customer_address_update');
                --
         LOOP
           FETCH l_cur BULK COLLECT INTO vv_cau LIMIT c_limit;
             EXIT WHEN vv_cau.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF vv_cau SAVE EXCEPTIONS
            INSERT INTO bars.customer_address_update
                                      VALUES vv_cau(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_cau();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for vv_cau
         vv_cau.delete;
    END;
      --
      bc.home();
      --
      select trunc(nvl(max(idupd / 100), 0)) + 1 into  l_max_idupd from bars.customer_address_update;

      mgr_utl.reset_sequence('s_customer_address_update', l_max_idupd);
      --
      bc.go(g_kf);
      --
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_BUSS';
    l_tab       := 'CUSTOMER_BUSS';

    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --

    execute immediate
              'insert
                  into customer_buss
                       (edrpou
                       ,mfo
                       ,rnk
                       ,bussline)
              select
                        edrpou
                       ,mfo
                       ,rukey(rnk) as rnk
                       ,bussline
              from '||pkf('customer_buss')||' log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_CATEGORY';
    l_tab       := 'CUSTOMER_CATEGORY';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
       execute immediate
              'insert
                  into customer_category (
                         rnk
                        ,category_id
                        ,dat_begin
                        ,dat_end
                        ,user_id )
              select
                          rukey(rnk) as rnk
                         ,category_id
                         ,dat_begin
                         ,dat_end
                         ,ruuser(user_id) as  user_id
              from '||pkf('customer_category')||' log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_EXTERN';
    l_tab       := 'CUSTOMER_EXTERN';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    bc.home();
    --
    select nvl(max(id),0)+1 into  l_id from bars.customer_extern;

    mgr_utl.reset_sequence('s_customerextern', l_id);
    --
    bc.go(g_kf);
    --
    execute immediate
              'insert
                  into customer_extern
                       (id
                       ,name
                       ,doc_type
                       ,doc_serial
                       ,doc_number
                       ,doc_date
                       ,doc_issuer
                       ,birthday
                       ,birthplace
                       ,sex
                       ,adr
                       ,tel
                       ,email
                       ,custtype
                       ,okpo
                       ,country
                       ,region
                       ,fs
                       ,ved
                       ,sed
                       ,ise
                       ,notes
                       ,rnk
                       ,detrnk)
              select
                        s_customerextern.nextval as id
                       ,name
                       ,doc_type
                       ,doc_serial
                       ,doc_number
                       ,doc_date
                       ,doc_issuer
                       ,birthday
                       ,birthplace
                       ,sex
                       ,adr
                       ,tel
                       ,email
                       ,custtype
                       ,okpo
                       ,country
                       ,region
                       ,fs
                       ,ved
                       ,sed
                       ,ise
                       ,notes
                       ,rnk
                       ,detrnk
              from '||pkf('customer_extern')||' log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_EXTERN_UPDATE';
    l_tab       := 'CUSTOMER_EXTERN_UPDATE';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate
              'insert
                  into customer_extern_update
                    (idupd
                     ,chgaction
                     ,effectdate
                     ,chgdate
                     ,doneby
                     ,id
                     ,name
                     ,doc_type
                     ,doc_serial
                     ,doc_number
                     ,doc_date
                     ,doc_issuer
                     ,birthday
                     ,birthplace
                     ,sex
                     ,adr
                     ,tel
                     ,email
                     ,custtype
                     ,okpo
                     ,country
                     ,region
                     ,fs
                     ,ved
                     ,sed
                     ,ise
                     ,notes
                     ,kf)
              select
                      rukey(idupd) as idupd,
                      chgaction,
                      effectdate,
                      chgdate,
                      ruuser(doneby) as doneby,
                      id,
                      name,
                      doc_type,
                      doc_serial,
                      doc_number,
                      doc_date,
                      doc_issuer,
                      birthday,
                      birthplace,
                      sex,
                      adr,
                      tel,
                      email,
                      custtype,
                      okpo,
                      country,
                      region,
                      fs,
                      ved,
                      sed,
                      ise,
                      notes,
                      '''||g_kf||''' as kf
         from '||pkf('customer_extern_update')||' log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    --
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.customer_extern_update;
    mgr_utl.reset_sequence('s_customer_extern_update', l_max_idupd);
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_REL';
    l_tab       := 'CUSTOMER_REL';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    bc.go(g_kf);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate
              'insert
                  into customer_rel
                     (rnk
                      ,rel_id
                      ,rel_rnk
                      ,rel_intext
                      ,vaga1
                      ,vaga2
                      ,type_id
                      ,position
                      ,first_name
                      ,middle_name
                      ,last_name
                      ,document_type_id
                      ,document
                      ,trust_regnum
                      ,trust_regdat
                      ,bdate
                      ,edate
                      ,notary_name
                      ,notary_region
                      ,sign_privs
                      ,sign_id
                      ,name_r)
              select
                      rukey(rnk) as rnk
                     ,rel_id
                     ,rukey(rel_rnk) as rel_rnk
                     ,rel_intext
                     ,vaga1
                     ,vaga2
                     ,type_id
                     ,position
                     ,first_name
                     ,middle_name
                     ,last_name
                     ,document_type_id
                     ,document
                     ,trust_regnum
                     ,trust_regdat
                     ,bdate
                     ,edate
                     ,notary_name
                     ,notary_region
                     ,sign_privs
                     ,sign_id
                     ,name_r
               from '||pkf('customer_rel')||' log errors reject limit unlimited';
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_REL_UPDATE';
    l_tab       := 'CUSTOMER_REL_UPDATE';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate
              'insert
                into customer_rel_update
                  ( idupd
                   ,chgdate
                   ,chgaction
                   ,doneby
                   ,rnk
                   ,rel_id
                   ,rel_rnk
                   ,rel_intext
                   ,vaga1
                   ,vaga2
                   ,type_id
                   ,position
                   ,first_name
                   ,middle_name
                   ,last_name
                   ,document_type_id
                   ,document
                   ,trust_regnum
                   ,trust_regdat
                   ,bdate
                   ,edate
                   ,notary_name
                   ,notary_region
                   ,sign_privs
                   ,sign_id
                   ,name_r
                   ,effectdate
                   ,global_bdate
                   ,kf)
              select
                    rukey(idupd) as idupd,
                    chgdate,
                    chgaction,
                    ruuser(doneby) as doneby,
                    rukey(rnk) as rnk,
                    rel_id,
                    rukey(rel_rnk) as rel_rnk,
                    rel_intext,
                    vaga1,
                    vaga2,
                    type_id,
                    position,
                    first_name,
                    middle_name,
                    last_name,
                    document_type_id,
                    document,
                    trust_regnum,
                    trust_regdat,
                    bdate,
                    edate,
                    notary_name,
                    notary_region,
                    sign_privs,
                    sign_id,
                    name_r,
                    effectdate,
                    global_bdate,
                    '''||g_kf||''' as kf
              from '||pkf('customer_rel_update')||' log errors reject limit unlimited';
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into  l_max_idupd from bars.customer_rel_update;
    --
    mgr_utl.reset_sequence('S_CUSTOMERRELUPDATE', l_max_idupd);
    --
    bc.go(g_kf);
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_RI';
    l_tab       := 'CUSTOMER_RI';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    bc.home();
    --
    select nvl(max(id), 0) + 1 into  l_id from bars.customer_ri;

    mgr_utl.reset_sequence('s_customer_ri', l_id);
    --
    bc.go(g_kf);
    --
    execute immediate
                'insert
                    into customer_ri
                      (id
                      ,idcode
                      ,doct
                      ,docs
                      ,docn
                      ,insform
                      ,k060
                      ,fileri
                      ,dateri)
                select
                      s_customer_ri.nextval as id
                     ,idcode
                     ,doct
                     ,docs
                     ,docn
                     ,insform
                     ,k060
                     ,fileri
                     ,dateri
                from '||pkf('customer_ri')||' log errors reject limit unlimited';
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
    begin
    l_errtab    := 'ERR$_CUSTOMER_RISK';
    l_tab       := 'CUSTOMER_RISK';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate
              'insert
                  into customer_risk
                    (rnk
                      ,risk_id
                      ,dat_begin
                      ,dat_end
                      ,user_id)
              select
                      rukey(rnk) as rnk
                      ,risk_id
                      ,dat_begin
                      ,dat_end
                      ,ruuser(user_id) as user_id
              from '||pkf('customer_risk')||' log errors reject limit unlimited';
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
        when others then
             rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
    trace('%s', get_errinfo(l_errtab));
    end;
  ---------------------------------------------------------------------------------
  --
  bc.home();
  --
  -- подстраиваем сиквенс под максимальное значение
  --
  select trunc(nvl(max(rnk / 100), 0)) + 1 into l_max_rnk
  from bars.customer;
  --
  mgr_utl.reset_sequence('S_CUSTOMER', l_max_rnk);

  trace('новое значение последовательности s_customer: %s', to_char(l_max_rnk));
  --
  --mgr_utl.finalize();
       begin
         v_counter:= 0;
           for rec in cur loop
               v_counter                  := v_counter + 1;
               l_cur_ut(v_counter)        := rec.tab_name;

               mgr_utl.enable_table_triggers        (l_cur_ut(v_counter));
               mgr_utl.p_constraints_fk_enable      (l_cur_ut(v_counter));
               mgr_utl.p_ref_constraints_enable     (l_cur_ut(v_counter));
           end loop;
      end;
  --
  trace('%s: finished', p);
  --
  end fill_customers_frl;

  --
  -- fill_customers - импорт клиентов
  --
 ------------------------------------------------------------------------------
  procedure fill_customer
  is
    l_tab                    VARCHAR2(30) DEFAULT 'CUSTOMER';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_rnk                NUMBER;

  begin
  trace('%s: entry point', p);
  --
  bc.go(g_kf);
  --
  mgr_utl.before_fill(l_tab);
  --
  mgr_utl.mantain_error_table(l_tab);
  --
    begin
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */
                  into bars.customer
              select /*+ parallel(8) */
                     rukey(rnk) as rnk
                     ,tgr
                     ,custtype
                     ,country
                     ,nmk
                     ,nmkv
                     ,nmkk
                     ,codcagent
                     ,prinsider
                     ,okpo
                     ,adr
                     ,sab
                     ,c_reg
                     ,c_dst
                     ,rgtax
                     ,datet
                     ,adm
                     ,datea
                     ,stmt
                     ,case when date_on is null then to_date(''01.01.1970'',''dd.mm.yyyy'') else date_on end as date_on
                     ,date_off
                     ,notes
                     ,notesec
                     ,crisk
                     ,pincode
                     ,nd
                     ,rukey(rnkp) as rnkp
                     ,ise
                     ,fs
                     ,oe
                     ,ved
                     ,sed
                     ,lim
                     ,mb
                     ,rgadm
                     ,bc
                     ,branch
                     ,tobo
                     ,ruuser(isp) as isp
                     ,taxf
                     ,nompdv
                     ,k050
                     ,nrezid_code
                     ,'''||g_kf||''' as kf
              from '||pkf('customer'), 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception
        when others then
             rollback;
      mgr_utl.save_error();
    --
    commit;
    --
    end;
    --
  bc.home();
  --
  -- подстраиваем сиквенс под максимальное значение
  --
  select trunc(nvl(max(rnk / 100), 0)) + 1 into l_max_rnk
  from bars.customer;
  --
  mgr_utl.reset_sequence('S_CUSTOMER', l_max_rnk);

  trace('новое значение последовательности s_customer: %s', to_char(l_max_rnk));

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer;
---------------------------------------------------------------------------------
  procedure fill_customer_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                    VARCHAR2(30) DEFAULT 'CUSTOMER_UPDATE';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd              bars.CUSTOMER_UPDATE.idupd%type;

  begin
  trace('%s: entry point', p);
  --
  bc.go(g_kf);
  --
  mgr_utl.before_fill(l_tab);
  --
  -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
  mgr_utl.mantain_error_table(l_tab);

    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */
                  into bars.customer_update
              select /*+ parallel(8) */
                     rukey(rnk) as rnk
                     ,custtype
                     ,country
                     ,nmk
                     ,nmkv
                     ,nmkk
                     ,codcagent
                     ,prinsider
                     ,okpo
                     ,adr
                     ,sab
                     ,c_reg
                     ,c_dst
                     ,rgtax
                     ,datet
                     ,adm
                     ,datea
                     ,stmt
                     ,case when date_on is null then trunc(sysdate) else date_on end as date_on
                     ,date_off
                     ,notes
                     ,notesec
                     ,crisk
                     ,pincode
                     ,chgdate
                     ,case when chgaction is null then 2 else chgaction end as chgaction
                     ,tgr
                     ,rukey(idupd) as idupd
                     ,ruuser(doneby) as doneby
                     ,branch
                     ,nd
                     ,rukey(rnkp) as rnkp
                     ,ise
                     ,fs
                     ,oe
                     ,ved
                     ,sed
                     ,lim
                     ,mb
                     ,rgadm
                     ,bc
                     ,tobo
                     ,ruuser(isp) as isp
                     ,taxf
                     ,nompdv
                     ,k050
                     ,effectdate
                     ,global_bdate
                     ,nrezid_code
                     ,'''||g_kf||''' as kf
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception
        when others then
             rollback;
      mgr_utl.save_error();

    --
    commit;
    --
    end;
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.customer_update;

  mgr_utl.reset_sequence('s_customer_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_update;
  ---------------------------------------------------------------------------------
  procedure fill_customerw
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMERW';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */
                  into bars.customerw
              select /*+ parallel(8) */
                    rukey(rnk) as rnk, tag, value, ruuser(isp) as isp
              from '||pkf('customerw'), 'insert into '||l_tab);
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();

    end;
    --
    commit;
    --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customerw;
  ---------------------------------------------------------------------------------
  procedure fill_customerw_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMERW_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             bars.CUSTOMERW_UPDATE.idupd%type;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
                'insert /*+ append parallel(8) */
                    into bars.customerw_update
                select /*+ parallel(8) */
                         rukey(rnk) as rnk
                         ,tag
                         ,value
                         ,ruuser(isp) as isp
                         ,chgdate
                         ,chgaction
                         ,ruuser(doneby) as doneby
                         ,rukey(idupd) as idupd
                         ,effectdate
                         ,'''||g_kf||''' as kf
                from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();

    end;
    --
    commit;
    --
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.customerw_update;

  mgr_utl.reset_sequence('s_customerw_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customerw_update;
  ---------------------------------------------------------------------------------
  procedure fill_custbank
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTBANK';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
      execute_statement(
              'insert
                  into bars.custbank
              select
                       rukey(rnk) as rnk,
                       mfo,
                       alt_bic,
                       bic,
                       rating,
                       kod_b,
                       dat_nd,
                       ruk,
                       telr,
                       buh,
                       telb,
                       num_nd,
                       bki
                  from '||pkf('custbank'), 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_custbank;

  ---------------------------------------------------------------------------------
 procedure fill_corps
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CORPS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
              execute_statement(
              'insert into bars.corps
              select
                       rukey(rnk) as rnk,
                       nmku,
                       ruk,
                       telr,
                       buh,
                       telb,
                       dov,
                       bdov,
                       edov,
                       nlsnew,
                       mainnls,
                       mainmfo,
                       mfonew,
                       tel_fax,
                       e_mail,
                       seal_id,
                       nmk
              from '||pkf('corps'), 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_corps;
  ---------------------------------------------------------------------------------
 procedure fill_person
  is
    l_tab                   VARCHAR2(30) DEFAULT 'PERSON';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
              execute_statement(
              'insert
                  into bars.person
                  (rnk,
                    sex,
                    passp,
                    ser,
                    numdoc,
                    pdate,
                    organ,
                    bday,
                    bplace,
                    teld,
                    telw,
                    dov,
                    bdov,
                    edov,
                    cellphone,
                    date_photo,
                    cellphone_confirmed,
                    actual_date,
                    eddr_id
                    )
              select
                    rukey(rnk) as rnk,
                    sex,
                    passp,
                    ser,
                    numdoc,
                    pdate,
                    organ,
                    bday,
                    bplace,
                    teld,
                    telw,
                    dov,
                    bdov,
                    edov,
                    cellphone,
                    date_photo,
                    cellphone_confirmed,
                    actual_date,
                    eddr_id
              from '||pkf('person'), 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_person;
  ---------------------------------------------------------------------------------
 procedure fill_custbank_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTBANK_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             bars.CUSTBANK_UPDATE.idupd%type;
  begin
  --
  trace('%s: entry point', p);
  --
  bc.go(g_kf);
  --
  mgr_utl.before_fill(l_tab);
  --
  -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
  mgr_utl.mantain_error_table(l_tab);
  --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    execute_statement(
              'insert
                  into bars.custbank_update
              select
                    rukey(idupd) as idupd,
                    chgaction,
                    effectdate,
                    chgdate,
                    ruuser(doneby) as doneby,
                    rukey(rnk) as rnk,
                    mfo,
                    alt_bic,
                    bic,
                    rating,
                    kod_b,
                    dat_nd,
                    ruk,
                    telr,
                    buh,
                    telb,
                    num_nd,
                    '''||g_kf||''' as kf
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

     exception when others then
      rollback;
      mgr_utl.save_error();
     end;
    --
    commit;
    --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.custbank_update;

  mgr_utl.reset_sequence('s_custbank_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_custbank_update;
  ---------------------------------------------------------------------------------
 procedure fill_corps_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CORPS_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             bars.CORPS_UPDATE.idupd%type;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */
                  into bars.corps_update
              select  /*+ parallel(8) */
                    rukey(idupd) as idupd
                    ,chgaction
                    ,effectdate
                    ,chgdate
                    ,doneby
                    ,rukey(rnk) as rnk
                    ,nmku
                    ,ruk
                    ,telr
                    ,buh
                    ,telb
                    ,dov
                    ,bdov
                    ,edov
                    ,nlsnew
                    ,mainnls
                    ,mainmfo
                    ,mfonew
                    ,tel_fax
                    ,e_mail
                    ,seal_id
                    ,nmk
                    ,'''||g_kf||''' as kf
                    ,global_bdate 
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.corps_update;

  mgr_utl.reset_sequence('s_corps_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_corps_update;
  ---------------------------------------------------------------------------------
  procedure fill_corps_acc
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CORPS_ACC';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_id                NUMBER;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    bc.home();
    --
    select nvl(max(id), 0) + 1 into l_max_id from bars.corps_acc;

    mgr_utl.reset_sequence('s_corps_acc', l_max_id);
    --
    bc.go(g_kf);

    begin
              execute_statement(
              'insert
                  into bars.corps_acc
              select
                     s_corps_acc.nextval as id
                     ,rukey(rnk) as rnk
                     ,mfo
                     ,nls
                     ,kv
                     ,comments
                     ,sw56_name
                     ,sw56_adr
                     ,sw56_code
                     ,sw57_name
                     ,sw57_adr
                     ,sw57_code
                     ,sw57_acc
                     ,sw59_name
                     ,sw59_adr
                     ,sw59_acc
              from '||pkf('corps_acc'), 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_corps_acc;
  ---------------------------------------------------------------------------------
  procedure fill_person_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'PERSON_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             bars.PERSON_UPDATE.idupd%type;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */  into bars.person_update
              select /*+ parallel(8) */
                     rukey(idupd) as idupd
                     ,chgaction
                     ,effectdate
                     ,chgdate
                     ,doneby
                     ,rukey(rnk) as rnk
                     ,sex
                     ,passp
                     ,ser
                     ,numdoc
                     ,pdate
                     ,organ
                     ,bday
                     ,bplace
                     ,teld
                     ,telw
                     ,cellphone
                     ,bdov
                     ,edov
                     ,date_photo
                     ,actual_date
                     ,eddr_id
                     ,'''||g_kf||''' as kf
                     ,global_bdate 
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into  l_max_idupd from bars.person_update;

  mgr_utl.reset_sequence('s_person_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_person_update;
  ---------------------------------------------------------------------------------
  procedure fill_customer_address
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_ADDRESS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */  into bars.customer_address
              select /*+ parallel(8) */
                      to_number(rukey(rnk)) as rnk
                      ,type_id
                      ,country
                      ,zip
                      ,domain
                      ,region
                      ,locality
                      ,address
                      ,territory_id
                      ,locality_type
                      ,street_type
                      ,street
                      ,home_type
                      ,home
                      ,homepart_type
                      ,homepart
                      ,room_type
                      ,room
                      ,comm
              from '||pkf('customer_address'), 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_address;
 ---------------------------------------------------------------------------------
  procedure fill_customer_address_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_ADDRESS_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             customer_address_update.idupd%type;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */ into bars.customer_address_update
              select /*+ parallel(8) */
                     rukey(idupd) as idupd
                    ,chgaction
                    ,effectdate
                    ,chgdate
                    ,ruuser(doneby) as doneby
                    ,rukey(rnk) as rnk
                    ,type_id
                    ,country
                    ,zip
                    ,domain
                    ,region
                    ,locality
                    ,address
                    ,territory_id
                    ,locality_type
                    ,street_type
                    ,street
                    ,home_type
                    ,home
                    ,homepart_type
                    ,homepart
                    ,room_type
                    ,room
                    ,'''||g_kf||''' as kf
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into  l_max_idupd from bars.customer_address_update;

  mgr_utl.reset_sequence('s_customer_address_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_address_update;
 ---------------------------------------------------------------------------------
  procedure fill_customer_buss
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_BUSS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
              execute_statement(
              'insert into bars.customer_buss
              select
                       edrpou
                      ,mfo
                      ,rukey(rnk) as rnk
                      ,bussline
                      ,null as EDRPOU
              from '||pkf('customer_buss'), 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_buss;
 ---------------------------------------------------------------------------------
  procedure fill_customer_category
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_CATEGORY';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
              execute_statement(
              'insert into bars.customer_category
              select
                      rukey(rnk) as rnk
                     ,category_id
                     ,dat_begin
                     ,dat_end
                     ,ruuser(user_id) as  user_id
              from '||pkf('customer_category'), 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_category;
 ---------------------------------------------------------------------------------
  procedure fill_customer_extern
    is
    l_max_id  NUMBER;
  begin
    --mgr_utl.sync_table_auto('CUSTOMER_EXTERN',false,'ID,"rukey(ID)",RNK,"rukey(RNK)",detrnk,"rukey(detrnk)"');
    mgr_utl.sync_table_auto('CUSTOMER_EXTERN',false,'ID,"rukey(ID)",RNK,"rukey(RNK)"');      begin
            bc.home();
            select trunc(nvl(max(id / 100), 0)) + 1 into l_max_id
            from bars.customer_extern;
            mgr_utl.reset_sequence('s_customerextern', l_max_id);
          end;
  exception when others then
            rollback;
                 mgr_utl.save_error();
  end fill_customer_extern;
 ---------------------------------------------------------------------------------
  procedure fill_customer_extern_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_EXTERN_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             bars.CUSTOMER_EXTERN_UPDATE.idupd%type;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
        begin
         --      
         l_max_idupd := get_max_idupd(l_tab);
         --
         execute_statement(
              'insert into bars.customer_extern_update
               select
                      rukey(idupd) as idupd,
                      chgaction,
                      effectdate,
                      chgdate,
                      ruuser(doneby) as doneby,
                      rukey(id) as id,
                      name,
                      doc_type,
                      doc_serial,
                      doc_number,
                      doc_date,
                      doc_issuer,
                      birthday,
                      birthplace,
                      sex,
                      adr,
                      tel,
                      email,
                      custtype,
                      okpo,
                      country,
                      region,
                      fs,
                      ved,
                      sed,
                      ise,
                      notes,
                      '''||g_kf||''' as kf
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into  l_max_idupd from bars.customer_extern_update;

  mgr_utl.reset_sequence('s_customer_extern_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_extern_update;
 ---------------------------------------------------------------------------------
  procedure fill_customer_rel
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_REL';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
              execute_statement(
              'insert into bars.customer_rel
              select
                      rukey(rnk) as rnk
                     ,rel_id
                     ,rukey(rel_rnk) as rel_rnk
                     ,rel_intext
                     ,vaga1
                     ,vaga2
                     ,type_id
                     ,position
                     ,first_name
                     ,middle_name
                     ,last_name
                     ,document_type_id
                     ,document
                     ,trust_regnum
                     ,trust_regdat
                     ,bdate
                     ,edate
                     ,notary_name
                     ,notary_region
                     ,sign_privs
                     ,sign_id
                     ,name_r
                     ,position_r
              from '||pkf('customer_rel'), 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_rel;
 ---------------------------------------------------------------------------------
  procedure fill_customer_rel_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_REL_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             customer_rel_update.idupd%type;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
        --
        begin
         --      
         l_max_idupd := get_max_idupd(l_tab);
         --
             execute_statement(
              'insert into bars.customer_rel_update
              select
                      rukey(idupd) as idupd,
                      chgdate,
                      chgaction,
                      ruuser(doneby) as doneby,
                      rukey(rnk) as rnk,
                      rel_id,
                      rukey(rel_rnk) as rel_rnk,
                      rel_intext,
                      vaga1,
                      vaga2,
                      type_id,
                      position,
                      first_name,
                      middle_name,
                      last_name,
                      document_type_id,
                      document,
                      trust_regnum,
                      trust_regdat,
                      bdate,
                      edate,
                      notary_name,
                      notary_region,
                      sign_privs,
                      sign_id,
                      name_r,
                      effectdate,
                      global_bdate,
                      position_r,
                      '''||g_kf||''' as kf
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into  l_max_idupd from bars.customer_rel_update;
  --
  mgr_utl.reset_sequence('S_CUSTOMERRELUPDATE', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_rel_update;
 ---------------------------------------------------------------------------------
  procedure fill_customer_ri
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_RI';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_id                    customer_ri.id%type;
  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
        bc.home();
        --
        select nvl(max(id), 0) + 1 into  l_id from bars.customer_ri;

        mgr_utl.reset_sequence('s_customer_ri', l_id);
        --
        bc.go(g_kf);

    begin
              execute_statement(
              'insert into bars.customer_ri
              select
                      s_customer_ri.nextval as id
                     ,idcode
                     ,doct
                     ,docs
                     ,docn
                     ,insform
                     ,k060
                     ,fileri
                     ,dateri
              from '||pkf('customer_ri') ||
              ' log errors reject limit unlimited',
              'insert into '||l_tab);

    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --

  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_customer_ri;
 ---------------------------------------------------------------------------------
  procedure fill_customer_risk
  is
    l_tab                   VARCHAR2(30) DEFAULT 'CUSTOMER_RISK';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
              execute_statement(
              'insert into bars.customer_risk
              select
                      rukey(rnk) as rnk
                     ,risk_id
                     ,dat_begin
                     ,dat_end
                     ,ruuser(user_id) as user_id
              from '||pkf('customer_risk'), 'insert into '||l_tab);
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_customer_risk;

  procedure fill_customer_images
  is
    l_tab         VARCHAR2(30) DEFAULT 'CUSTOMER_IMAGES';
    l_max_rnk     bars.CUSTOMER_IMAGES.rnk%type;
  begin
   init();
   --bpa.disable_policies(l_tab);
   --
   select trunc(nvl(max(rnk / 100), 0)) + 1 
     into l_max_rnk
     from bars.CUSTOMER_IMAGES
    where mod(rnk, 100) = mgr_utl.get_ru();
   --
       mgr_utl.sync_table(p_table => 'CUSTOMER_IMAGES',
                          p_stmt => 'insert into CUSTOMER_IMAGES(rnk, type_img, date_img, image)
                                     select rukey(rnk) as rnk, type_img, date_img, image
                                     from '||pkf(l_tab)||' where rnk >= '||l_max_rnk,
                          p_delete => false);
   --bpa.enable_policies(l_tab);                      
  end fill_customer_images;

----------------------------- end customer----------------------------
  ----
  -- sync_ps - синхронизация плана счетов
  --
  procedure sync_ps
  is
    l_tab          VARCHAR2(30) DEFAULT 'PS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
              execute immediate
              'delete
                from ps
               where nbs not in (select nbs from '||pkf('ps')||')';
              --
              execute immediate
              'merge
               into ps p
               using '||pkf('ps')||' s
                 on (p.nbs=s.nbs)
               when matched then
                   update set p.xar       = s.xar,
                              p.pap       = nvl(s.pap,3),
                              p.name      = nvl(substr(s.name,1,175),''null''),
                              p.class     = nvl(s.class,99),
                              p.chknbs    = s.chknbs,
                              p.auto_stop = s.auto_stop,
                              p.d_close   = s.d_close,
                              p.sb        = s.sb
               when not matched then
                   insert (nbs, xar, pap, name, class, chknbs, auto_stop, d_close, sb)
                   values (s.nbs, s.xar, nvl(s.pap,3), nvl(substr(s.name,1,175),''null''), nvl(s.class,99),
                           s.chknbs, s.auto_stop, s.d_close, s.sb)';
              --
              commit;
        --
        -- TODO: Наполнить NBS_TIPS
    exception when others then
        rollback;
        mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_ps;

  ----
  -- sync_ps_sparam - синхронизация ps_sparam
  --
  procedure sync_ps_sparam
  is
    l_tab          VARCHAR2(30) DEFAULT 'ps_sparam';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;

  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        delete
          from ps_sparam;
        --
        execute immediate
        '
        insert
          into ps_sparam(nbs, spid, opt, sqlval)
        select nbs, spid, opt, sqlval
          from '||pkf('ps_sparam');
        --
        commit;
        --
    exception when others then
        rollback;
        mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_ps_sparam;

  ----
  -- sync_pos - синхронизирует таблицу pos
  --
  procedure sync_pos
  is
    l_tab          VARCHAR2(30) DEFAULT 'POS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        delete
          from pos;
        --
        execute immediate
        '
        insert
          into pos(pos, name)
        select pos, name
          from '||pkf('pos');
        --
        commit;
        --
    exception when others then
        rollback;
        mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_pos;

  ----
  -- sync_tips - синхронизирует таблицу tips
  --
  procedure sync_tips
  is
    l_tab          VARCHAR2(30) DEFAULT 'TIPS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        delete
          from tips;
        --
        execute immediate
        '
        insert
          into tips(tip, name, ord)
        select tip, name, ord
          from '||pkf('tips');
        --
        commit;
        --
    exception
      when others then
           rollback;
             mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_tips;

  ----
  -- sync_vids - синхронизирует таблицу vids
  --
  procedure sync_vids
  is
    l_tab          VARCHAR2(30) DEFAULT 'VIDS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        delete
          from vids;
        --
        execute immediate
        '
        insert
          into vids(vid, name)
        select vid, name
          from '||pkf('vids');
        --
        commit;
        --
    exception
        when others then
             rollback;
               mgr_utl.save_error();
    end;
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end sync_vids;

  ----
  -- sync_tabval$local - синхронизирует таблицу tabval$local
  --
  procedure sync_tabval$local
  is
    l_tab          VARCHAR2(30) DEFAULT 'TABVAL$LOCAL';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        delete
          from tabval$local
         where kf = g_kf;
        --
        execute immediate
        '
        insert
          into tabval$local (
               kf, kv, skv,
               s0000, s3800, s3801,
               s3802, s6201, s7201,
               s9282, s9280, s9281,
               s0009, g0000)
        select :g_kf, kv, skv,
               s0000, s3800, s3801,
               s3802, s6201, s7201,
               s9282, s9280, s9281,
               s0009, null
          from '||pkf('tabval$local')||' where kf = :g_kf'
        using g_kf, g_kf;
        --
        commit;
        --
    exception
        when others then
             rollback;
               mgr_utl.save_error();
    end;
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end sync_tabval$local;

    ----
    -- sync_accounts_field - синхронизирует таблицу accounts_field
    --
  procedure sync_accounts_field
  is
    begin
        --
        execute immediate 'alter table ACCOUNTSW  disable constraint FK_ACCOUNTSW_ACCOUNTSFIELD';
        --
        mgr_utl.sync_global_table(
           'ACCOUNTS_FIELD',
           'merge
             into accounts_field af
            using '||pkf('accounts_field')||' kaf
               on (af.tag = kaf.tag)
             when not matched then
                  insert (tag, name, deleted,use_in_arch)
                  values (kaf.tag, kaf.name, kaf.deleted, kaf.use_in_arch)'
            );
        --
        execute immediate 'alter table ACCOUNTSW  modify constraint FK_ACCOUNTSW_ACCOUNTSFIELD enable novalidate';
        --
  end sync_accounts_field;


    ----
    -- sync_dpa_nbs - синхронизирует таблицу dpa_nbs
    --
  procedure sync_dpa_nbs
  is
    l_tab          VARCHAR2(30) DEFAULT 'DPA_NBS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;

    begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        delete
          from dpa_nbs;
        --
        execute immediate
        '
        insert
          into dpa_nbs(type, nbs, taxotype)
        select type, nbs, taxotype
          from '||pkf('dpa_nbs');
        --
        commit;
        --
    exception
        when others then
             rollback;
               mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_dpa_nbs;

    ----
    -- sync_brates - синхронизирует таблицу brates
    --

  procedure sync_brates
  is
    l_tab          VARCHAR2(30) DEFAULT 'BRATES';
    l_max_br_id    brates.br_id%type;

  begin

   --select nvl(max(br_id),0)+1 into  l_max_br_id from bars.BRATES;
   --mgr_utl.reset_sequence('s_brates', l_max_br_id);

    mgr_utl.mantain_error_table(l_tab);

    bars_policy_adm.disable_policies(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

    mgr_utl.before_fill(l_tab);

    mgr_oschad.execute_statement(
    'insert into brates(name, inuse, formula, comm, br_type, br_id)
     select name,  inuse, formula, comm, br_type, br_id 
       from ' || mgr_utl.pkf('BRATES') || ' kb where not exists (select 1 from bars.brates bb where kb.br_id = bb.br_id)
     log errors reject limit unlimited',
    'Завантаження даних базових ставок '||l_tab);

    --execute immediate 'alter table DPT_VIDD modify constraint FK_DPTVIDD_BRATES enable novalidate';
    --execute immediate 'alter table MIGR_DPT_BR modify constraint FK_MIGRDPTBR_BR enable novalidate';
    mgr_utl.p_ref_constraints_en_novalid (l_tab);
    mgr_utl.trace('%s', mgr_utl.get_errinfo('err$_brates'));

    mgr_utl.finalize();

    bars_policy_adm.enable_policies(l_tab);

    -- подстраиваем последовательность
    bc.home();
    select trunc(nvl(max(br_id), 0)) + 1 into l_max_br_id from bars.brates;
    --
    mgr_utl.reset_sequence('s_brates', l_max_br_id);
    --
    mgr_utl.trace('%s', mgr_utl.get_errinfo('ERR$_'||l_tab));
    --
  end sync_brates;

  procedure fill_br_tier_edit
  is
    l_tab          VARCHAR2(30) DEFAULT 'BR_TIER_EDIT';
  begin
      init();

      mgr_utl.before_clean(l_tab);

      bars_policy_adm.disable_policies(l_tab);

      /*execute_statement(
          'delete br_tier_edit
           where (br_id, bdate, kv, s, branch) in
                 (select br_id, bdate, kv, s, substr(branch, 1,8) from ' || pkf('br_tier_edit') || ')',
          'Очистка налаштувань значень ставок залежних від суми для МФО ' || g_kf ||' таблиця '||l_tab,  null, 'N');*/
        
        execute_statement(
          'delete br_tier_edit
           where kf = '''||g_kf||'''',
          'Очистка налаштувань значень ставок залежних від суми для МФО ' || g_kf ||' таблиця '||l_tab,  null, 'N');
      
      mgr_utl.finalize();
      mgr_utl.before_fill('br_tier_edit');

      execute_statement(
          'insert into br_tier_edit(br_id, bdate, kv, s, rate, kf)
            select bne.br_id, bne.bdate, bne.kv, bne.s, bne.rate, '''||g_kf||''' as kf from brates b, '||pkf('br_tier_edit')||' bne where b.br_id = bne.br_id',
          'Заповнення налаштувань значень ставок залежних від суми для МФО ' || g_kf|| ' таблиця '||l_tab);

      mgr_utl.finalize();

      bars_policy_adm.enable_policies(l_tab);
  end fill_br_tier_edit;

   procedure fill_br_normal_edit
    is
    l_tab          VARCHAR2(30) DEFAULT 'BR_NORMAL_EDIT';

   begin
        init();

        mgr_utl.before_clean(l_tab);

        bars_policy_adm.disable_policies(l_tab);

        /*execute_statement( p_statement         => 'delete br_normal_edit where (branch, br_id, bdate, kv) in (select substr(branch, 1,8), br_id, bdate, kv from ' || pkf('br_normal_edit') || ')',
                           p_log_label         => 'Очистка налаштувань значень ставок залежних від дати для МФО ' || g_kf ||' таблиця '||l_tab,
                           p_table_name        => l_tab,
                           p_mgr_log_label     => 'N'
                         );*/
        execute_statement( p_statement         => 'delete br_normal_edit where kf = '''||g_kf||'''',
                           p_log_label         => 'Очистка налаштувань значень ставок залежних від дати для МФО ' || g_kf ||' таблиця '||l_tab,
                           p_table_name        => l_tab,
                           p_mgr_log_label     => 'N'   
                         );              
        mgr_utl.finalize();
        mgr_utl.before_fill(l_tab);

        execute_statement( p_statement         => 'insert into br_normal_edit(rate, kv, br_id, bdate, kf) select bne.rate, bne.kv, bne.br_id, bne.bdate, '''||g_kf||''' as kf from brates b, '||pkf('br_normal_edit')||' bne where b.br_id = bne.br_id',
                           p_log_label         => 'Заповнення налаштувань значень ставок залежних від дати для МФО ' || g_kf ||' таблиця '||l_tab,
                           p_table_name        => l_tab,
                           p_mgr_log_label     => 'Y'
                         );
        mgr_utl.finalize();

        bars_policy_adm.enable_policies(l_tab);
   end fill_br_normal_edit;


  procedure fill_int_accn
  is
    l_tab          VARCHAR2(30) DEFAULT 'INT_ACCN';


  begin
    --
    init();
    --
        mgr_utl.mantain_error_table(l_tab);

        mgr_utl.sync_table('int_accn',
        'insert into int_accn(acc, id, metr, basem, basey, freq, stp_dat, acr_dat, apl_dat, tt, acra, acrb, s, ttb, kvb, nlsb, mfob, namb, nazn, io, idu, idr, kf, okpo)
         select rukey(acc) as acc, id, metr, basem, nvl(basey,0) as basey, nvl(freq,2) as freq, stp_dat, nvl(acr_dat,to_date(''01.01.1900'',''dd.mm.yyyy'')), apl_dat, tt,
         rukey(acra) as acra, rukey(acrb) as acrb, nvl(s,0) as s, ttb, kvb, nlsb, mfob, namb, nazn, io, idu, idr, '''||g_kf||''' as kf, okpo
         from  '||pkf('int_accn') ||
       ' log errors reject limit unlimited', true);
        --
        trace('%s', get_errinfo('ERR$_'||l_tab));
        --
  end fill_int_accn;

  procedure fill_int_accn_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab          VARCHAR2(30) DEFAULT 'INT_ACCN_UPDATE';
    l_max_idupd    bars.INT_ACCN_UPDATE.idupd%type;

  begin
    --
    init();
    --
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
        mgr_utl.mantain_error_table(l_tab);
        --
        mgr_utl.sync_table(l_tab,
        'insert into INT_ACCN_UPDATE
         select rukey(idupd) as idupd, chgaction, effectdate, chgdate, ruuser(doneby) as doneby, rukey(acc) as acc, id, metr, basem, basey, freq, stp_dat,
         acr_dat, apl_dat, tt, rukey(acra) as acra, rukey(acrb) as acrb, s, ttb, kvb, nlsb, mfob, namb, nazn, io, idu, idr, '''||g_kf||''' as kf, okpo, global_bdate
         from  '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd ||
       ' log errors reject limit unlimited', false);

    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.int_accn_update;
    --
    mgr_utl.reset_sequence('s_intaccn_update', l_max_idupd);
    --
    trace('%s', get_errinfo('ERR$_'||l_tab));
    --
  end fill_int_accn_update;

  procedure fill_int_ratn
  is

  begin
    --
    init();
    --
      mgr_utl.sync_table('int_ratn',
      'insert into int_ratn(acc, id, bdat, ir, br, op, idu, kf)
       select rukey(acc) as acc, id, bdat, ir, br, op, idu, ''' || g_kf || ''' as kf
       from  ' || pkf('int_ratn'), true);
  end fill_int_ratn;

  procedure fill_int_ratn_arc
  is
    l_tab                          VARCHAR2(30) DEFAULT 'INT_RATN_ARC';
    p                              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                        PLS_INTEGER := 0;
    c_limit                        PLS_INTEGER := 50000;
    l_cur                          SYS_REFCURSOR;
    c_n                            PLS_INTEGER := 0;
    l_max_idupd                    INT_RATN_ARC.idupd%TYPE;
    l_migration_start_time         date default sysdate;
    l_start_time                   timestamp default current_timestamp;
    l_end_time                     timestamp default current_timestamp;
    l_rowcount                     number default 0;
    l_time_duration                interval day(3) to second(3);


   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_int_ratn_arc_row IS TABLE OF int_ratn_arc%ROWTYPE;
    v_curs t_int_ratn_arc_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_INT_RATN_ARC%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;
      v_indx             PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';

         v_cur_exceptions (i).acc                    := v_curs (v_indx).acc       ;
         v_cur_exceptions (i).id                     := v_curs (v_indx).id        ;
         v_cur_exceptions (i).bdat                   := v_curs (v_indx).bdat      ;
         v_cur_exceptions (i).ir                     := v_curs (v_indx).ir        ;
         v_cur_exceptions (i).br                     := v_curs (v_indx).br        ;
         v_cur_exceptions (i).op                     := v_curs (v_indx).op        ;
         v_cur_exceptions (i).idu                    := v_curs (v_indx).idu       ;
         v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat      ;
         v_cur_exceptions (i).vid                    := v_curs (v_indx).vid       ;
         v_cur_exceptions (i).idupd                  := v_curs (v_indx).idupd     ;
         v_cur_exceptions (i).kf                     := v_curs (v_indx).kf        ;
         v_cur_exceptions (i).effectdate             := v_curs (v_indx).effectdate;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_INT_RATN_ARC
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging;

  BEGIN
  --
  trace('%s: entry point', p);
  --
  mgr_utl.before_fill(l_tab);
  --
  -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
  mgr_utl.mantain_error_table(l_tab);
  --
  bpa.disable_policies(l_tab);

    BEGIN
    v_count  := 0;
    c_n      := 0;
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    OPEN l_cur FOR
        'select
          rukey(acc) as acc
         ,id
         ,bdat
         ,ir
         ,br
         ,op
         ,ruuser(idu) as idu
         ,fdat
         ,vid
         ,rukey(idupd) as idupd
         ,'''||g_kf||''' as kf
         ,effectdate
         ,global_bdate 
       from '||pkf('int_ratn_arc');
      --
     LOOP
       FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
         EXIT WHEN v_curs.COUNT = 0;

     BEGIN
      FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
        INSERT INTO bars.int_ratn_arc
                                  VALUES v_curs(indx);

      EXCEPTION
             WHEN bulk_exceptions THEN
                c_n := c_n + SQL%ROWCOUNT;
                error_logging ();
     END;
      COMMIT;
        v_count := v_count + c_limit;
      dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
      dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

     END LOOP;
     l_rowcount := l_cur%rowcount;
     CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
     -- Clear collection for v_curs
     v_curs.delete;
     END;
  --
  -- trace('подстраиваем сиквенс s_int_ratn_arc под максимальное значение');
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from int_ratn_arc;
  --
  -- trace('новое значение последовательности s_int_ratn_arc: %s', to_char(l_max_idupd));
  --
  mgr_utl.reset_sequence('s_int_ratn_arc', l_max_idupd);

  --  trace('собираем статистику');

  --  mgr_utl.gather_table_stats (ownname => 'BARS', tabname => 'INT_RATN_ARC',  cascade=>true);

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  bpa.enable_policies(l_tab);
  --
  end fill_int_ratn_arc;

  ----
  -- sync_banks$base - синхронизирует таблицу banks$base
  --
  procedure sync_banks$base
  is
    l_tab          VARCHAR2(30) DEFAULT 'BANKS$BASE';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        execute immediate
        '
        merge
         into banks$base b
        using '||pkf('banks')||' s
           on (b.mfo=s.mfo)
         when matched then
              update
                 set b.sab  = s.sab,
                     b.nb   = s.nb,
                     b.kodg = s.kodg,
                     b.blk  = s.blk,
                     b.mfou = s.mfou,
                     b.ssp  = s.ssp,
                     b.nmo  = s.nmo
         when not matched then
              insert (mfo, sab, nb, kodg, blk, mfou, ssp, nmo)
              values (s.mfo, s.sab, s.nb, s.kodg, s.blk, s.mfou, s.ssp, s.nmo)';
        --
        commit;
        --
    exception
        when others then
             rollback;
               mgr_utl.save_error();
    end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_banks$base;

  ----
  -- sync_sw_banks - синхронизирует таблицу sw_banks
  --
  procedure sync_sw_banks
  is
    l_tab          VARCHAR2(30) DEFAULT 'SW_BANKS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
      begin
          --
          execute immediate
          '
          merge
           into sw_banks b
          using '||pkf('sw_banks')||' s
             on (b.bic=s.bic)
           when matched then
                update
                   set
                       b.name      = s.name,
                       b.office    = s.office,
                       b.city      = s.city,
                       b.country   = s.country,
                       b.chrset    = s.chrset,
                       b.transback = s.transback
           when not matched then
                insert (bic, name, office, city, country, chrset, transback)
                values (s.bic, s.name, s.office, s.city, s.country, s.chrset, s.transback)';
          --
          trace('%s: %s rows merged', p, to_char(sql%rowcount));
          --
          commit;
          --
      exception when others then
          rollback;
          mgr_utl.save_error();
      end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_sw_banks;


  ----
  -- sync_basey - синхронизирует таблицу basey
  --
  procedure sync_basey
  is
    l_tab          VARCHAR2(30) DEFAULT 'BASEY';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
      --
      trace('%s: entry point', p);
      --
      bc.home();
      --
      mgr_utl.before_clean(l_tab);
      --
      begin
          --
          execute immediate
          '
          merge
           into basey b
          using '||pkf('basey')||' s
             on (b.basey=s.basey)
           when matched then
                update
                   set
                       b.name      = s.name,
                       b.name_mb   = s.name_mb
           when not matched then
                insert (basey, name, name_mb)
                values (s.basey, s.name, s.name_mb)';
          --
          trace('%s: %s rows merged', p, to_char(sql%rowcount));
          --
          commit;
          --
      exception when others then
          rollback;
          mgr_utl.save_error();
      end;
      --
      mgr_utl.finalize();
      --
      trace('%s: finished', p);
      --
  end sync_basey;

  ----
  -- sync_sk - синхронизирует таблицу sk
  --
  procedure sync_sk
  is
    l_tab          VARCHAR2(30) DEFAULT 'SK';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
      begin
          --
          execute immediate
          '
          merge
           into sk b
          using '||pkf('sk')||' s
             on (b.sk=s.sk)
           when matched then
                update
                   set
                       b.name      = s.name,
                       b.d_close   = s.d_close
           when not matched then
                insert (sk, name, d_close)
                values (s.sk, s.name, s.d_close)';
          --
          trace('%s: %s rows merged', p, to_char(sql%rowcount));
          --
          commit;
          --
      exception when others then
          rollback;
          mgr_utl.save_error();
      end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_sk;

  ----
  -- sync_int_metr - синхронизирует таблицу int_metr
  --
  procedure sync_int_metr
  is
    l_tab          VARCHAR2(30) DEFAULT 'INT_METR';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.sync_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean(l_tab);
    --
      begin
          --
          execute immediate
          '
          merge
           into int_metr b
          using '||pkf('int_metr')||' s
             on (b.metr = s.metr)
           when matched then
                update
                   set b.name = s.name
           when not matched then
                insert (metr, name)
                values (s.metr, s.name)';
          --
          trace('%s: %s rows merged', p, to_char(sql%rowcount));
          --
          commit;
          --
      exception when others then
          rollback;
          mgr_utl.save_error();
      end;
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end sync_int_metr;

  ----
  -- clean_accounts - очистка счетов
  --
  -- и отключенных политиках
  --
  procedure clean_accounts
  is
    l_tab          VARCHAR2(30) DEFAULT 'ACCOUNTS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;
    l_max_acc      INTEGER;

    cursor cur is
          select table_name as tab_name
          from user_tables
          where lower(table_name) in ('specparam', 'specparam_update', 'specparam_int', 'specparam_int_update', 'accounts_update', 'accountsw_update');
    type t_cur_ut is table of user_tables.table_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;

  begin
  trace('%s: entry point', p);
  --
  bc.home();
  --
  --mgr_utl.before_clean(l_tab);
  --
    case when g_kf = g_glb_mfo then
        begin
           for rec in cur loop
                v_counter := v_counter + 1;
                l_cur_ut(v_counter) := rec.tab_name;

                mgr_utl.disable_table_triggers            (l_cur_ut(v_counter));
                mgr_utl.disable_foreign_keys              (l_cur_ut(v_counter));
                mgr_utl.mantain_error_table               (l_cur_ut(v_counter));
                mgr_utl.p_ref_constraints_disable         (l_cur_ut(v_counter));
                mgr_utl.p_table_truncate                  (l_cur_ut(v_counter));
           end loop;
                   begin
                     --обрабатываем отдельно для accounts т.к. ref partition
                     mgr_utl.disable_table_triggers   (l_tab);
                     mgr_utl.disable_foreign_keys     (l_tab);
                     mgr_utl.mantain_error_table      (l_tab);
                     --mgr_utl.p_ref_constraints_disable(l_tab);
                     mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab);
                     commit;
                    -- mgr_utl.p_ref_constraints_en_novalid  (l_tab);
                     mgr_utl.enable_foreign_keys           (l_tab);
                     mgr_utl.enable_table_triggers         (l_tab);

                   end;

        exception
           when others then
                rollback;
                  mgr_utl.save_error();
        end;
    else
        begin
        v_counter:= 0;
          for rec_del in cur loop
               v_counter := v_counter + 1;
               l_cur_ut(v_counter) := rec_del.tab_name;

               mgr_utl.disable_table_triggers       (l_cur_ut(v_counter));
               mgr_utl.disable_foreign_keys         (l_cur_ut(v_counter));
               mgr_utl.mantain_error_table          (l_cur_ut(v_counter));
               mgr_utl.p_ref_constraints_disable    (l_cur_ut(v_counter));
               mgr_utl.execute_immediate(ip_sql =>'delete from '|| l_cur_ut(v_counter)||'  where  kf = '||g_kf );
               --
               trace('%s: deleting '||l_cur_ut(v_counter), p);
               commit;
          end loop;

        exception
          when others then
               rollback;
                 mgr_utl.save_error();
        end;
         --
    end case;

  bc.home();
  --
  -- подстраиваем сиквенс под максимальное значение
  --
  select trunc(nvl(max(acc / 100), 0)) + 1 into l_max_acc
  from accounts;
  --
  mgr_utl.reset_sequence('S_ACCOUNTS', l_max_acc);

  --
  begin
   v_counter:= 0;
     for rec in cur loop
         v_counter                        := v_counter + 1;
         l_cur_ut(v_counter)              := rec.tab_name;

         mgr_utl.enable_table_triggers    (l_cur_ut(v_counter));
         mgr_utl.enable_foreign_keys      (l_cur_ut(v_counter));
         mgr_utl.p_ref_constraints_enable (l_cur_ut(v_counter));
     end loop;

  exception
        when others then
             rollback;
               mgr_utl.save_error();
  end;
  -- mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_accounts;

  ----
  -- fill_accounts - импорт счетов
  --
  procedure fill_accounts
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ACCOUNTS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_acc               accounts.acc%type;
    l_max_idupd             number(30);
    v_count                 pls_integer := 0;
    c_limit                 pls_integer := 50000;
    l_cur                   sys_refcursor;
    c_n                     pls_integer := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);


    bulk_exceptions   EXCEPTION;
    PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    TYPE t_accounts_row IS TABLE OF accounts%ROWTYPE;
    vv_cur_acc          t_accounts_row;

    TYPE t_accounts_update_row IS TABLE OF accounts_update%ROWTYPE;
    vv_cur_accu         t_accounts_update_row;

    TYPE t_accountsw_row IS TABLE OF accountsw%ROWTYPE;
    vv_cur_accw         t_accountsw_row;

    TYPE t_accountsw_update_row IS TABLE OF accountsw_update%ROWTYPE;
    vv_cur_accwu        t_accountsw_update_row;

    TYPE t_cur_s IS TABLE OF specparam%ROWTYPE;
    vv_cur_s            t_cur_s;

    TYPE t_specparam_update_row IS TABLE OF specparam_update%ROWTYPE;
    vv_cur_su           t_specparam_update_row;

    TYPE t_specparam_int_row IS TABLE OF specparam_int%ROWTYPE;
    vv_cur_si           t_specparam_int_row;

    TYPE t_specparam_int_update_row IS TABLE OF specparam_int_update%ROWTYPE;
    vv_cur_siu          t_specparam_int_update_row;

  ---------------------------------------------------------------------------------
   PROCEDURE error_logging_acc IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_ACCOUNTS%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).acc                   := vv_cur_acc (v_indx).acc;
         v_cur_exceptions (i).isp                   := vv_cur_acc (v_indx).isp;
         v_cur_exceptions (i).kf                    := vv_cur_acc (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_ACCOUNTS
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_acc;
 ---------------------------------------------------------------------------------
   PROCEDURE error_logging_accu IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_ACCOUNTS_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$      := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$        := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$         := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$       := 'I';
         v_cur_exceptions (i).acc                  := vv_cur_accu (v_indx).acc;
         v_cur_exceptions (i).rnk                  := vv_cur_accu (v_indx).rnk;
         v_cur_exceptions (i).kf                   := vv_cur_accu (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_ACCOUNTS_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_accu;
  --------------------------------------------------------------------------------
   PROCEDURE error_logging_accw IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_ACCOUNTSW%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).acc                   := vv_cur_accw (v_indx).acc;
         v_cur_exceptions (i).kf                    := vv_cur_accw (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_ACCOUNTSW
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_accw;
  ---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_accwu IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_ACCOUNTSW_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).idupd                  := vv_cur_accwu (v_indx).idupd;
         v_cur_exceptions (i).kf                     := vv_cur_accwu (v_indx).kf;
         v_cur_exceptions (i).effectdate             := vv_cur_accwu (v_indx).effectdate;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_ACCOUNTSW_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_accwu;
  ---------------------------------------------------------------------------------
     PROCEDURE error_logging_s IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_SPECPARAM%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).acc                   := vv_cur_s (v_indx).acc;
         v_cur_exceptions (i).kf                    := vv_cur_s (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_SPECPARAM
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_s;

   ---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_su IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_SPECPARAM_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).idupd                  := vv_cur_su (v_indx).idupd;
         v_cur_exceptions (i).kf                     := vv_cur_su (v_indx).kf;
         v_cur_exceptions (i).effectdate             := vv_cur_su (v_indx).effectdate;
         v_cur_exceptions (i).acc                    := vv_cur_su (v_indx).acc;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_SPECPARAM_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_su;
    ---------------------------------------------------------------------------------
    PROCEDURE error_logging_si IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_SPECPARAM_INT%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).acc                   := vv_cur_si (v_indx).acc;
         v_cur_exceptions (i).mfo                   := vv_cur_si (v_indx).mfo;
         v_cur_exceptions (i).kf                    := vv_cur_si (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_SPECPARAM_INT
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_si;
   ---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_siu IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_SPECPARAM_INT_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).idupd                  := vv_cur_siu (v_indx).idupd;
         v_cur_exceptions (i).kf                     := vv_cur_siu (v_indx).kf;
         v_cur_exceptions (i).acc                    := vv_cur_siu (v_indx).acc;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_SPECPARAM_INT_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_siu;
     ---------------------------------------------------------------------------------
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(
    'accountsw, accounts_update, specparam, specparam_update, specparam_int, accounts, accounts_update, accountsw_update');
       -- переводим отдельные ограничения целостности в отложенный режим
       --  execute immediate 'set constraint r_account_account deferred';

        /* лучше удаление и последующее создание
        execute immediate 'ALTER INDEX xak_accounts_nbs_ob22 UNUSABLE';
        execute immediate 'ALTER INDEX xak_accounts_branch UNUSABLE';
        execute immediate 'ALTER INDEX xak_accounts_accc UNUSABLE';
        execute immediate 'ALTER INDEX xak_accounts_tip UNUSABLE';
        execute immediate 'ALTER INDEX xak_accounts_nms UNUSABLE';
        execute immediate 'ALTER INDEX xak_accounts_rnk UNUSABLE';
        execute immediate 'ALTER INDEX xak_accounts_ftip UNUSABLE';
        execute immediate 'ALTER INDEX xak_accounts_kf_nlsalt_kv UNUSABLE';
        */

        BEGIN
        v_count  := 0;
        c_n      := 0;
        l_tab    := 'ACCOUNTS';
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;

        mgr_utl.mantain_error_table(l_tab);
        --
        trace('выполняем вставку в accounts');
        OPEN l_cur FOR
              'select
                      rukey(acc) as acc
                     ,kf
                     ,nls
                     ,kv
                     ,branch
                     ,nlsalt
                     ,nbs
                     ,nbs2
                     ,daos
                     ,dapp
                     ,ruuser(isp) as isp
                     ,nms
                     ,lim
                     ,ostb
                     ,ostc
                     ,ostf
                     ,ostq
                     ,dos
                     ,kos
                     ,dosq
                     ,kosq
                     ,pap
                     ,tip
                     ,vid
                     ,trcn
                     ,mdate
                     ,dazs
                     ,sec
                     ,rukey(accc) as accc
                     ,blkd
                     ,blkk
                     ,pos
                     ,seci
                     ,seco
                     ,grp
                     ,ostx
                     ,rukey(rnk) as rnk
                     ,notifier_ref
                     ,tobo
                     ,bdate
                     ,opt
                     ,ob22
                     ,dappq
                     ,send_sms
              from '||pkf('accounts');
              --
               LOOP
                 FETCH l_cur BULK COLLECT INTO vv_cur_acc LIMIT c_limit;
                   EXIT WHEN vv_cur_acc.COUNT = 0;

               BEGIN
                FORALL indx IN INDICES OF vv_cur_acc SAVE EXCEPTIONS
                  INSERT INTO bars.accounts
                                            VALUES vv_cur_acc(indx);

                EXCEPTION
                       WHEN bulk_exceptions THEN
                          c_n := c_n + SQL%ROWCOUNT;
                          error_logging_acc ();
               END;
                COMMIT;
                  v_count := v_count + c_limit;
                dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
                dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

               END LOOP;
               l_rowcount := l_cur%rowcount;
               CLOSE l_cur;

         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
               -- Clear collection for vv_cur_acc
               vv_cur_acc.delete;
    --
    trace('таблица accounts заполнена');
    --


       -- возвращаем ограничения целостности в немедленный режим проверки
       -- execute immediate 'set constraint r_account_account immediate';

       /*
        execute immediate 'ALTER INDEX xak_accounts_nbs_ob22 REBUILD';
        execute immediate 'ALTER INDEX xak_accounts_branch REBUILD';
        execute immediate 'ALTER INDEX xak_accounts_accc REBUILD';
        execute immediate 'ALTER INDEX xak_accounts_tip REBUILD';
        execute immediate 'ALTER INDEX xak_accounts_nms REBUILD';
        execute immediate 'ALTER INDEX xak_accounts_rnk REBUILD';
        execute immediate 'ALTER INDEX xak_accounts_ftip REBUILD';
        execute immediate 'ALTER INDEX xak_accounts_kf_nlsalt_kv REBUILD';

        */
       --
       -- trace('собираем статистику по accounts');
       --
       -- mgr_utl.gather_table_stats('bars', 'accounts', cascade=>true);
    END;
  ---------------------------------------------------------------------------------
  BEGIN
      v_count    := 0;
      c_n        := 0;
      l_tab      := 'ACCOUNTS_UPDATE';
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

    --
    bc.go(g_kf);
    --
    trace('%s: filling accounts_update ...', p);

    mgr_utl.mantain_error_table(l_tab);

    /*
    execute immediate 'ALTER INDEX i2_accountsupd UNUSABLE';
    execute immediate 'ALTER INDEX idx_accountsupd_gld_effd UNUSABLE';
    execute immediate 'ALTER INDEX xai_accountsupd_effdat UNUSABLE';
    */
    --
              OPEN l_cur FOR
              'select
                      rukey(acc) as acc
                     ,nls
                     ,nlsalt
                     ,kv
                     ,nbs
                     ,nbs2
                     ,daos
                     ,ruuser(isp) as isp
                     ,nms
                     ,pap
                     ,vid
                     ,dazs
                     ,blkd
                     ,blkk
                     ,chgdate
                     ,chgaction
                     ,pos
                     ,tip
                     ,grp
                     ,seci
                     ,seco
                     ,doneby
                     ,rukey(idupd) as idupd
                     ,lim
                     ,rukey(accc) as accc
                     ,tobo
                     ,branch
                     ,mdate
                     ,ostx
                     ,sec
                     ,rukey(rnk) as rnk
                     ,kf
                     ,effectdate
                     ,send_sms
                     ,ob22
                     ,globalbd
              from '||pkf('accounts_update');
                    --
             LOOP
               FETCH l_cur BULK COLLECT INTO vv_cur_accu LIMIT c_limit;
                 EXIT WHEN vv_cur_accu.COUNT = 0;

             BEGIN
              FORALL indx IN INDICES OF vv_cur_accu SAVE EXCEPTIONS
                INSERT INTO bars.accounts_update
                                          VALUES vv_cur_accu(indx);

              EXCEPTION
                     WHEN bulk_exceptions THEN
                        c_n := c_n + SQL%ROWCOUNT;
                        error_logging_accu ();
             END;
              COMMIT;
                v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

             END LOOP;
             l_rowcount := l_cur%rowcount;
             CLOSE l_cur;
     l_end_time := current_timestamp;
     l_time_duration:= (l_end_time - l_start_time);
     mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                  ,ip_migration_start_time          => l_migration_start_time
                                  ,ip_table_name                    => l_tab
                                  ,ip_operation                     => p
                                  ,ip_row_count                     => l_rowcount
                                  ,ip_task_start_time               => l_start_time
                                  ,ip_task_end_time                 => l_end_time
                                  ,ip_time_duration                 => l_time_duration
                                  ,ip_log_message                   => 'Done'
                                   );
    EXCEPTION
          WHEN OTHERS THEN
               --mgr_utl.save_error();
      mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                              ,ip_migration_start_time              => l_migration_start_time
                              ,ip_table_name                        => l_tab
                              ,ip_operation                         => p
                              ,ip_row_count                         => l_rowcount
                              ,ip_task_start_time                   => l_start_time
                              ,ip_task_end_time                     => l_end_time
                              ,ip_time_duration                     => l_time_duration
                              ,ip_log_message                       => 'Error'
                              );
    vv_cur_accu.delete;
    END;
    --
    bc.home();
    -- подстраиваем последовательность s_accounts_update
    select  trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.accounts_update;

    trace('%s: sequence max(accounts_update.idupd)=%s', p, to_char(l_max_idupd));
    --
    mgr_utl.reset_sequence('s_accounts_update', l_max_idupd);
    --
    --trace('%s: sequence S_ACCOUNTS_UPDATE adjusted', p);
    --
        /*
        execute immediate 'ALTER INDEX i2_accountsupd REBUILD';
        execute immediate 'ALTER INDEX idx_accountsupd_gld_effd REBUILD';
        execute immediate 'ALTER INDEX xai_accountsupd_effdat REBUILD';
        */
        --
        --trace('собираем статистику по accounts_update');
        --
        --mgr_utl.gather_table_stats('bars', 'accounts_update', cascade=>true);
        --
   ---------------------------------------------------------------------------------
    BEGIN
    v_count    := 0;
    c_n        := 0;
    l_tab      := 'ACCOUNTSW';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

       mgr_utl.mantain_error_table(l_tab);
       --
            OPEN l_cur FOR
              'select
                     rukey(acc) as acc
                    ,tag
                    ,case when tag = ''PK_PRCT'' and regexp_like(value,''^[0-9]+$'') and value <>''0''
                         then rukey(value)
                         else value
                     end as value
                    ,kf
              from '||pkf('ACCOUNTSW');
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_accw LIMIT c_limit;
               EXIT WHEN vv_cur_accw.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_accw SAVE EXCEPTIONS
              INSERT INTO bars.accountsw
                                        VALUES vv_cur_accw(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_accw ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;

     l_end_time := current_timestamp;
     l_time_duration:= (l_end_time - l_start_time);
     mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                  ,ip_migration_start_time          => l_migration_start_time
                                  ,ip_table_name                    => l_tab
                                  ,ip_operation                     => p
                                  ,ip_row_count                     => l_rowcount
                                  ,ip_task_start_time               => l_start_time
                                  ,ip_task_end_time                 => l_end_time
                                  ,ip_time_duration                 => l_time_duration
                                  ,ip_log_message                   => 'Done'
                                   );
    EXCEPTION
          WHEN OTHERS THEN
               --mgr_utl.save_error();
      mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                              ,ip_migration_start_time              => l_migration_start_time
                              ,ip_table_name                        => l_tab
                              ,ip_operation                         => p
                              ,ip_row_count                         => l_rowcount
                              ,ip_task_start_time                   => l_start_time
                              ,ip_task_end_time                     => l_end_time
                              ,ip_time_duration                     => l_time_duration
                              ,ip_log_message                       => 'Error'
                              );
           vv_cur_accw.delete;
    END;

   ---------------------------------------------------------------------------------
    BEGIN
    v_count    := 0;
    c_n        := 0;
    l_tab      := 'ACCOUNTSW_UPDATE';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    mgr_utl.mantain_error_table(l_tab);
    --
    OPEN l_cur FOR
      'select
              rukey(idupd) as idupd
              ,chgaction
              ,effectdate
              ,chgdate
              ,ruuser(doneby) as doneby
              ,rukey(acc) as acc
              ,tag
              ,value
              ,kf
      from '||pkf('accountsw_update');
   --
      LOOP
       FETCH l_cur BULK COLLECT INTO vv_cur_accwu LIMIT c_limit;
         EXIT WHEN vv_cur_accwu.COUNT = 0;

      BEGIN
      FORALL indx IN INDICES OF vv_cur_accwu SAVE EXCEPTIONS
        INSERT INTO bars.accountsw_update
                                  VALUES vv_cur_accwu(indx);

      EXCEPTION
             WHEN bulk_exceptions THEN
                c_n := c_n + SQL%ROWCOUNT;
                error_logging_accwu ();
      END;
      COMMIT;
        v_count := v_count + c_limit;
      dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
      dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

      END LOOP;
      l_rowcount := l_cur%rowcount;
      CLOSE l_cur;
     l_end_time := current_timestamp;
     l_time_duration:= (l_end_time - l_start_time);
     mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                  ,ip_migration_start_time          => l_migration_start_time
                                  ,ip_table_name                    => l_tab
                                  ,ip_operation                     => p
                                  ,ip_row_count                     => l_rowcount
                                  ,ip_task_start_time               => l_start_time
                                  ,ip_task_end_time                 => l_end_time
                                  ,ip_time_duration                 => l_time_duration
                                  ,ip_log_message                   => 'Done'
                                   );
    EXCEPTION
          WHEN OTHERS THEN
               --mgr_utl.save_error();
      mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                              ,ip_migration_start_time              => l_migration_start_time
                              ,ip_table_name                        => l_tab
                              ,ip_operation                         => p
                              ,ip_row_count                         => l_rowcount
                              ,ip_task_start_time                   => l_start_time
                              ,ip_task_end_time                     => l_end_time
                              ,ip_time_duration                     => l_time_duration
                              ,ip_log_message                       => 'Error'
                              );
      -- Clear collection for vv_cur_accwu
      vv_cur_accwu.delete;
    END;
   --
   bc.home();
   --
   select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from accountsw_update;
   --
   mgr_utl.reset_sequence('s_accountsw_update', l_max_idupd);
   ---------------------------------------------------------------------------------
    BEGIN
      v_count    := 0;
      c_n        := 0;
      l_tab      := 'SPECPARAM';
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

    trace('%s: filling SPECPARAM table', p);

    mgr_utl.mantain_error_table(l_tab);

          OPEN l_cur FOR
              'select
                      rukey(acc) as acc
                     ,r011
                     ,r013
                     ,s080
                     ,s180
                     ,s181
                     ,s190
                     ,s200
                     ,s230
                     ,s240
                     ,d020
                     ,kekd
                     ,ktk
                     ,kvk
                     ,idg
                     ,ids
                     ,sps
                     ,kbk
                     ,s120
                     ,s130
                     ,s250
                     ,nkd
                     ,s031
                     ,s182
                     ,istval
                     ,r014
                     ,k072
                     ,s090
                     ,kf
                     ,s270
                     ,s260
                     ,k150
                     ,r114
                     ,s280
                     ,s290
                     ,s370
                     ,d1#f9
                     ,nf#f9
                     ,z290
                     ,dp1
                     ,r012
                     ,s580
                     ,kvd
                     ,r016
              from '||pkf('specparam');
                --
         LOOP
           FETCH l_cur BULK COLLECT INTO vv_cur_s LIMIT c_limit;
             EXIT WHEN vv_cur_s.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF vv_cur_s SAVE EXCEPTIONS
            INSERT INTO bars.specparam
                                      VALUES vv_cur_s(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_s ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         vv_cur_s.delete;

    -- trace('собираем статистику');
    --
    -- mgr_utl.gather_table_stats('bars', 'specparam', cascade=>true);
    END;
   ---------------------------------------------------------------------------------
    BEGIN
    v_count    := 0;
    c_n        := 0;
    l_tab      := 'SPECPARAM_UPDATE';
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    trace('%s: filling SPECPARAM_UPDATE table', p);
    --
    mgr_utl.mantain_error_table(l_tab);

     /*
     execute immediate 'ALTER INDEX xai_specparamupd_effdat UNUSABLE';
     execute immediate 'ALTER INDEX xie_specparamupd_acc UNUSABLE';
     */
     --
     OPEN l_cur FOR
            'select
                   rukey(acc) as acc
                   ,r011
                   ,r013
                   ,s080
                   ,s180
                   ,s181
                   ,s190
                   ,s200
                   ,s230
                   ,s240
                   ,d020
                   ,fdat
                   ,ruuser(user_name) as user_name
                   ,rukey(idupd) as idupd
                   ,kf
                   ,s260
                   ,s270
                   ,r014
                   ,k072
                   ,z290
                   ,s250
                   ,s090
                   ,nkd
                   ,s031
                   ,k150
                   ,r114
                   ,s280
                   ,s290
                   ,s370
                   ,effectdate
                   ,r012
                   ,s580
                   ,istval
                   ,chgaction
                   ,global_bdate
                   ,s130
            from '||pkf('specparam_update');
            --
     LOOP
       FETCH l_cur BULK COLLECT INTO vv_cur_su LIMIT c_limit;
         EXIT WHEN vv_cur_su.COUNT = 0;

     BEGIN
      FORALL indx IN INDICES OF vv_cur_su SAVE EXCEPTIONS
        INSERT INTO bars.specparam_update
                                  VALUES vv_cur_su(indx);

      EXCEPTION
             WHEN bulk_exceptions THEN
                c_n := c_n + SQL%ROWCOUNT;
                error_logging_su ();
     END;
      COMMIT;
        v_count := v_count + c_limit;
        dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
        dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

     END LOOP;
     l_rowcount := l_cur%rowcount;
     CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
     -- Clear collection for vv_cur_su
     vv_cur_su.delete;

    /*
    execute immediate 'ALTER INDEX  xai_specparamupd_effdat REBUILD';
    execute immediate 'ALTER INDEX  xie_specparamupd_acc REBUILD';
    */

      --trace('собираем статистику');
      --
      --mgr_utl.gather_table_stats('bars', 'specparam_update', cascade=>true);
      --
    END;
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.specparam_update;
    --
    mgr_utl.reset_sequence('s_specparam_update', l_max_idupd);
   ---------------------------------------------------------------------------------
   BEGIN
      v_count    := 0;
      c_n        := 0;
      l_tab      := 'SPECPARAM_INT';
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

      trace('%s: filling SPECPARAM_INT table', p);

      mgr_utl.mantain_error_table(l_tab);

             OPEN l_cur FOR
             'select
                    rukey(acc) as acc
                   ,p080
                   ,ob22
                   ,mfo
                   ,r020_fa
                   ,kor
                   ,deb01
                   ,deb02
                   ,deb03
                   ,deb04
                   ,deb05
                   ,deb06
                   ,deb07
                   ,f_11
                   ,ob88
                   ,dd
                   ,rr
                   ,priocom_idcontract
                   ,priocom_cr_supplycode
                   ,priocom_kl_kpr
                   ,priocom_kod_bizn
                   ,priocom_ndog_z
                   ,priocom_currency_z
                   ,priocom_s040_z
                   ,priocom_s050_z
                   ,priocom_lsumm
                   ,typnls
                   ,kf
                   ,demand_brn
                   ,demand_cond_set
                   ,demand_kk
                   ,kredit_zarplata
              from '||pkf('specparam_int');
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO vv_cur_si LIMIT c_limit;
           EXIT WHEN vv_cur_si.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF vv_cur_si SAVE EXCEPTIONS
          INSERT INTO bars.specparam_int
                                    VALUES vv_cur_si(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging_si ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       vv_cur_si.delete;
    END;
   ---------------------------------------------------------------------------------
    BEGIN
      v_count    := 0;
      c_n        := 0;
      l_tab      := 'SPECPARAM_INT_UPDATE';
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
              OPEN l_cur FOR
              'select
                      rukey(acc) as acc
                     ,p080
                     ,ob22
                     ,ob88
                     ,mfo
                     ,r020_fa
                     ,fdat
                     ,ruuser(user_name) as user_name
                     ,rukey(idupd) as idupd
                     ,kf
              from '||pkf('SPECPARAM_INT_UPDATE');
                --
         LOOP
           FETCH l_cur BULK COLLECT INTO vv_cur_siu LIMIT c_limit;
             EXIT WHEN vv_cur_siu.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF vv_cur_siu SAVE EXCEPTIONS
            INSERT INTO bars.specparam_int_update
                                      VALUES vv_cur_siu(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_siu ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for vv_cur_siu
        vv_cur_siu.delete;

    --
    bc.home();
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.specparam_int_update;
    --
    END;
  ---------------------------------------------------------------------------------
  --
  bc.home();
  --
  -- trace('собираем статистику');
  --
  --mgr_utl.gather_table_stats('bars', 'accountsw', cascade=>true);
  --mgr_utl.gather_table_stats('bars', 'bank_acc', cascade=>true);
  --mgr_utl.gather_table_stats('bars', 'bic_acc',  cascade=>true);
  --mgr_utl.gather_table_stats('bars', 'int_ratn', cascade=>true);
  --mgr_utl.gather_table_stats('bars', 'int_accn', cascade=>true);
  --
  trace('подстраиваем сиквенс под максимальное значение');
  --
  select trunc(nvl(max(acc / 100), 0)) + 1 into l_max_acc
  from bars.accounts;
  --
  mgr_utl.reset_sequence('S_ACCOUNTS', l_max_acc);
  --
  trace('%s: sequence S_ACCOUNTS adjusted', p);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_accounts;

  ----
  -- fill_accounts - импорт счетов
  --

 procedure fill_accounts_prl
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ACCOUNTS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_acc               NUMBER;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
             p_statement =>'insert /*+ append parallel(8) */
                            into bars.accounts
                            select /*+ parallel(8) */
                                  rukey(acc) as acc
                                 ,kf
                                 ,nls
                                 ,kv
                                 ,branch
                                 ,nlsalt
                                 ,nbs
                                 ,nbs2
                                 ,daos
                                 ,dapp
                                 ,ruuser(isp) as isp
                                 ,nms
                                 ,lim
                                 ,ostb
                                 ,ostc
                                 ,ostf
                                 ,ostq
                                 ,dos
                                 ,kos
                                 ,dosq
                                 ,kosq
                                 ,pap
                                 ,tip
                                 ,vid
                                 ,trcn
                                 ,mdate
                                 ,dazs
                                 ,sec
                                 ,rukey(accc) as accc
                                 ,blkd
                                 ,blkk
                                 ,pos
                                 ,seci
                                 ,seco
                                 ,grp
                                 ,ostx
                                 ,rukey(rnk) as rnk
                                 ,notifier_ref
                                 ,tobo
                                 ,bdate
                                 ,opt
                                 ,ob22
                                 ,dappq
                                 ,send_sms
                            from '||pkf('accounts')||' log errors reject limit unlimited',
            p_log_label     => 'insert into '||l_tab,
            p_table_name    => l_tab,
            p_mgr_log_label => 'Y');
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();
  --
  -- подстраиваем сиквенс под максимальное значение
  --
    select trunc(nvl(max(acc / 100), 0)) + 1 into l_max_acc
    from accounts;
  --
    mgr_utl.reset_sequence('S_ACCOUNTS', l_max_acc);

    trace('новое значение последовательности S_ACCOUNTS: %s', to_char(l_max_acc));

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_accounts_prl;

 ---------------------------------------------------------------------------------
  procedure fill_accounts_frl
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ACCOUNTS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_acc               accounts.acc%TYPE;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

    bulk_exceptions   EXCEPTION;
    PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    TYPE t_cur_acc IS TABLE OF accounts%ROWTYPE;

    vv_cur_acc t_cur_acc;

 ---------------------------------------------------------------------------------
   PROCEDURE error_logging_acc IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_ACCOUNTS%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).acc                   := vv_cur_acc (v_indx).acc;
         v_cur_exceptions (i).isp                   := vv_cur_acc (v_indx).isp;
         v_cur_exceptions (i).kf                    := vv_cur_acc (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_ACCOUNTS
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_acc;
---------------------------------------------------------------------------------
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    --
        trace('выполняем вставку в accounts');
        --
        BEGIN
        v_count       := 0;
        c_n           := 0;
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;

        mgr_utl.mantain_error_table(l_tab);

        OPEN l_cur FOR
              'select
                      rukey(acc) as acc
                     ,kf
                     ,nls
                     ,kv
                     ,branch
                     ,nlsalt
                     ,nbs
                     ,nbs2
                     ,daos
                     ,dapp
                     ,ruuser(isp) as isp
                     ,nms
                     ,lim
                     ,ostb
                     ,ostc
                     ,ostf
                     ,ostq
                     ,dos
                     ,kos
                     ,dosq
                     ,kosq
                     ,pap
                     ,tip
                     ,vid
                     ,trcn
                     ,mdate
                     ,dazs
                     ,sec
                     ,rukey(accc) as accc
                     ,blkd
                     ,blkk
                     ,pos
                     ,seci
                     ,seco
                     ,grp
                     ,ostx
                     ,rukey(rnk) as rnk
                     ,notifier_ref
                     ,tobo
                     ,bdate
                     ,opt
                     ,ob22
                     ,dappq
                     ,send_sms
              from '||pkf('accounts');
                      --
               LOOP
                 FETCH l_cur BULK COLLECT INTO vv_cur_acc LIMIT c_limit;
                   EXIT WHEN vv_cur_acc.COUNT = 0;

               BEGIN
                FORALL indx IN INDICES OF vv_cur_acc SAVE EXCEPTIONS
                  INSERT INTO bars.accounts
                                            VALUES vv_cur_acc(indx);

                EXCEPTION
                       WHEN bulk_exceptions THEN
                          c_n := c_n + SQL%ROWCOUNT;
                          error_logging_acc ();
               END;
                COMMIT;
                  v_count := v_count + c_limit;
                dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
                dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
               END LOOP;
               l_rowcount := l_cur%rowcount;
               CLOSE l_cur;

         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for vv_cur_acc
         vv_cur_acc.delete;
        END;

  --
  trace('таблица accounts заполнена');
  --
  bc.home();
  --
  -- подстраиваем сиквенс под максимальное значение
  --
    select trunc(nvl(max(acc / 100), 0)) + 1 into l_max_acc
    from accounts;
  --
    mgr_utl.reset_sequence('S_ACCOUNTS', l_max_acc);

    trace('новое значение последовательности S_ACCOUNTS: %s', to_char(l_max_acc));

  mgr_utl.finalize();
  --
  trace('%s: finished', p);

  end fill_accounts_frl;

---------------------------------------------------------------------------------
  procedure fill_accounts_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ACCOUNTS_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             NUMBER;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
             p_statement =>'insert /*+ append parallel(8) */
                           into bars.accounts_update
                           select /*+ parallel(8) */
                                 rukey(acc) as acc
                                ,nls
                                ,nlsalt
                                ,kv
                                ,nbs
                                ,nbs2
                                ,daos
                                ,ruuser(isp) as isp
                                ,nms
                                ,pap
                                ,vid
                                ,dazs
                                ,blkd
                                ,blkk
                                ,chgdate
                                ,chgaction
                                ,pos
                                ,tip
                                ,grp
                                ,seci
                                ,seco
                                ,ruuser(doneby) as doneby
                                ,rukey(idupd) as idupd
                                ,lim
                                ,rukey(accc) as accc
                                ,tobo
                                ,branch
                                ,mdate
                                ,ostx
                                ,sec
                                ,rukey(rnk) as rnk
                                ,kf
                                ,effectdate
                                ,send_sms
                                ,ob22
                                ,globalbd
                            from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd||' log errors reject limit unlimited',
            p_log_label     => 'insert into '||l_tab,
            p_table_name    => l_tab,
            p_mgr_log_label => 'Y');
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
  --
  commit;
  --
  bc.home();
  --
  -- подстраиваем последовательность s_accounts_update
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd
  from bars.accounts_update;
  --
  trace('%s: sequence max(accounts_update.idupd)=%s', p, to_char(l_max_idupd));
  --
  mgr_utl.reset_sequence('s_accounts_update', l_max_idupd);
  --
  trace('%s: sequence S_ACCOUNTS_UPDATE adjusted', p);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_accounts_update;
---------------------------------------------------------------------------------
  procedure fill_accountsw
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ACCOUNTSW';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
             p_statement =>'insert /*+ append parallel(8) */
                            into bars.accountsw
                            select /*+ parallel(8) */
                                  rukey(acc) as acc
                                 ,tag
                                 ,case when tag = ''PK_PRCT'' and regexp_like(value,''^[0-9]+$'') and value <>''0''
                                       then rukey(value)
                                       else value
                                  end as value
                                 ,kf
                            from '||pkf('accountsw'),
            p_log_label     => 'insert into '||l_tab,
            p_table_name    => l_tab,
            p_mgr_log_label => 'Y');
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_accountsw;
---------------------------------------------------------------------------------
  procedure fill_accountsw_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ACCOUNTSW_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             NUMBER(30);

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
              execute_statement(
              'insert /*+ append parallel(8) */  into bars.accountsw_update
              select /*+ parallel(8) */
                     rukey(idupd) as idupd
                    ,chgaction
                    ,effectdate
                    ,chgdate
                    ,ruuser(doneby) as doneby
                    ,rukey(acc) as acc
                    ,tag
                    ,value
                    ,kf
             from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from accountsw_update;

  mgr_utl.reset_sequence('s_accountsw_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_accountsw_update;
---------------------------------------------------------------------------------
  procedure fill_specparam
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SPECPARAM';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
-- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */  into bars.specparam
              select /*+ parallel(8) */
                    rukey(acc) as acc
                   ,r011
                   ,r013
                   ,s080
                   ,s180
                   ,s181
                   ,s190
                   ,s200
                   ,s230
                   ,s240
                   ,d020
                   ,kekd
                   ,ktk
                   ,kvk
                   ,idg
                   ,ids
                   ,sps
                   ,kbk
                   ,s120
                   ,s130
                   ,s250
                   ,nkd
                   ,s031
                   ,s182
                   ,istval
                   ,r014
                   ,k072
                   ,s090
                   ,kf
                   ,s270
                   ,s260
                   ,k150
                   ,r114
                   ,s280
                   ,s290
                   ,s370
                   ,d1#f9
                   ,nf#f9
                   ,z290
                   ,dp1
                   ,r012
                   ,s580
                   ,null as kvd
                   --,kvd
                   ,r016
              from '||pkf('specparam'), 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_specparam;
---------------------------------------------------------------------------------
  procedure fill_specparam_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SPECPARAM_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             NUMBER(30);

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */  into bars.specparam_update
              select /*+ parallel(8) */
                     rukey(acc) as acc
                     ,r011
                     ,r013
                     ,s080
                     ,s180
                     ,s181
                     ,s190
                     ,s200
                     ,s230
                     ,s240
                     ,d020
                     ,fdat
                     ,ruuser(user_name) as user_name
                     ,rukey(idupd) as idupd
                     ,kf
                     ,s260
                     ,s270
                     ,r014
                     ,k072
                     ,z290
                     ,s250
                     ,s090
                     ,nkd
                     ,s031
                     ,k150
                     ,r114
                     ,s280
                     ,s290
                     ,s370
                     ,effectdate
                     ,r012
                     ,s580
                     ,istval
                     ,chgaction
                     ,global_bdate
                     ,s130
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.specparam_update;

  mgr_utl.reset_sequence('s_specparam_update', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_specparam_update;
---------------------------------------------------------------------------------
  procedure fill_specparam_int
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SPECPARAM_INT';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    bpa.disable_policies(l_tab);
    --
    begin
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */  into bars.specparam_int
              select /*+ parallel(8) */
                      rukey(acc) as acc
                    ,p080
                    ,ob22
                    ,mfo
                    ,r020_fa
                    ,kor
                    ,deb01
                    ,deb02
                    ,deb03
                    ,deb04
                    ,deb05
                    ,deb06
                    ,deb07
                    ,f_11
                    ,ob88
                    ,dd
                    ,rr
                    ,priocom_idcontract
                    ,priocom_cr_supplycode
                    ,priocom_kl_kpr
                    ,priocom_kod_bizn
                    ,priocom_ndog_z
                    ,priocom_currency_z
                    ,priocom_s040_z
                    ,priocom_s050_z
                    ,priocom_lsumm
                    ,typnls
                    ,kf
                    ,demand_brn
                    ,demand_cond_set
                    ,demand_kk
                    ,null as kredit_zarplata
                    --,kredit_zarplata
              from '||pkf('specparam_int'), 'insert into '||l_tab);
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bpa.enable_policies(l_tab);
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_specparam_int;
---------------------------------------------------------------------------------
 procedure fill_specparam_int_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SPECPARAM_INT_UPDATE';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_idupd             NUMBER(30);

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */ into bars.specparam_int_update
              select /*+ parallel(8) */
                     rukey(acc) as acc
                    ,p080
                    ,ob22
                    ,ob88
                    ,mfo
                    ,r020_fa
                    ,fdat
                    ,ruuser(user_name) as user_name
                    ,rukey(idupd) as idupd
                    ,kf
              from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, 'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();
  --
  select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.specparam_int_update;

  mgr_utl.reset_sequence('s_specparamintupdate', l_max_idupd);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_specparam_int_update;

------------------------------------------------------------------
  procedure fill_groups_staff
    is
    l_tab varchar2(50) default 'GROUPS_STAFF';

        begin
            --
            init();
            --
            mgr_utl.disable_table_triggers     (l_tab);
            mgr_utl.disable_foreign_keys       (l_tab);
            --
            mgr_utl.sync_table('GROUPS_STAFF',
            --
            'insert into bars.groups_staff
                    select
                             GetNewUserid('''||g_kf||''',idu) idu,
                             idg,
                             secg,
                             approve,
                             adate1,
                             adate2,
                             rdate1,
                             rdate2,
                             revoked,
                             GetNewUserid('''||g_kf||''', grantor) grantor,
                             sec_sel,
                             sec_cre,
                             sec_deb
                    from '||pkf('groups_staff')||' log errors reject limit unlimited',
            false);
  mgr_utl.enable_table_triggers(l_tab);
  mgr_utl.enable_foreign_keys(l_tab);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_groups_staff;

  ----
  -- clean_saldoa - очистка saldoa
  --
  --
  procedure clean_saldoa
  is
    l_tab          VARCHAR2(30) DEFAULT 'SALDOA';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    cursor cur is
          select partition_name
          from user_tab_partitions
          where table_name = 'SALDOA'
          order by partition_name desc;

    type t_cur_ut is table of user_tab_partitions.partition_name%type index by pls_integer;
    l_cur_ut t_cur_ut;

    v_counter integer := 0;

  begin
    --
    trace('%s: entry point', p);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

   case when g_kf = g_glb_mfo then
        begin
           for rec in cur loop
                v_counter := v_counter + 1;

                l_cur_ut(v_counter) := rec.partition_name;
                mgr_utl.p_partition_truncate(l_tab, l_cur_ut(v_counter));
            end loop;
         end;
    else
        begin
          for rec_del in cur loop
               mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
               --
               trace('%s: deleting '||l_tab, p);
               commit;
          end loop;
        end;
        --
    end case;
    --

  exception
    when others then
         rollback;
           mgr_utl.save_error();
  --
  bc.home();
  --
  mgr_utl.p_ref_constraints_enable(l_tab);
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
    --
  end clean_saldoa;

  ----
  -- fill_saldoa - импорт оборотов
  --
  --
  procedure fill_saldoa
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SALDOA';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;

    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

  bulk_exceptions   EXCEPTION;
  PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    TYPE t_saldoa_row IS TABLE OF saldoa%ROWTYPE;

    vv_cur_saldoa t_saldoa_row;

    PROCEDURE error_logging_saldoa IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_SALDOA%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).acc                   := vv_cur_saldoa (v_indx).acc;
         v_cur_exceptions (i).fdat                  := vv_cur_saldoa (v_indx).fdat;
         v_cur_exceptions (i).kf                    := vv_cur_saldoa (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_SALDOA
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging_saldoa;

  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
        BEGIN
          v_count   := 0;
          c_n       := 0;
          l_migration_start_time := sysdate;
          l_start_time := current_timestamp;

         mgr_utl.mantain_error_table(l_tab);
         --
              OPEN l_cur FOR
                    'select
                            rukey(acc) as acc
                            ,fdat
                            ,pdat
                            ,ostf
                            ,dos
                            ,kos
                            ,trcn
                            ,ostq
                            ,dosq
                            ,kosq
                            ,'''||g_kf||''' as kf
                    from '||pkf('saldoa');
  --
             LOOP
               FETCH l_cur BULK COLLECT INTO vv_cur_saldoa LIMIT c_limit;
                 EXIT WHEN vv_cur_saldoa.COUNT = 0;

             BEGIN
              FORALL indx IN INDICES OF vv_cur_saldoa SAVE EXCEPTIONS
                INSERT INTO bars.saldoa
                                          VALUES vv_cur_saldoa(indx);

              EXCEPTION
                     WHEN bulk_exceptions THEN
                        c_n := c_n + SQL%ROWCOUNT;
                        error_logging_saldoa ();
             END;
              COMMIT;
                v_count := v_count + c_limit;
             dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
             dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

             END LOOP;
             l_rowcount := l_cur%rowcount;
             CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
             vv_cur_saldoa.delete;
          END;
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  --trace('собираем статистику');
  --
 -- mgr_utl.gather_table_stats('bars', 'saldoa', cascade=>true);
  --
  trace('%s: finished', p);
  --
  end fill_saldoa;

  ----
  -- fill_saldoa_prl - импорт saldoa parallel wey
  --
  procedure fill_saldoa_prl(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SALDOA';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_min_fdat               bars.SALDOA.fdat%type;
    l_max_fdat               bars.SALDOA.fdat%type;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
       --
     /* select nvl(max(fdat), to_date('01.01.1975', 'dd.mm.yyyy')) 
        into l_min_fdat
        from SALDOA
       where kf = G_KF;
       -- 
      if l_min_fdat = to_date('01.01.1975', 'dd.mm.yyyy')
        then l_max_fdat := add_months(trunc(sysdate, 'mm'), -3);
        else l_max_fdat := sysdate + 100;
      end if;*/
       -- 
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute_statement(
              'insert /*+ append parallel(8) */  into bars.saldoa
               select /*+ parallel(8) */
                       rukey(acc) as acc
                      ,fdat
                      ,pdat
                      ,ostf
                      ,dos
                      ,kos
                      ,trcn
                      ,ostq
                      ,dosq
                      ,kosq
                      ,'''||g_kf||''' as kf
                 from '||pkf(l_tab, p_schema, p_dblink)||' 
                --where fdat > '''||l_min_fdat||'''
                --  and fdat < '''||l_max_fdat||''''
             ,'insert into '||l_tab);

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    exception when others then
      rollback;
      mgr_utl.save_error();
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_saldoa_prl;

  procedure fill_saldoz
  is

    begin
      init();
      mgr_utl.sync_table('SALDOZ',
                         'insert into saldoz(acc, fdat, dos, kos, dosq, kosq, kf)
                         select rukey(acc) as acc, fdat, dos, kos, dosq, kosq, '''||g_kf||''' as kf
                         from ' ||pkf('saldoz'),
                         false);
  end fill_saldoz;

  procedure fill_snap_balances
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SNAP_BALANCES';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

    /* "Exceptions encountered in FORALL" exception... */
    bulk_exceptions   EXCEPTION;
    PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
     */
    TYPE t_snap_balances_row IS RECORD(
         fdat     DATE
        ,kf       VARCHAR2(6)
        ,acc      INTEGER
        ,rnk      INTEGER
        ,ost      NUMBER(24)
        ,dos      NUMBER(24)
        ,kos      NUMBER(24)
        ,ostq     NUMBER(24)
        ,dosq     NUMBER(24)
        ,kosq     NUMBER(24)
        ) ;
    TYPE t_snap_balances IS TABLE OF t_snap_balances_row INDEX BY PLS_INTEGER;
    v_curs t_snap_balances;

    /*
    TYPE t_snap_balances_row IS TABLE OF snap_balances%ROWTYPE;
    v_curs t_snap_balances_row;
    */
  ---------------------------------------------------------------------------------
        /*local procedure for save error to err$table*/
     PROCEDURE error_logging IS
        /* Associative array type of the exceptions table... */
        TYPE t_cur_exception IS TABLE OF ERR$_SNAP_BALANCES%ROWTYPE INDEX BY PLS_INTEGER;

        v_cur_exceptions   t_cur_exception;

        v_indx          PLS_INTEGER;

        /* Emulate DML error logging behaviour... */
        PRAGMA AUTONOMOUS_TRANSACTION;
     BEGIN
        FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
           v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

           /* Populate as many values as available... */
           v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
           v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
           v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
           v_cur_exceptions (i).ora_err_optyp$         := 'I';
           v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
           v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
           v_cur_exceptions (i).acc                    := v_curs (v_indx).acc;

        END LOOP;

        /* Load the exceptions into the exceptions table... */
        FORALL i IN INDICES OF v_cur_exceptions
           INSERT INTO ERR$_SNAP_BALANCES
                VALUES v_cur_exceptions (i);

        COMMIT;
     END error_logging;

  BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
        --
     BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        --
        OPEN l_cur FOR
              'select
                      fdat,
                      '''||g_kf||''' as kf,
                      rukey(acc) as acc,
                      rukey(rnk) as rnk,
                      ost,
                      dos,
                      kos,
                      ostq,
                      dosq,
                      kosq
              from '||pkf('snap_balances');
              --from '||pkf('snap_balances')||' where fdat between to_date(''01.01.2016'', ''dd.mm.yyyy'') and  to_date(''01.01.2017'', ''dd.mm.yyyy'')';
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.snap_balances(fdat, kf, acc, rnk, ost, dos, kos, ostq, dosq, kosq)
                                    VALUES  ( v_curs(indx).fdat,
                                              v_curs(indx).kf,
                                              v_curs(indx).acc,
                                              v_curs(indx).rnk,
                                              v_curs(indx).ost,
                                              v_curs(indx).dos,
                                              v_curs(indx).kos,
                                              v_curs(indx).ostq,
                                              v_curs(indx).dosq,
                                              v_curs(indx).kosq);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
    END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_snap_balances;


 procedure fill_snap_balances_dt(p_date date default null, p_date_end date default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SNAP_BALANCES';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_date                  DATE;
    l_date_end              DATE;

    /* "Exceptions encountered in FORALL" exception... */
    bulk_exceptions   EXCEPTION;
    PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
     */
    TYPE t_snap_balances_row IS RECORD(
         fdat     DATE
        ,kf       VARCHAR2(6)
        ,acc      INTEGER
        ,rnk      INTEGER
        ,ost      NUMBER(24)
        ,dos      NUMBER(24)
        ,kos      NUMBER(24)
        ,ostq     NUMBER(24)
        ,dosq     NUMBER(24)
        ,kosq     NUMBER(24)
        ) ;
    TYPE t_snap_balances IS TABLE OF t_snap_balances_row INDEX BY PLS_INTEGER;
    v_curs t_snap_balances;

    /*
    TYPE t_snap_balances_row IS TABLE OF snap_balances%ROWTYPE;
    v_curs t_snap_balances_row;
    */
  ---------------------------------------------------------------------------------
        /*local procedure for save error to err$table*/
     PROCEDURE error_logging IS
        /* Associative array type of the exceptions table... */
        TYPE t_cur_exception IS TABLE OF ERR$_SNAP_BALANCES%ROWTYPE INDEX BY PLS_INTEGER;

        v_cur_exceptions   t_cur_exception;

        v_indx          PLS_INTEGER;

        /* Emulate DML error logging behaviour... */
        PRAGMA AUTONOMOUS_TRANSACTION;
     BEGIN
        FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
           v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

           /* Populate as many values as available... */
           v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
           v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
           v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
           v_cur_exceptions (i).ora_err_optyp$         := 'I';
           v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
           v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
           v_cur_exceptions (i).acc                    := v_curs (v_indx).acc;

        END LOOP;

        /* Load the exceptions into the exceptions table... */
        FORALL i IN INDICES OF v_cur_exceptions
           INSERT INTO ERR$_SNAP_BALANCES
                VALUES v_cur_exceptions (i);

        COMMIT;
     END error_logging;

  BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
     BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
        l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
        --
        OPEN l_cur FOR
              'select
                      fdat,
                      '''||g_kf||''' as kf,
                      rukey(acc) as acc,
                      rukey(rnk) as rnk,
                      ost,
                      dos,
                      kos,
                      ostq,
                      dosq,
                      kosq
              from '||pkf('snap_balances')||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.snap_balances(fdat, kf, acc, rnk, ost, dos, kos, ostq, dosq, kosq)
                                    VALUES  ( v_curs(indx).fdat,
                                              v_curs(indx).kf,
                                              v_curs(indx).acc,
                                              v_curs(indx).rnk,
                                              v_curs(indx).ost,
                                              v_curs(indx).dos,
                                              v_curs(indx).kos,
                                              v_curs(indx).ostq,
                                              v_curs(indx).dosq,
                                              v_curs(indx).kosq);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
    END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_snap_balances_dt;

  ----
  -- fill_snap_balances_prl - импорт snap_balances parallel wey
  --
  procedure fill_snap_balances_prl(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'SNAP_BALANCES';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_max_fdat              bars.SNAP_BALANCES.fdat%type;
    l_fdat_to               bars.SNAP_BALANCES.fdat%type;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
       --
      select nvl(max(fdat), to_date('31.12.2015', 'dd.mm.yyyy')) 
        into l_max_fdat
        from SNAP_BALANCES
       where kf = G_KF;
       -- 
       if l_max_fdat = to_date('31.12.2015', 'dd.mm.yyyy')
         then l_fdat_to := trunc(sysdate - 15);
       else l_fdat_to := to_date('31.12.2025', 'dd.mm.yyyy');
       end if;
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
    execute immediate
              'insert /*+ append parallel(8) */
              into bars.snap_balances(fdat,acc, rnk, ost, dos, kos, ostq, dosq, kosq, kf)
              select /*+ parallel(8) */
                     fdat,
                     rukey(acc) as acc,
                     rukey(rnk) as rnk,
                     ost,
                     dos,
                     kos,
                     ostq,
                     dosq,
                     kosq,
                     '''||g_kf||''' as kf
                from '||pkf(l_tab, p_schema, p_dblink)||' 
               where fdat > '''||l_max_fdat||'''
                 and fdat < '''||l_fdat_to||'''
               log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);
    trace('%s rows inserted', l_rowcount);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

    end;
    --
    commit;
    --
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_snap_balances_prl;

  --exec fill_agg_monbals(p_date => date '2015-10-01',  p_date_end =>  date '2015-12-31');
  --exec fill_agg_monbals(p_date => date '2015-01-01');
  procedure fill_agg_monbals
    is
    l_tab                   VARCHAR2(30) DEFAULT 'AGG_MONBALS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */
    TYPE t_agg_monbals_row IS RECORD(
         fdat     DATE
        ,kf       VARCHAR2(6)
        ,acc      INTEGER
        ,rnk      INTEGER
        ,ost      NUMBER(24)
        ,ostq     NUMBER(24)
        ,dos      NUMBER(24)
        ,dosq     NUMBER(24)
        ,kos      NUMBER(24)
        ,kosq     NUMBER(24)
        ,crdos    NUMBER(24)
        ,crdosq   NUMBER(24)
        ,crkos    NUMBER(24)
        ,crkosq   NUMBER(24)
        ,cudos    NUMBER(24)
        ,cudosq   NUMBER(24)
        ,cukos    NUMBER(24)
        ,cukosq   NUMBER(24)
        ) ;
    TYPE t_agg_monbals IS TABLE OF t_agg_monbals_row INDEX BY PLS_INTEGER;
    v_curs t_agg_monbals;

    /*
    TYPE t_agg_monbals_row IS TABLE OF agg_monbals%ROWTYPE;
    v_curs t_agg_monbals_row;
    */
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_AGG_MONBALS%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
         v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
         v_cur_exceptions (i).acc                    := v_curs (v_indx).acc;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_AGG_MONBALS
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        --
        OPEN l_cur FOR
          'select fdat,
                  '''||g_kf||''' as kf,
                  rukey(acc) as acc,
                  rukey(rnk) as rnk,
                  ost,
                  dos,
                  kos,
                  ostq,
                  dosq,
                  kosq,
                  crdos,
                  crdosq,
                  crkos,
                  crkosq,
                  cudos,
                  cudosq,
                  cukos,
                  cukosq
       from '||pkf('agg_monbals')||' where fdat >= to_date(''01.01.2016'', ''dd.mm.yyyy'')';
            --from '||pkf('agg_monbals');

       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.agg_monbals(fdat, kf, acc, rnk, ost, dos, kos, ostq, dosq, kosq, crdos, crdosq, crkos, crkosq, cudos, cudosq, cukos, cukosq)
                                   VALUES(v_curs(indx).fdat,
                                          v_curs(indx).kf,
                                          v_curs(indx).acc,
                                          v_curs(indx).rnk,
                                          v_curs(indx).ost,
                                          v_curs(indx).dos,
                                          v_curs(indx).kos,
                                          v_curs(indx).ostq,
                                          v_curs(indx).dosq,
                                          v_curs(indx).kosq,
                                          v_curs(indx).crdos,
                                          v_curs(indx).crdosq,
                                          v_curs(indx).crkos,
                                          v_curs(indx).crkosq,
                                          v_curs(indx).cudos,
                                          v_curs(indx).cudosq,
                                          v_curs(indx).cukos,
                                          v_curs(indx).cukosq);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_agg_monbals;

    procedure fill_agg_monbals_dt(p_date date default null, p_date_end date default null, p_schema varchar2 default null,  p_dblink varchar2 default null)
      is
      l_tab                   VARCHAR2(30) DEFAULT 'AGG_MONBALS';
      p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
      v_count                 PLS_INTEGER := 0;
      c_limit                 PLS_INTEGER := 50000;
      l_cur                   SYS_REFCURSOR;
      c_n                     PLS_INTEGER := 0;
      l_migration_start_time  date default sysdate;
      l_start_time            timestamp default current_timestamp;
      l_end_time              timestamp default current_timestamp;
      l_rowcount              number default 0;
      l_time_duration         interval day(3) to second(3);
      l_date                  DATE;
      l_date_end              DATE;


       /* "Exceptions encountered in FORALL" exception... */
       bulk_exceptions   EXCEPTION;
       PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

      /*
       * Source data record and associative array type. Needed to
       * enable LIMIT-based fetching...
      */
      TYPE t_agg_monbals_row IS RECORD(
           fdat     DATE
          ,kf       VARCHAR2(6)
          ,acc      INTEGER
          ,rnk      INTEGER
          ,ost      NUMBER(24)
          ,ostq     NUMBER(24)
          ,dos      NUMBER(24)
          ,dosq     NUMBER(24)
          ,kos      NUMBER(24)
          ,kosq     NUMBER(24)
          ,crdos    NUMBER(24)
          ,crdosq   NUMBER(24)
          ,crkos    NUMBER(24)
          ,crkosq   NUMBER(24)
          ,cudos    NUMBER(24)
          ,cudosq   NUMBER(24)
          ,cukos    NUMBER(24)
          ,cukosq   NUMBER(24)
          ) ;
      TYPE t_agg_monbals IS TABLE OF t_agg_monbals_row INDEX BY PLS_INTEGER;
      v_curs t_agg_monbals;

      /*
      TYPE t_agg_monbals_row IS TABLE OF agg_monbals%ROWTYPE;
      v_curs t_agg_monbals_row;
      */
  ---------------------------------------------------------------------------------
        /*local procedure for save error to err$table*/
      PROCEDURE error_logging IS
        /* Associative array type of the exceptions table... */
        TYPE t_cur_exception IS TABLE OF ERR$_AGG_MONBALS%ROWTYPE INDEX BY PLS_INTEGER;

        v_cur_exceptions   t_cur_exception;

        v_indx          PLS_INTEGER;

        /* Emulate DML error logging behaviour... */
        PRAGMA AUTONOMOUS_TRANSACTION;
      BEGIN
        FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
           v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

           /* Populate as many values as available... */
           v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
           v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
           v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
           v_cur_exceptions (i).ora_err_optyp$         := 'I';
           v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
           v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
           v_cur_exceptions (i).acc                    := v_curs (v_indx).acc;

        END LOOP;

        /* Load the exceptions into the exceptions table... */
        FORALL i IN INDICES OF v_cur_exceptions
           INSERT INTO ERR$_AGG_MONBALS
                VALUES v_cur_exceptions (i);

        COMMIT;
      END error_logging;

      BEGIN

      bc.go(g_kf);
      --
      mgr_utl.before_fill(l_tab);
      --
      -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
      mgr_utl.mantain_error_table(l_tab);
      --
      execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
      --
         BEGIN
          l_migration_start_time := sysdate;
          l_start_time           := current_timestamp;
          l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
          l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
          --
          OPEN l_cur FOR
            'select fdat,
                    '''||g_kf||''' as kf,
                    rukey(acc) as acc,
                    rukey(rnk) as rnk,
                    OST		,
                    OSTQ	,
                    DOS		,
                    DOSQ	,
                    KOS		,
                    KOSQ	,
                    CRDOS	,
                    CRDOSQ	,
                    CRKOS	,
                    CRKOSQ	,
                    CUDOS	,
                    CUDOSQ	,
                    CUKOS	,
                    CUKOSQ	
              from '||pkf(l_tab, p_schema,  p_dblink)||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
                --
         LOOP
           FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
             EXIT WHEN v_curs.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
            INSERT INTO bars.agg_monbals( fdat, kf, acc, rnk, OST		,OSTQ	,DOS		,DOSQ	, KOS		,KOSQ	,CRDOS	,
                     CRDOSQ	, CRKOS	,CRKOSQ	,CUDOS	,CUDOSQ	,CUKOS	, CUKOSQ)
                                     VALUES(v_curs(indx).fdat,
                                            v_curs(indx).kf,
                                            v_curs(indx).acc,
                                            v_curs(indx).rnk,
                                            v_curs(indx).OST		,
                                            v_curs(indx).OSTQ	,
                                            v_curs(indx).DOS		,
                                            v_curs(indx).DOSQ	,
                                            v_curs(indx).KOS		,
                                            v_curs(indx).KOSQ	,
                                            v_curs(indx).CRDOS	,
                                            v_curs(indx).CRDOSQ	,
                                            v_curs(indx).CRKOS	,
                                            v_curs(indx).CRKOSQ	,
                                            v_curs(indx).CUDOS	,
                                            v_curs(indx).CUDOSQ	,
                                            v_curs(indx).CUKOS	,
                                            v_curs(indx).CUKOSQ  );
          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
              dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
              dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
           l_end_time := current_timestamp;
           l_time_duration:= (l_end_time - l_start_time);
           mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                        ,ip_migration_start_time          => l_migration_start_time
                                        ,ip_table_name                    => l_tab
                                        ,ip_operation                     => p
                                        ,ip_row_count                     => l_rowcount
                                        ,ip_task_start_time               => l_start_time
                                        ,ip_task_end_time                 => l_end_time
                                        ,ip_time_duration                 => l_time_duration
                                        ,ip_log_message                   => 'Done'
                                         );
          EXCEPTION
                WHEN OTHERS THEN
                     --mgr_utl.save_error();
            mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                    ,ip_migration_start_time              => l_migration_start_time
                                    ,ip_table_name                        => l_tab
                                    ,ip_operation                         => p
                                    ,ip_row_count                         => l_rowcount
                                    ,ip_task_start_time                   => l_start_time
                                    ,ip_task_end_time                     => l_end_time
                                    ,ip_time_duration                     => l_time_duration
                                    ,ip_log_message                       => 'Error'
                                    );
         -- Clear collection for v_curs
        v_curs.delete;
        END;
    --
    bc.home();

    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
    end fill_agg_monbals_dt;

    ----
    -- fill_agg_monbals_prl - импорт agg_monbals parallel wey
    --
 procedure fill_agg_monbals_prl(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'AGG_MONBALS';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_min_fdat              bars.AGG_MONBALS.fdat%type;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
    --
        select nvl(max(add_months(fdat, 1)), to_date('01.01.2016', 'dd.mm.yyyy')) 
          into l_min_fdat
          from bars.AGG_MONBALS
         where kf = G_KF  ;
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    execute immediate 'ALTER SESSION SET NLS_DATE_FORMAT = ''DD.MM.YYYY''';
      
    if p_dblink is null then
    execute immediate
              'insert /*+ append parallel(8) */
                      into '||l_tab||'( fdat, kf, acc, rnk, OST		,OSTQ	,DOS		,DOSQ	, KOS		,KOSQ	,CRDOS	,
                     CRDOSQ	, CRKOS	,CRKOSQ	,CUDOS	,CUDOSQ	,CUKOS	, CUKOSQ)
              select /*+ parallel(8) */
                     fdat,
                     '''||g_kf||''' as kf,
                     rukey(acc) as acc,
                     rukey(rnk) as rnk,
                     OST		,
                     OSTQ	,
                     DOS		,
                     DOSQ	,
                     KOS		,
                     KOSQ	,
                     CRDOS	,
                     CRDOSQ	,
                     CRKOS	,
                     CRKOSQ	,
                     CUDOS	,
                     CUDOSQ	,
                     CUKOS	,
                     CUKOSQ	                     
                from '||pkf(l_tab, p_schema,  p_dblink)||' 
               where fdat between to_date(''01.01.2016'', ''dd.mm.yyyy'') and  to_date(''01.01.2049'', ''dd.mm.yyyy'')
                 and fdat >= '''||l_min_fdat||''' log errors reject limit unlimited';
    else
    execute immediate
              'insert /*+ append noparallel */
                      into '||l_tab||'( fdat, kf, acc, rnk, OST		,OSTQ	,DOS		,DOSQ	, KOS		,KOSQ	,CRDOS	,
                     CRDOSQ	, CRKOS	,CRKOSQ	,CUDOS	,CUDOSQ	,CUKOS	, CUKOSQ)
              select /*+ noparallel */
                     fdat,
                     '''||g_kf||''' as kf,
                     rukey(acc) as acc,
                     rukey(rnk) as rnk,
                     OST		,
                     OSTQ	,
                     DOS		,
                     DOSQ	,
                     KOS		,
                     KOSQ	,
                     CRDOS	,
                     CRDOSQ	,
                     CRKOS	,
                     CRKOSQ	,
                     CUDOS	,
                     CUDOSQ	,
                     CUKOS	,
                     CUKOSQ	
                from '||pkf(l_tab, p_schema,  p_dblink)||' 
               where fdat between to_date(''01.01.2016'', ''dd.mm.yyyy'') and  to_date(''01.01.2049'', ''dd.mm.yyyy'')
                 and fdat >= '''||l_min_fdat||''' log errors reject limit unlimited';
    end if;
     
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);
    trace('%s rows inserted', l_rowcount);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    end;
    --
    commit;
    --
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_agg_monbals_prl;

  ----
  -- clean_oper - очистка oper
  --
  --
  procedure clean_oper
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    cursor cur is
          select partition_name
          from user_tab_partitions
          where table_name='OPER'
          order by partition_name desc;

    type t_cur_ut is table of user_tab_partitions.partition_name%type index by pls_integer;
    l_cur_ut t_cur_ut;

    v_counter integer := 0;

  begin
    --
    trace('%s: entry point', p);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

    case when g_kf = g_glb_mfo then
         begin
           for rec in cur loop
                v_counter := v_counter + 1;

                l_cur_ut(v_counter) := rec.partition_name;
                mgr_utl.p_partition_truncate(l_tab, l_cur_ut(v_counter));
            end loop;
         end;
    else
        begin
          for rec_del in cur loop
               mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
               --
               trace('%s: deleting '||l_tab, p);
               commit;
          end loop;
        end;
        --
    end case;
  --
  -- mgr_utl.p_ref_constraints_enable(l_tab);

  exception when others then
      rollback;
        mgr_utl.save_error();
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_oper;

  ----
  -- fill_oper_forall - локальная процедура, импорт oper с использованием FORALL
  --
  procedure fill_oper_forall(p_date date default null, p_date_end date default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_date                  DATE;
    l_date_end              DATE;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

  /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
  */

    TYPE t_oper_row IS TABLE OF oper%ROWTYPE;
    vv_cur_oper t_oper_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_oper IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPER%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_oper (v_indx).ref;
         v_cur_exceptions (i).kf                     := vv_cur_oper (v_indx).kf;
         v_cur_exceptions (i).pdat                   := vv_cur_oper (v_indx).pdat;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPER
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_oper;

    --
    BEGIN
    v_count                 := 0;
    c_n                    := 0;
    l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
    l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
    l_migration_start_time := sysdate;
    l_start_time           := current_timestamp;

    --ikf(g_kf);
    --
    --bc.go(g_kf);

    --mgr_utl.before_fill(l_tab);

    --mgr_utl.mantain_error_table(l_tab);
             --
            BEGIN
            OPEN l_cur FOR
              'select
                       rukey(ref) as ref
                      ,deal_tag
                      ,tt
                      ,vob
                      ,nd
                      ,pdat
                      ,vdat
                      ,kv
                      ,dk
                      ,s
                      ,sq
                      ,sk
                      ,datd
                      ,datp
                      ,nam_a
                      ,nlsa
                      ,mfoa
                      ,nam_b
                      ,nlsb
                      ,mfob
                      ,nazn
                      ,d_rec
                      ,id_a
                      ,id_b
                      ,id_o
                      ,sign
                      ,sos
                      ,vp
                      ,chk
                      ,s2
                      ,kv2
                      ,kvq
                      ,rukey(refl) as refl
                      ,prty
                      ,sq2
                      ,currvisagrp
                      ,nextvisagrp
                      ,ref_a
                      ,tobo
                      ,otm
                      ,signed
                      ,branch
                      ,ruuser(userid) as userid
                      ,ruuser(respid) as respid
                      ,'''||g_kf||''' as kf
                      ,bis
                      ,sos_tracker
                      ,next_visa_branches
                      ,sos_change_time
                      ,odat
                      ,bdat
              from '||pkf('oper')||' where pdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_oper LIMIT c_limit;
               EXIT WHEN vv_cur_oper.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_oper SAVE EXCEPTIONS
              INSERT INTO bars.oper
                                        VALUES vv_cur_oper(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_oper ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
           -- Clear collection for vv_cur_oper
           vv_cur_oper.delete;
        END;

  end fill_oper_forall;

  ----
  -- fill_oper_part - локальная процедура, импорт oper посекционно в паралельном режиме, Direct-Path INSERT метод
  --
  procedure fill_oper_part
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_min_pdat              DATE;
    l_max_pdat              DATE;
    l_exists                BOOLEAN;
    l_num                   NUMBER;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

    begin

    -- ikf(g_kf);

    -- bc.go(g_kf);
     --
    -- mgr_utl.before_fill('OPER');

       for c in (select 'NONE' as partition_name, partitioned, 0 as partition_position, null as partition_stmt
                    from all_tables
                   where owner='KF'||g_kf
                     and table_name='OPER'
                     and partitioned='NO'
                   union all
                  select partition_name, 'YES' as partitioned, partition_position, 'partition('||partition_name||')' as partition_stmt
                    from all_tab_partitions
                   where table_owner='KF'||g_kf
                     and table_name='OPER'
                     and partition_name >= 'OPER_Y2015_Q1'
                   order by partition_position asc
                 )
        loop
            -- проверяем наличие в oper данных партиции KF<>.oper
            execute immediate 'select min(pdat), max(pdat) from '||pkf('oper')||' '||c.partition_stmt into l_min_pdat, l_max_pdat;
            --
            l_exists := false;
            begin
                select 1
                  into l_num
                  from OPER
                 where pdat between l_min_pdat and l_max_pdat
                   and kf=g_kf
                   and rownum=1;
                --
                l_exists := true;
            exception
                when no_data_found then
                    null;
            end;
            --
            if l_exists
            then
                trace('Данные '||pkf('oper')||' '||c.partition_stmt||' уже импортированы в oper, пропускаем');
                continue;
            end if;
            -- наполняем данные партиции
            execute immediate
            '
            insert  /*+ APPEND parallel (8)*/
              into OPER (ref, deal_tag, tt, vob, nd, pdat, vdat, kv, dk, s, sq, sk, datd, datp, nam_a, nlsa, mfoa, nam_b, nlsb, mfob, nazn,
                              d_rec, id_a, id_b, id_o, sign, sos, vp, chk, s2, kv2, kvq, refl, prty, sq2, currvisagrp, nextvisagrp, ref_a, tobo,
                              otm, signed, branch, userid, respid, kf, bis, sos_tracker, next_visa_branches, sos_change_time, odat, bdat)
            select  /*+ parallel (8)*/
                            rukey(ref) as ref, deal_tag, tt, vob, nd, pdat, vdat, kv, dk, s, sq, sk, datd, datp, nam_a, nlsa, mfoa, nam_b, nlsb, mfob, nazn,
                            d_rec, id_a, id_b, id_o, sign, sos, vp, chk, s2, kv2, kvq, rukey(refl)as refl, prty, sq2, currvisagrp, nextvisagrp, ref_a, tobo,
                            otm, signed, branch, ruuser(userid)as userid, ruuser(respid)as respid, '''||g_kf||''', bis, sos_tracker, next_visa_branches, sos_change_time, odat, bdat
              from '||pkf('oper')||' '||c.partition_stmt;
            --
            commit;
            --
            trace('импортирована партиция %s', c.partition_name);
            --
        end loop;

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception
      when others then
           rollback;
           --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

  end fill_oper_part;

  ----
  -- fill_oper_part_date - локальная процедура, импорт oper согласно указанным датам с вычеткой данных в паралельном режиме , Partition Pruning - Direct-Path INSERT метод
  --
  procedure fill_oper_part_date(p_date date default null, p_date_end date default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_date                  DATE;
    l_date_end              DATE;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   begin

  -- ikf(g_kf);
  -- bc.go(g_kf);
   --
  -- mgr_utl.before_fill('OPER');

    l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
    l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
    l_migration_start_time := sysdate;
    l_start_time           := current_timestamp;

           execute immediate ' insert  /*+ APPEND parallel (8)*/
                                              into OPER (ref, deal_tag, tt, vob, nd, pdat, vdat, kv, dk, s, sq, sk, datd, datp, nam_a, nlsa, mfoa, nam_b, nlsb, mfob, nazn,
                                                              d_rec, id_a, id_b, id_o, sign, sos, vp, chk, s2, kv2, kvq, refl, prty, sq2, currvisagrp, nextvisagrp, ref_a, tobo,
                                                              otm, signed, branch, userid, respid, kf, bis, sos_tracker, next_visa_branches, sos_change_time, odat, bdat)
                                               select   /*+ parallel (8)*/
                                                            rukey(ref) as ref, deal_tag, tt, vob, nd, pdat, vdat, kv, dk, s, sq, sk, datd, datp, nam_a, nlsa, mfoa, nam_b, nlsb, mfob, nazn,
                                                            d_rec, id_a, id_b, id_o, sign, sos, vp, chk, s2, kv2, kvq, rukey(refl)as refl, prty, sq2, currvisagrp, nextvisagrp, ref_a, tobo,
                                                            otm, signed, branch, ruuser(userid)as userid, ruuser(respid)as respid, '''||g_kf||''' as kf, bis, sos_tracker, next_visa_branches, sos_change_time, odat, bdat
                                              from '||pkf('oper')||' where pdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

    --
    commit;
    --
  end fill_oper_part_date;

  procedure fill_oper(p_partitionway varchar2 default null, p_date date default null, p_date_end date default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    --l_stmt                  VARCHAR2(4000);
    l_max_ref               NUMBER;

  begin
    --ikf(g_kf);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    mgr_utl.mantain_error_table(l_tab);

    -- переводим отдельные ограничения целостности в отложенный режим
    --l_stmt := 'set constraint fk_oper_oper deferred';
    --trace(l_stmt);
    --execute immediate l_stmt;
    /*
    execute immediate 'ALTER INDEX XIE_REFL_OPER UNUSABLE';
    execute immediate 'ALTER INDEX xie_vdat_oper UNUSABLE';
    */
    --
    begin
        --
        execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';

        case when p_partitionway = 'T'
                  and p_date is null
                  and p_date_end is null then fill_oper_part();
             when p_partitionway = 'T'
                  and p_date is not null then fill_oper_part_date(p_date, p_date_end);
             else fill_oper_forall(p_date, p_date_end);
        end case;
        --
    exception
        when others then
            rollback;
               mgr_utl.save_error();
    end;
  --
  bc.home();
  --
  --l_stmt := 'set constraint fk_oper_oper immediate';
  --trace(l_stmt);
  --execute immediate l_stmt;
  /*
   execute immediate 'ALTER INDEX  XIE_REFL_OPER REBUILD';
   execute immediate 'ALTER INDEX  xie_vdat_oper REBUILD';
  */
  --
  select trunc(nvl(max(ref / 100), 0)) + 1
    into l_max_ref
    from oper;
  --
  mgr_utl.reset_sequence('S_OPER', l_max_ref);
  --
  --trace('собираем статистику');
  --
  --mgr_utl.gather_table_stats('bars', 'oper', cascade=>true);
  --
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_oper;


  ----
  -- fill_oper_ext - импорт oper_ext
  --
  procedure fill_oper_ext
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER_EXT';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

  /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
  */

    TYPE t_oper_ext_row IS TABLE OF oper_ext%ROWTYPE;

    vv_cur_oe t_oper_ext_row;

    PROCEDURE error_logging_oe IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPER_EXT%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$       := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$         := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$          := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$        := 'I';
         v_cur_exceptions (i).ref                   := vv_cur_oe (v_indx).ref;
         v_cur_exceptions (i).pay_bankdate          := vv_cur_oe (v_indx).pay_bankdate;
         v_cur_exceptions (i).kf                    := vv_cur_oe (v_indx).kf;
         --v_cur_exceptions (i).effectdate            := v_cur (v_indx).effectdate;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPER_EXT
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging_oe;

  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    /*
    execute immediate 'ALTER INDEX idx_operext_bankdate UNUSABLE';
    execute immediate 'ALTER INDEX idx_operext_caldate UNUSABLE';
    */
    --
    BEGIN
        v_count      := 0;
        c_n          := 0;
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;

           mgr_utl.mantain_error_table(l_tab);

             OPEN l_cur FOR
                'select
                         rukey(ref) as ref
                         , '''||g_kf||''' as kf
                         ,pay_bankdate
                         ,pay_caldate
                  from '||pkf('oper_ext');
                    --
             LOOP
               FETCH l_cur BULK COLLECT INTO vv_cur_oe LIMIT c_limit;
                 EXIT WHEN vv_cur_oe.COUNT = 0;

             BEGIN
              FORALL indx IN INDICES OF vv_cur_oe SAVE EXCEPTIONS
                INSERT INTO bars.oper_ext
                                          VALUES vv_cur_oe(indx);

             EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_oe ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
           -- Clear collection for vv_cur_oper
           vv_cur_oe.delete;

     END;

    /*
    execute immediate 'ALTER INDEX idx_operext_bankdate REBUILD';
    execute immediate 'ALTER INDEX idx_operext_caldate REBUILD';
    */
    --
    --trace('собираем статистику');
    --
    --mgr_utl.gather_table_stats('bars', 'oper_ext', cascade=>true);
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_oper_ext;

  ---------------------------------------------
  procedure fill_op_field
    is
    l_tab         VARCHAR2(30) DEFAULT 'OP_FIELD';
    begin
        --      
        init();
        --
        case when g_kf = g_glb_mfo then
         execute_statement(
              'merge into '||l_tab||' a using (select tag, 
                                                      name, 
                                                      fmt, 
                                                      browser, 
                                                      nomodify, 
                                                      vspo_char, 
                                                      chkr, 
                                                      default_value, 
                                                      type, 
                                                      use_in_arch
                                                 from '||pkf(l_tab)||') s on (a.tag = s.tag) 
                         when matched then update set a.name = s.name, 
                                                      a.fmt = s.fmt, 
                                                      a.browser = s.browser, 
                                                      a.nomodify = s.nomodify, 
                                                      a.vspo_char = s.vspo_char, 
                                                      a.chkr = s.chkr, 
                                                      a.default_value = s.default_value, 
                                                      a.type = s.type, 
                                                      a.use_in_arch = s.use_in_arch
              when not matched then insert values    (s.tag, 
                                                      s.name, 
                                                      s.fmt, 
                                                      s.browser, 
                                                      s.nomodify, 
                                                      s.vspo_char, 
                                                      s.chkr, 
                                                      s.default_value, 
                                                      s.type, 
                                                      s.use_in_arch)',
                    'Доповнення новими значеннями '||l_tab);
        else 
         execute_statement(
              'merge into '||l_tab||' a using (select tag, 
                                                      name, 
                                                      fmt, 
                                                      browser, 
                                                      nomodify, 
                                                      vspo_char, 
                                                      chkr, 
                                                      default_value, 
                                                      type, 
                                                      use_in_arch
                                                 from '||pkf(l_tab)||') s on (a.tag = s.tag) 
              when not matched then insert values    (s.tag, 
                                                      s.name, 
                                                      s.fmt, 
                                                      s.browser, 
                                                      s.nomodify, 
                                                      s.vspo_char, 
                                                      s.chkr, 
                                                      s.default_value, 
                                                      s.type, 
                                                      s.use_in_arch)',
                    'Доповнення новими значеннями '||l_tab);
        end case;
         --
        bc.home;
       --mgr_utl.p_constraints_enable(l_tab);
        --
       --
         exception when others then
         rollback;
     --
    end fill_op_field;

  ----
  -- clean_operw - очистка operw
  --
  --
  procedure clean_operw
  is
    l_tab          VARCHAR2(30) DEFAULT 'OPERW';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

       case when g_kf = g_glb_mfo then

                mgr_utl.p_table_truncate(l_tab);
                trace('%s: truncate '||l_tab, p);
       else
                begin
                  mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );

                  trace('%s: deleting '||l_tab, p);

                commit;
               --
                end;
                --
        end case;
    --
  exception
    when others then
         rollback;
           mgr_utl.save_error();

    -- mgr_utl.p_ref_constraints_enable(l_tab);

    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_operw;

  ----
  -- fill_operw - импорт operw
  --
  procedure fill_operw
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPERW';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 200000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_min_ref               operw.ref%type;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_operw_row IS TABLE OF operw%ROWTYPE;
    vv_cur_operw t_operw_row;
   /*
   TYPE t_operw_row IS RECORD(
        ref   NUMBER(38)
       ,tag   CHAR(5)
       ,value VARCHAR2(220)
       ,kf    VARCHAR2(6));

    TYPE t_cur_operw IS TABLE OF t_operw_row INDEX BY PLS_INTEGER;

    vv_cur_operw t_cur_operw;
    */
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_operw IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPERW%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_operw (v_indx).ref;
         v_cur_exceptions (i).tag                    := vv_cur_operw (v_indx).tag;
         v_cur_exceptions (i).value                  := vv_cur_operw (v_indx).value;
         v_cur_exceptions (i).kf                     := vv_cur_operw (v_indx).kf;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPERW
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_operw;

  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    --mgr_utl.before_fill(l_tab);
    --
    trace('inserting into '||l_tab);
        --
    BEGIN
        v_count          := 0;
        c_n              := 0;
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;

        mgr_utl.mantain_error_table(l_tab);
        --
        --execute immediate 'ALTER SESSION SET SORT_AREA_SIZE 1048576';
        --
        execute immediate 'select trunc(nvl(op.ref/100, 1))
                           from (select max(ref) as ref
                                 from bars.oper partition(OPER_Y2015_Q4)
                                 where ref > 0
                                 and kf=:g_kf
                                 )op'
                           into l_min_ref using g_kf;

         OPEN l_cur FOR
                'select
                 rukey(ref) as ref
                 ,tag
                 ,case when tag = ''NOS_A'' and regexp_like(value,''^[0-9]+$'') and value <>''0''
                         then rukey(value)
                         else value
                  end as value
                 ,'''||g_kf||''' as kf
              from '||pkf('operw')||' where ref > '||l_min_ref;
                    --
             LOOP
               FETCH l_cur BULK COLLECT INTO vv_cur_operw LIMIT c_limit;
                 EXIT WHEN vv_cur_operw.COUNT = 0;

             BEGIN
              FORALL indx IN INDICES OF vv_cur_operw SAVE EXCEPTIONS
                INSERT
                       INTO bars.operw
                                          VALUES vv_cur_operw(indx);

              EXCEPTION
                     WHEN bulk_exceptions THEN
                        c_n := c_n + SQL%ROWCOUNT;
                        error_logging_operw ();
             END;
              COMMIT;
                v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

             END LOOP;
             l_rowcount := l_cur%rowcount;
             CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
             -- Clear collection for vv_cur_operw
            vv_cur_operw.delete;
       --
       --execute immediate 'ALTER SESSION SET SORT_AREA_SIZE 65536';
       --
       END;
  --
  --trace('собираем статистику');
  --
  --mgr_utl.gather_table_stats('bars', 'operw', cascade=>true);
  --
  bc.home();
  --
  --mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_operw;

  procedure fill_operw_dblink
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPERW';
    l_min_ref               operw.ref%TYPE;
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab||'_dblink';

  begin
    --trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    --mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    begin
    l_min_ref:= 284013905;
    --
    --execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
    --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
    --
       execute_statement(
                 'insert /*+ append parallel(8) */  into bars.OPERW
                 select /*+ parallel(8) */
                     rukey(ref) as ref
                    ,tag
                    ,case when tag = ''NOS_A'' and regexp_like(value,''^[0-9]+$'') and value <>''0''
                            then rukey(value)
                            else value
                     end as value
                    ,'''||g_kf||''' as kf
                 from bars.operw@mgrs.grc.ua where ref > '||l_min_ref||' log errors reject limit unlimited',
                 'insert into '||l_tab);
    --
    commit;
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    --
    end;
  --
  bc.home();
  --
  --mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  exception when others then
    rollback;
    mgr_utl.save_error();
  end fill_operw_dblink;

  procedure fill_operw_prl
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPERW';
    l_min_ref               operw.ref%TYPE;
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab||'_prl';

  begin
    --trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    --mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

       begin
       --execute immediate 'ALTER SESSION FORCE parallel DML parallel 12';
       --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 12';
       execute immediate 'select trunc(nvl(op.ref/100, 1))
                              from (select max(ref) as ref
                                    from bars.oper partition(OPER_Y2016_Q4)
                                    where ref > 0
                                    and kf=:g_kf
                                    )op'
                              into l_min_ref using g_kf;
       execute_statement(
                 'insert /*+ append parallel(12) */  into bars.OPERW
                 select /*+ parallel(12) */
                     rukey(ref) as ref
                    ,tag
                    ,case when tag = ''NOS_A'' and regexp_like(value,''^[0-9]+$'') and value <>''0''
                            then rukey(value)
                            else value
                     end as value
                    ,'''||g_kf||''' as kf
                 from '||pkf('operw')||' where ref > '||l_min_ref||' log errors reject limit unlimited', 'insert into '||l_tab);
       --
       commit;
       --
       --execute immediate 'ALTER SESSION DISABLE parallel DML';
       --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
       --
       end;
  --
  bc.home();
  --
  --mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  exception when others then
    rollback;
    mgr_utl.save_error();
  end fill_operw_prl;

  ----
  -- clean_oper_visa - очистка oper_visa
  --
  --
  procedure clean_oper_visa
  is
    l_tab          VARCHAR2(30) DEFAULT 'OPER_VISA';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    begin
    --
     trace('%s: entry point', p);
    --
     bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

    case when g_kf = g_glb_mfo then

            mgr_utl.p_table_truncate(l_tab);
            trace('%s: truncate '||l_tab, p);
    else
              begin
                mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||' where kf = '||g_kf );

                trace('%s: deleting '||l_tab, p);
              commit;
              --
              end;
              --
    end case;
    --
    exception
        when others then
             rollback;
               mgr_utl.save_error();

   -- mgr_utl.p_ref_constraints_enable(l_tab);

  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_oper_visa;


  ----
  -- fill_oper_visa - импорт oper_visa
  --
  procedure fill_oper_visa
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER_VISA';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 200000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_max_sqnc              oper_visa.sqnc%TYPE;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

   TYPE t_cur_oper_visa IS TABLE OF oper_visa%ROWTYPE;

   vv_cur_oper_visa t_cur_oper_visa;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_oper_visa IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPER_VISA%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_oper_visa (v_indx).ref;
         v_cur_exceptions (i).dat                    := vv_cur_oper_visa (v_indx).dat;
         v_cur_exceptions (i).userid                 := vv_cur_oper_visa (v_indx).userid;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPER_VISA
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_oper_visa;

  begin
    --
    trace('%s: entry point', p);
    --
    --bc.home();
    --
    --select nvl(max(sqnc),0)  into l_max_sqnc  from bars.oper_visa;
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    --execute immediate 'ALTER INDEX i1_opervisa UNUSABLE';

      BEGIN
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;

        mgr_utl.mantain_error_table(l_tab);

            OPEN l_cur FOR
              'select
                   rukey(ref) as ref
                   ,dat
                   ,ruuser(userid) as userid
                   ,groupid
                   ,status
                   ,rukey(sqnc) as sqnc
                   ,passive
                   ,keyid
                   ,sign
                   ,substr(username,1,60) as username
                   ,usertabn
                   ,groupname
                   ,f_in_charge
                   ,check_ts
                   ,check_code
                   ,check_msg
                   ,'''||g_kf||''' as kf
                   ,passive_reasonid
              from '||pkf('oper_visa');
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_oper_visa LIMIT c_limit;
               EXIT WHEN vv_cur_oper_visa.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_oper_visa SAVE EXCEPTIONS
              INSERT INTO bars.oper_visa
                                        VALUES vv_cur_oper_visa(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_oper_visa ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
           -- Clear collection for vv_cur_oper_visa
          vv_cur_oper_visa.delete;
     END;
  --
  bc.home();
  --
  select trunc(nvl(max(sqnc / 100), 0)) + 1 into l_max_sqnc  from bars.oper_visa;

  mgr_utl.reset_sequence('S_VISA', l_max_sqnc);
  --
  --trace('собираем статистику');
  --
  --mgr_utl.gather_table_stats('bars', 'oper_visa', cascade=>true);
  --
  --execute immediate 'ALTER INDEX i1_opervisa REBUILD';
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_oper_visa;

  ----
  -- fill_oper_visa - импорт oper_visa parallel wey
  --
  procedure fill_oper_visa_prl(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER_VISA';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_min_sqnc              NUMBER;
    l_max_sqnc              NUMBER;

  begin
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

    --
    select trunc(nvl(max(sqnc / 100), 0)) + 1 
      into l_min_sqnc 
      from bars.oper_visa
     where kf = G_KF ;
    --
    if l_min_sqnc = 1
    then
    execute immediate '
    select max(sqnc) - 10000000
      from '||pkf(l_tab, p_schema, p_dblink)||' t
     --where t.dat < trunc( add_months(sysdate, - 3), ''mm'')
     '
      into l_max_sqnc; 
    else 
    execute immediate '
    select max(sqnc)
      from '||pkf(l_tab, p_schema, p_dblink) 
      into l_max_sqnc; 
    end if;   
     
    commit;
    
    begin
              --execute immediate 'ALTER SESSION FORCE parallel DML parallel 12';
              --execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 12';

              execute_statement(
              'insert /*+ append parallel(12) */  into bars.oper_visa
               select /*+ parallel(12) */
                     rukey(ref) as ref
                     ,dat
                     ,ruuser(userid) as userid
                     ,groupid
                     ,status
                     ,rukey(sqnc) as sqnc
                     ,passive
                     ,keyid
                     ,sign
                     ,substr(username,1,60) as username
                     ,usertabn
                     ,groupname
                     ,f_in_charge
                     ,check_ts
                     ,check_code
                     ,check_msg
                     ,'''||g_kf||''' as kf
                     ,passive_reasonid
                from '||pkf(l_tab, p_schema, p_dblink)||' 
               where sqnc >= '||l_min_sqnc||'
                 and sqnc <= '||l_max_sqnc
                  
              , 'insert into '||l_tab);

    commit;
    --
    --execute immediate 'ALTER SESSION DISABLE parallel DML';
    --execute immediate 'ALTER SESSION DISABLE parallel QUERY';
    end;

  --
  bc.home();
  --
  select trunc(nvl(max(sqnc / 100), 0)) + 1 into l_max_sqnc  from bars.oper_visa;

  mgr_utl.reset_sequence('S_VISA', l_max_sqnc);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_oper_visa_prl;

  procedure fill_oper_visa_frl
   is
    l_tab                    VARCHAR2(30) DEFAULT 'OPER_VISA';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 200000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_max_sqnc               oper_visa.sqnc%TYPE;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

   TYPE t_cur_oper_visa IS TABLE OF oper_visa%ROWTYPE;

   vv_cur_oper_visa t_cur_oper_visa;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_oper_visa IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPER_VISA%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions      t_cur_exception;

      v_indx                PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$           := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$             := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$              := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$            := 'I';
         v_cur_exceptions (i).ref                       := vv_cur_oper_visa (v_indx).ref;
         v_cur_exceptions (i).dat                       := vv_cur_oper_visa (v_indx).dat;
         v_cur_exceptions (i).userid                    := vv_cur_oper_visa (v_indx).userid;
         v_cur_exceptions (i).groupid                   := vv_cur_oper_visa (v_indx).status;
         v_cur_exceptions (i).status                    := vv_cur_oper_visa (v_indx).userid;
         v_cur_exceptions (i).sqnc                      := vv_cur_oper_visa (v_indx).sqnc;
         v_cur_exceptions (i).passive                   := vv_cur_oper_visa (v_indx).passive;
         v_cur_exceptions (i).keyid                     := vv_cur_oper_visa (v_indx).keyid;
         v_cur_exceptions (i).sign                      := vv_cur_oper_visa (v_indx).sign;
         v_cur_exceptions (i).username                  := vv_cur_oper_visa (v_indx).username;
         v_cur_exceptions (i).usertabn                  := vv_cur_oper_visa (v_indx).usertabn;
         v_cur_exceptions (i).groupname                 := vv_cur_oper_visa (v_indx).groupname;
         v_cur_exceptions (i).f_in_charge               := vv_cur_oper_visa (v_indx).f_in_charge;
         v_cur_exceptions (i).check_ts                  := vv_cur_oper_visa (v_indx).check_ts;
         v_cur_exceptions (i).check_code                := vv_cur_oper_visa (v_indx).check_code;
         v_cur_exceptions (i).check_msg                 := vv_cur_oper_visa (v_indx).check_msg;
         v_cur_exceptions (i).kf                        := vv_cur_oper_visa (v_indx).kf;
         v_cur_exceptions (i).passive_reasonid          := vv_cur_oper_visa (v_indx).passive_reasonid;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPER_VISA
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_oper_visa;


  begin
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;
    --
    trace('%s: entry point', p);
    --
    --bc.home();
    --
    --select nvl(max(sqnc),0)  into l_max_sqnc  from bars.oper_visa;
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
     --execute immediate 'ALTER INDEX i1_opervisa UNUSABLE';

      BEGIN

      OPEN l_cur FOR
              'select
                   rukey(ref) as ref
                   ,dat
                   ,ruuser(userid) as userid
                   ,groupid
                   ,status
                   ,rukey(sqnc) as sqnc
                   ,passive
                   ,keyid
                   ,sign
                   ,substr(username,1,60) as username
                   ,usertabn
                   ,groupname
                   ,f_in_charge
                   ,check_ts
                   ,check_code
                   ,check_msg
                   ,'''||g_kf||''' as kf
                   ,passive_reasonid
              from '||pkf('oper_visa');
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_oper_visa LIMIT c_limit;
               EXIT WHEN vv_cur_oper_visa.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_oper_visa SAVE EXCEPTIONS
              INSERT INTO bars.oper_visa
                                        VALUES vv_cur_oper_visa(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_oper_visa ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
          -- Clear collection for vv_cur_oper_visa
          vv_cur_oper_visa.delete;
        END;
  --
  bc.home();
  --
  select trunc(nvl(max(sqnc / 100), 0)) + 1 into l_max_sqnc  from bars.oper_visa;

  mgr_utl.reset_sequence('S_VISA', l_max_sqnc);
  --
  --trace('собираем статистику');
  --
  --mgr_utl.gather_table_stats('bars', 'oper_visa', cascade=>true);
  --
  --
  --execute immediate 'ALTER INDEX    i1_opervisa REBUILD';

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_oper_visa_frl;


  ----
  -- clean_opldok - очистка opldok
  --
  --
  procedure clean_opldok
  is
    l_tab          VARCHAR2(30) DEFAULT 'OPLDOK';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    cursor cur is
        select partition_name
        from user_tab_partitions
        where table_name='OPLDOK'
        order by partition_name desc;

    type t_cur_ut is table of user_tab_partitions.partition_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;

  begin
    --
    trace('%s: entry point', p);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

   case when g_kf = g_glb_mfo then
        begin
           for rec in cur loop
                v_counter := v_counter + 1;

                l_cur_ut(v_counter) := rec.partition_name;
                mgr_utl.p_partition_truncate(l_tab, l_cur_ut(v_counter));
            end loop;

         end;

    else
        begin
          for rec_del in cur loop
              mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
              --
              trace('%s: deleting '||l_tab, p);
              commit;
          end loop;
        end;

    end case;
  --
  -- mgr_utl.p_ref_constraints_enable(l_tab);

  exception when others then
      rollback;
        mgr_utl.save_error();
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_opldok;

  ----
  -- clean_oper_ext - очистка oper_ext
  --
  --
  procedure clean_oper_ext
  is
    l_tab          VARCHAR2(30) DEFAULT 'OPER_EXT';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    cursor cur is
        select partition_name
        from user_tab_partitions
        where table_name='OPER_EXT'
        order by partition_name desc;

    type t_cur_ut is table of user_tab_partitions.partition_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;

  begin
    --
    trace('%s: entry point', p);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

    case when g_kf = g_glb_mfo then
              begin
                 for rec in cur loop
                      v_counter := v_counter + 1;

                      l_cur_ut(v_counter) := rec.partition_name;
                      mgr_utl.p_partition_truncate(l_tab, l_cur_ut(v_counter));
                  end loop;

              end;

    else
              begin
                for rec_del in cur loop

                     mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
                     --
                     trace('%s: deleting '||l_tab, p);
                     commit;
                end loop;
              end;
    end case;
    --
   -- mgr_utl.p_ref_constraints_enable(l_tab);

  exception when others then
      rollback;
        mgr_utl.save_error();
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_oper_ext;


  ----
  -- fill_opldok_forall - локальная процедура, импорт opldok с использованием FORALL
  --
  procedure fill_opldok_forall(p_date date default null, p_date_end date default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPLDOK';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 200000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_date                  DATE;
    l_date_end              DATE;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_opldok_row IS TABLE OF opldok%ROWTYPE;

    vv_cur_opldok t_opldok_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_opldok IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPLDOK%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_opldok (v_indx).ref;
         v_cur_exceptions (i).kf                     := vv_cur_opldok (v_indx).kf;
         v_cur_exceptions (i).acc                    := vv_cur_opldok (v_indx).acc;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPLDOK
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_opldok;

    BEGIN
      v_count                 := 0;
      c_n                    := 0;
      l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
      l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
      l_migration_start_time := sysdate;
      l_start_time           := current_timestamp;

    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

          BEGIN
          OPEN l_cur FOR
                  'select
                       rukey(ref) as ref
                       ,tt
                       ,dk
                       ,rukey(acc) as acc
                       ,fdat
                       ,s
                       ,sq
                       ,txt
                       ,rukey(stmt) as stmt
                       ,sos
                       ,'''||g_kf||''' as kf
                       ,otm
                       ,to_number(rukey(id)) as id
                  from '||pkf('opldok')||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
    --
         LOOP
           FETCH l_cur BULK COLLECT INTO vv_cur_opldok LIMIT c_limit;
             EXIT WHEN vv_cur_opldok.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF vv_cur_opldok SAVE EXCEPTIONS
            INSERT INTO bars.opldok
                                      VALUES vv_cur_opldok(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_opldok ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for vv_cur_opldok
        vv_cur_opldok.delete;
        END;
    --
    bc.home();

      --  trace('собираем статистику');

      --  mgr_utl.gather_table_stats (ownname => 'BARS', tabname => 'OPLDOK',  cascade=>true);

    mgr_utl.finalize();
    --
    trace('%s: finished', p);

  end fill_opldok_forall;

  ----
  -- fill_opldok_part - локальная процедура, импорт opldok посекционно в паралельном режиме, Direct-Path INSERT метод
  --
  procedure fill_opldok_part
  is
    l_tab                          VARCHAR2(30) DEFAULT 'OPLDOK';
    p                              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time         date default sysdate;
    l_start_time                   timestamp default current_timestamp;
    l_end_time                     timestamp default current_timestamp;
    l_rowcount                     number default 0;
    l_time_duration                interval day(3) to second(3);
    l_min_fdat                     DATE;
    l_max_fdat                     DATE;
    l_exists                       BOOLEAN;
    l_num                          NUMBER;

   begin

   for c in (select 'NONE' as partition_name, partitioned, 0 as partition_position, null as partition_stmt
                    from all_tables
                   where owner='KF'||g_kf
                     and table_name='OPLDOK'
                     and partitioned='NO'
                   union all
                  select partition_name, 'YES' as partitioned, partition_position, 'partition('||partition_name||')' as partition_stmt
                    from all_tab_partitions
                   where table_owner='KF'||g_kf
                     and table_name='OPLDOK'
                     and partition_name >= 'OPLDOK_Y2015_Q1'
                   order by partition_position asc
                 )
        loop
            -- проверяем наличие в OPLDOK данных партиции KF<>.OPLDOK
            execute immediate 'select min(fdat), max(fdat) from '||pkf('opldok')||' '||c.partition_stmt into l_min_fdat, l_max_fdat;
            --
            l_exists := false;
            begin
                select 1
                  into l_num
                  from OPLDOK
                 where fdat between l_min_fdat and l_max_fdat
                   and kf=g_kf
                   and rownum=1;
                --
                l_exists := true;
            exception
                when no_data_found then
                    null;
            end;
            --
            if l_exists
            then
                trace('Данные '||pkf('opldok')||' '||c.partition_stmt||' уже импортированы в OPLDOK, пропускаем');
                continue;
            end if;

            l_migration_start_time := sysdate;
            l_start_time := current_timestamp;
            -- наполняем данные партиции
            execute immediate
            '
            insert  /*+ APPEND parallel (8)*/
              into OPLDOK (ref, tt, dk, acc, fdat, s, sq, txt, stmt, sos, kf, otm, id)
            select  /*+ parallel (8)*/
                   to_number(rukey(o.ref)) as ref, o.tt, o.dk, to_number(rukey(o.acc)) as acc, o.fdat, o.s, o.sq, o.txt,
                   to_number(rukey(o.stmt)) as stmt,
                   coalesce(o.sos,1) as sos, kf, otm, null as id
              from '||pkf('opldok')||' '||c.partition_stmt||' o';
            --
            commit;
            --
            trace('импортирована партиция %s', c.partition_name);
            --
        end loop;

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

  end fill_opldok_part;

  ----
  -- fill_opldok_part_date - локальная процедура, импорт opldok согласно указанным датам с вычеткой данных в паралельном режиме , Partition Pruning - Direct-Path INSERT метод
  --
  procedure fill_opldok_part_date(p_date date default null, p_date_end date default null)
  is

    l_tab                   VARCHAR2(30) DEFAULT 'OPLDOK';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_date                  DATE;
    l_date_end              DATE;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   begin

    l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
    l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
    l_migration_start_time := sysdate;
    l_start_time           := current_timestamp;

           execute immediate ' insert  /*+ APPEND parallel (8)*/
                                            into OPLDOK (ref, tt, dk, acc, fdat, s, sq, txt, stmt, sos, kf, otm)
                                          select /*+ parallel (8)*/
                                                 to_number(rukey(ref)) as ref, tt, dk, to_number(rukey(acc)) as acc, fdat, s, sq, txt,
                                                 to_number(rukey(stmt)) as stmt, coalesce(sos,1) as sos, kf, null as otm
                                          from '||pkf('opldok')||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    --
    commit;
    --
  end fill_opldok_part_date;

  ----
  -- fill_opldok - импорт opldok
  -- во избежание ошибок дату указываем в ANSI формате, пример p_partitionway => 'T', p_date => date '2015-10-01',  p_date_end =>  date '2015-12-31'
  --
  procedure fill_opldok(p_partitionway varchar2 default null, p_date date default null, p_date_end date default null)
  is
    l_tab          VARCHAR2(30) DEFAULT 'OPLDOK';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_stmt     opldok.stmt%type;
    l_max_id       bars.opldok.id%type;


  begin
    --
    trace('%s: entry point', p);

    --ikf(g_kf);

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';

    case when p_partitionway = 'T'
              and p_date  is null
              and p_date_end is null
         then fill_opldok_part();
         when p_partitionway = 'T'
              and p_date is not null
         then fill_opldok_part_date(p_date, p_date_end);
         else fill_opldok_forall(p_date, p_date_end);
    end case;
      --
    bc.home();
    -- подстраиваем последовательность S_STMT
    select trunc(nvl(max(stmt / 100), 0)) + 1
      into l_max_stmt
      from opldok;
    --
    mgr_utl.reset_sequence('S_STMT', l_max_stmt);
    --
    trace('подстраиваем сиквенс S_OPLDOK под максимальное значение');
    --
    select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_id
          from bars.opldok;
    mgr_utl.reset_sequence('S_OPLDOK', l_max_id);

    --trace('собираем статистику');
    --
    --mgr_utl.gather_table_stats('bars', 'opldok', cascade=>true);
    --
    exception
        when others then
            rollback;
              mgr_utl.save_error();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_opldok;

  ----
  -- correct_opldok - корректировка opldok
  --
  procedure correct_opldok
  is
      l_refs        DBMS_UTILITY.NUMBER_ARRAY;
      l_stmt        DBMS_UTILITY.NUMBER_ARRAY;
      l_nval        DBMS_UTILITY.NUMBER_ARRAY;
      l_tts         DBMS_UTILITY.NAME_ARRAY;
      l_ss          DBMS_UTILITY.NUMBER_ARRAY;
      c0            sys_refcursor;
      l_cnt         integer := 0;
      l_errcnt      integer := 0;
      bulk_errors   exception;

      pragma exception_init ( bulk_errors, -24381 );

      l_index       integer;
      p             constant varchar2(62) := G_PKG||'.correct_opldok';
      --l_sql    varchar2(2000);
  begin
      --
      trace('%s: entry point', p);
      --
      mgr_utl.disable_table_triggers(pkf('opldok'));
      --
      --trace('update '||pkf('opldok')||' set stmt = 0 where stmt is null, %s rows updated', to_char(sql%rowcount));
      --
      trace('получим кол-во записей в '||pkf('opldok'));
      --
      execute immediate
      '
      select count(*)
        from '||pkf('opldok')
      into l_cnt;
      --
      trace('l_cnt = %s'||to_char(l_cnt));

      trace('подстраиваем последовательность s_syn_opldok, minvalue=%s', to_char(l_cnt+1));
      --
      mgr_utl.reset_sequence('S_SYN_OPLDOK', l_cnt+1);
      --
      trace('модифицируем проводки типа FXP');
      --
      execute immediate
      '
      update '||pkf('opldok')||'
         set stmt = s_syn_opldok.nextval,
             sos = 0
       where stmt is null
         and sos is null
         and tt=''FXP''';
      --
      trace('модифицировано %s строк', to_char(sql%rowcount));
      --
      commit;
      --
      trace('stmt: null->0');
      --
      execute immediate
      '
      update '||pkf('opldok')||'
         set stmt = 0
       where stmt is null';
      --
      trace('модифицировано %s строк', to_char(sql%rowcount));
      --
      commit;
      --
      l_cnt := 0;
      --
      open c0 for
      'select o.ref, o.stmt, o.tt, o.s, S_SYN_OPLDOK.nextval as nval
         from '||pkf('opldok')||' o
        where (ref, stmt, dk) in
                (select ref, stmt, dk
                   from (
                            select ref, stmt, dk, count(*) cnt
                              from '||pkf('opldok')||'
                             where dk=0
                             group by ref, stmt, dk
                            having count(*)>1
                         )
                 )';
      while true
      loop
        fetch c0 bulk collect into l_refs, l_stmt, l_tts, l_ss, l_nval limit 100000;
        if l_refs.count=0
        then
            exit;
        end if;
        -- dk=0
        begin
            forall i in 1..l_refs.count
                save exceptions
                execute immediate
                'update '||pkf('opldok')||' set stmt=:l_nval where ref=:l_refs and stmt=:l_stmt and tt=:l_tts and s=:l_ss and dk=0 and rownum=1'
                using l_nval(i), l_refs(i), l_stmt(i), l_tts(i), l_ss(i);
        exception
            when bulk_errors then
                -- сохраняем ошибки
                for j in 1..sql%bulk_exceptions.count
                loop
                    l_index := sql%bulk_exceptions(j).error_index;
                    insert
                      into test_mgr_diff_stmt(ref)
                    values (l_refs(l_index));
                end loop;
        end;
        -- dk=1
        begin
            forall i in 1..l_refs.count
                save exceptions
                execute immediate
                'update '||pkf('opldok')||' set stmt=:l_nval where ref=:l_refs and stmt=:l_stmt and tt=:l_tts and s=:l_ss and dk=1 and rownum=1'
                using l_nval(i), l_refs(i), l_stmt(i), l_tts(i), l_ss(i);
        exception
            when bulk_errors then
                -- сохраняем ошибки
                for j in 1..sql%bulk_exceptions.count
                loop
                    l_index := sql%bulk_exceptions(j).error_index;
                    insert
                      into test_mgr_diff_stmt(ref)
                    values (l_refs(l_index));
                end loop;
        end;
        commit;
        l_cnt := l_cnt + l_refs.count;
        l_errcnt := l_errcnt + sql%bulk_exceptions.count;
        trace('%s: count: '||l_cnt||', errors: '||l_errcnt||', last ref='||l_refs(l_refs.count), p);
        dbms_application_info.set_client_info('count: '||l_cnt||', errors: '||l_errcnt||', last ref='||l_refs(l_refs.count));
      end loop;
      close c0;
      --
      trace('%s: finished', p);
      --
  end correct_opldok;

  ----
  -- clean_ref_que - очистка ref_que
  --
  --
  procedure clean_ref_que
  is
    l_tab          VARCHAR2(30) DEFAULT 'REF_QUE';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        trace('deleting from '||l_tab);
        --
        delete
          from ref_que
         where kf = g_kf;
        --
        trace('%s rows deleted', to_char(sql%rowcount));
        --
        commit;
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_ref_que;

  ----
  -- fill_ref_que - импорт ref_que
  --
  procedure fill_ref_que
  is
    l_tab                      VARCHAR2(30) DEFAULT 'REF_QUE';
    p                          CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time     date default sysdate;
    l_start_time               timestamp default current_timestamp;
    l_end_time                 timestamp default current_timestamp;
    l_rowcount                 number default 0;
    l_time_duration            interval day(3) to second(3);
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    begin
        trace('inserting into '||l_tab);
        --
        --
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
        --
        execute immediate
        '
        insert
          into ref_que(ref, fmcheck, kf, otm)
        select to_number(ref||'''||g_ru||'''), null, :g_kf, otm
          from '||pkf('ref_que')
        using g_kf;
        --
        l_rowcount := sql%rowcount;

        trace('вставлено %s строк', to_char(sql%rowcount));
        --
        l_end_time := current_timestamp;
        l_time_duration:= (l_end_time - l_start_time);
        --
        mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                    ,ip_migration_start_time          => l_migration_start_time
                                    ,ip_table_name                    => l_tab
                                    ,ip_operation                     => p
                                    ,ip_row_count                     => l_rowcount
                                    ,ip_task_start_time               => l_start_time
                                    ,ip_task_end_time                 => l_end_time
                                    ,ip_time_duration                 => l_time_duration
                                    ,ip_log_message                   => 'Done'
                                     );
        --
        commit;
        --
        bc.home();
        --
        trace('собираем статистику');
        --
        mgr_utl.gather_table_stats('bars', 'ref_que', cascade=>true);
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
            mgr_log.p_save_log_error( ip_migration_id                       => g_kf
                                      ,ip_migration_start_time              => l_migration_start_time
                                      ,ip_table_name                        => l_tab
                                      ,ip_operation                         => p
                                      ,ip_row_count                         => l_rowcount
                                      ,ip_task_start_time                   => l_start_time
                                      ,ip_task_end_time                     => l_end_time
                                      ,ip_time_duration                     => l_time_duration
                                      ,ip_log_message                       => 'Error'
                                      );
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_ref_que;

  ----
  -- clean_ref_lst - очистка ref_lst
  --
  --
  procedure clean_ref_lst
  is
    l_tab          VARCHAR2(30) DEFAULT 'REF_LST';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        trace('deleting from '||l_tab);
        --
        delete
          from ref_lst
         where kf = g_kf;
        --
        trace('%s rows deleted', to_char(sql%rowcount));
        --
        commit;
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_ref_lst;

  ----
  -- fill_ref_lst - импорт ref_lst
  --
  procedure fill_ref_lst
  is
    l_tab                      VARCHAR2(30) DEFAULT 'REF_LST';
    p                          CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time     date default sysdate;
    l_start_time               timestamp default current_timestamp;
    l_end_time                 timestamp default current_timestamp;
    l_rowcount                 number default 0;
    l_time_duration            interval day(3) to second(3);
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    begin
        trace('inserting into '||l_tab);
        --
        --
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
        --
        execute immediate
        '
        insert
          into ref_lst(
               datd, nd, mfoa,
               nlsa, mfob, nlsb,
               s, ref, rec, kf)
        select datd, nd, mfoa,
               nlsa, mfob, nlsb,
               s, to_number(ref||'''||g_ru||'''), to_number(rec||'''||g_ru||'''), :g_kf
          from '||pkf('ref_lst')
        using g_kf;
        --
        l_rowcount := sql%rowcount;

        trace('вставлено %s строк', to_char(sql%rowcount));
        --
        l_end_time := current_timestamp;
        l_time_duration:= (l_end_time - l_start_time);
        --
        mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                    ,ip_migration_start_time          => l_migration_start_time
                                    ,ip_table_name                    => l_tab
                                    ,ip_operation                     => p
                                    ,ip_row_count                     => l_rowcount
                                    ,ip_task_start_time               => l_start_time
                                    ,ip_task_end_time                 => l_end_time
                                    ,ip_time_duration                 => l_time_duration
                                    ,ip_log_message                   => 'Done'
                                     );
        --
        commit;
        --
        bc.home();
        --
        trace('собираем статистику');
        --
        mgr_utl.gather_table_stats('bars', 'ref_lst', cascade=>true);
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
            mgr_log.p_save_log_error( ip_migration_id                       => g_kf
                                      ,ip_migration_start_time              => l_migration_start_time
                                      ,ip_table_name                        => l_tab
                                      ,ip_operation                         => p
                                      ,ip_row_count                         => l_rowcount
                                      ,ip_task_start_time                   => l_start_time
                                      ,ip_task_end_time                     => l_end_time
                                      ,ip_time_duration                     => l_time_duration
                                      ,ip_log_message                       => 'Error'
                                      );
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_ref_lst;

  ----
  -- clean_zag_a - очистка zag_a
  --
  --
  procedure clean_zag_a
  is
    l_tab          VARCHAR2(30) DEFAULT 'ZAG_A';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    begin
    --
     trace('%s: entry point', p);
    --
     bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

   case when g_kf = g_glb_mfo then

            mgr_utl.p_table_truncate(l_tab);
    else
              begin
                mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
                --
                trace('%s: deleting '||l_tab, p);
              commit;
              --
              end;
              --
    end case;
    --
    exception when others then
              rollback;
                   mgr_utl.save_error();

    --mgr_utl.p_ref_constraints_enable(l_tab);

    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_zag_a;

  ----
  -- fill_zag_a - импорт zag_a
  --
  procedure fill_zag_a
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ZAG_A';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

  begin
  --
  trace('%s: entry point', p);
  --
  bc.go(g_kf);
  --
  mgr_utl.before_fill(l_tab);
  --
  begin
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;
      --
      trace('inserting into '||l_tab);
      --
      execute immediate
      '
      insert
        into zag_a (
             fn, dat, ref, kv, n, sde,
             skr, datk, dat_2, otm, sign, sign_key, kf)
      select z.fn, z.dat, rukey(z.ref) as ref, z.kv, z.n, z.sde,
             z.skr, z.datk, z.dat_2, z.otm, z.sign, z.sign_key, :g_kf
        from '||pkf('zag_a')||' z'
      using g_kf;

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);
    trace('%s rows inserted', l_rowcount);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

    end;
    --
    commit;
    --
    --trace('собираем статистику');
    --
    --mgr_utl.gather_table_stats('bars', 'zag_a', cascade=>true);
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_zag_a;

  ----
  -- clean_zag_b - очистка zag_b
  --
  --
  procedure clean_zag_b
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ZAG_B';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

   case when g_kf = g_glb_mfo then

            mgr_utl.p_table_truncate(l_tab);
            trace('%s: truncate '||l_tab, p);
   else
              begin
                mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
                --
                trace('%s: deleting '||l_tab, p);
              commit;
              --
              end;
              --
    end case;
    --
    exception when others then
              rollback;
                   mgr_utl.save_error();

   -- mgr_utl.p_ref_constraints_enable(l_tab);

    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_zag_b;

  ----
  -- fill_zag_b - импорт zag_b
  --
  procedure fill_zag_b
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ZAG_B';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    begin
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
        --
        trace('inserting into '||l_tab);
        --
        execute immediate
        '
        insert
          into zag_b (
               fn, dat, ref, kv, n, sde, skr, datk, dat_2, otm,
               sign, sign_key, ssp_sign_key, ssp_sign, kf, k_er)
        select z.fn, z.dat, rukey(z.ref) as ref, z.kv, z.n, z.sde, z.skr, z.datk, z.dat_2, z.otm,
               z.sign, z.sign_key, z.ssp_sign_key, z.ssp_sign, :g_kf, k_er
          from '||pkf('zag_b')||' z'
        using g_kf;
        --
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);
    trace('%s rows inserted', l_rowcount);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

    end;
    --
    commit;
    --
    bc.home();
    --
    -- trace('собираем статистику');
    --
    -- mgr_utl.gather_table_stats('bars', 'zag_b', cascade=>true);
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_zag_b;

  ----
  -- clean_arc_rrp - очистка arc_rrp
  --
  --
  procedure clean_arc_rrp
  is
    l_tab          VARCHAR2(30) DEFAULT 'ARC_RRP';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    cursor cur is
        select partition_name
        from user_tab_partitions
        where table_name='ARC_RRP'
        order by partition_name desc;

    type t_cur_ut is table of user_tab_partitions.partition_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;

  begin
    --
    trace('%s: entry point', p);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

    case when g_kf = g_glb_mfo then
        begin
           for rec in cur loop
                v_counter := v_counter + 1;

                l_cur_ut(v_counter) := rec.partition_name;
                mgr_utl.p_partition_truncate(l_tab, l_cur_ut(v_counter));
            end loop;
         end;

    else
        begin
          for rec_del in cur loop
               mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
               --
               trace('%s: deleting '||l_tab, p);
          commit;
          end loop;
        end;
        --
    end case;
    --
   -- mgr_utl.p_ref_constraints_enable(l_tab);

  exception when others then
            rollback;
                mgr_utl.save_error();
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_arc_rrp;

  ----
  -- clean_sos_track- очистка sos_track
  --
  --
  procedure clean_sos_track
  is
    l_tab          VARCHAR2(30) DEFAULT 'SOS_TRACK';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

    case when g_kf = g_glb_mfo then

            mgr_utl.p_table_truncate(l_tab);
            trace('%s: truncate '||l_tab, p);
    else
              begin
                mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
                --
                trace('%s: deleting '||l_tab, p);
              commit;
              --
              end;
              --
    end case;
    --
  exception when others then
    rollback;
      mgr_utl.save_error();

   -- mgr_utl.p_ref_constraints_enable(l_tab);

  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_sos_track;


  ----
  -- clean_agg_monbals - очистка agg_monbals
  --
  --
  procedure clean_agg_monbals
  is
    l_tab          VARCHAR2(30) DEFAULT 'AGG_MONBALS';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    cursor cur is
        select partition_name
        from user_tab_partitions
        where table_name='AGG_MONBALS'
        order by partition_name desc;

    type t_cur_ut is table of user_tab_partitions.partition_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;

  begin
    --
    trace('%s: entry point', p);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

   case when g_kf = g_glb_mfo then
         begin
           for rec in cur loop
                v_counter := v_counter + 1;

                l_cur_ut(v_counter) := rec.partition_name;
                mgr_utl.p_partition_truncate(l_tab, l_cur_ut(v_counter));
           end loop;
         end;

    else
        begin
          for rec_del in cur loop
               mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
               --
               trace('%s: deleting '||l_tab, p);
               commit;
           end loop;
         end;
        --
    end case;
    --
   -- mgr_utl.p_ref_constraints_enable(l_tab);


  exception when others then
      rollback;
        mgr_utl.save_error();
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_agg_monbals;

  ----
  -- clean_snap_balances - очистка snap_balances
  --
  --
  procedure clean_snap_balances
  is
    l_tab          VARCHAR2(30) DEFAULT 'SNAP_BALANCES';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

    cursor cur is
        select partition_name
        from user_tab_partitions
        where table_name='SNAP_BALANCES'
        order by partition_name desc;

    type t_cur_ut is table of user_tab_partitions.partition_name%type index by pls_integer;
    l_cur_ut t_cur_ut;
    v_counter integer := 0;

  begin
    --
    trace('%s: entry point', p);
    --
    mgr_utl.before_clean(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.p_ref_constraints_save(l_tab);
    mgr_utl.p_ref_constraints_disable(l_tab);

    case when g_kf = g_glb_mfo then
        begin
           for rec in cur loop
                v_counter := v_counter + 1;

                l_cur_ut(v_counter) := rec.partition_name;
                mgr_utl.p_partition_truncate(l_tab, l_cur_ut(v_counter));
            end loop;

        end;

    else
        begin
          for rec_del in cur loop
               mgr_utl.execute_immediate(ip_sql =>'delete from '||l_tab||'  where  kf = '||g_kf );
               --
               trace('%s: deleting '||l_tab, p);
               commit;
           end loop;
        end;
              --
    end case;
   --
   -- mgr_utl.p_ref_constraints_enable(l_tab);

  exception when others then
      rollback;
        mgr_utl.save_error();
  --

  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end clean_snap_balances;
   ----
  -- fill_arc_rrp_forall - локальная процедура, импорт arc_rrp с использованием FORALL
  --
  procedure fill_arc_rrp_forall(p_date date default null, p_date_end date default null)
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ARC_RRP';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_date                  DATE;
    l_date_end              DATE;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

  /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
  */

    TYPE t_arc_rrp_row IS TABLE OF arc_rrp%ROWTYPE;

    vv_cur_arc_rrp t_arc_rrp_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_arc_rrp IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_ARC_RRP%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_arc_rrp (v_indx).ref;
         v_cur_exceptions (i).kf                     := vv_cur_arc_rrp (v_indx).kf;
         v_cur_exceptions (i).dat_a                  := vv_cur_arc_rrp (v_indx).dat_a;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_ARC_RRP
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_arc_rrp;


    --
    BEGIN
       v_count          := 0;
       c_n              := 0;
       l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
       l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
       l_migration_start_time := sysdate;
       l_start_time := current_timestamp;

    --ikf(g_kf);
    --
    --bc.go(g_kf);
    --mgr_utl.before_fill(l_tab);
    --mgr_utl.mantain_error_table(l_tab);
             --
            BEGIN
            OPEN l_cur FOR
                            'select
                                    to_number(rukey(rec)) as rec,
                                    rukey(ref) as ref,
                                    mfoa,
                                    nlsa,
                                    mfob,
                                    nlsb,
                                    dk,
                                    s,
                                    vob,
                                    nd,
                                    kv,
                                    datd,
                                    trunc(datp) as datp,
                                    nam_a,
                                    nam_b,
                                    nazn,
                                    naznk,
                                    nazns,
                                    id_a,
                                    id_b,
                                    id_o,
                                    ref_a,
                                    bis,
                                    sign,
                                    fn_a,
                                    dat_a,
                                    rec_a,
                                    fn_b,
                                    dat_b,
                                    rec_b,
                                    d_rec,
                                    blk,
                                    sos,
                                    prty,
                                    fa_name,
                                    fa_ln,
                                    fa_t_arm3,
                                    fa_t_arm2,
                                    fc_name,
                                    fc_ln,
                                    fc_t1_arm2,
                                    fc_t2_arm2,
                                    fb_name,
                                    fb_ln,
                                    fb_t_arm2,
                                    fb_t_arm3,
                                    fb_d_arm3,
                                    '''||g_kf||'''
                             from '||pkf('arc_rrp')||' where dat_a between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_arc_rrp LIMIT c_limit;
               EXIT WHEN vv_cur_arc_rrp.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_arc_rrp SAVE EXCEPTIONS
              INSERT INTO bars.arc_rrp
                                        VALUES vv_cur_arc_rrp(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_arc_rrp ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
           -- Clear collection for vv_cur_arc_rrp
           vv_cur_arc_rrp.delete;
         END;

  end fill_arc_rrp_forall;

  ----
  -- fill_arc_rrp_part - локальная процедура, импорт arc_rrp посекционно в паралельном режиме, Direct-Path INSERT метод
  --
  procedure fill_arc_rrp_part
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ARC_RRP';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_min_dat               DATE;
    l_max_dat               DATE;
    l_exists                BOOLEAN;
    l_num                   NUMBER;

   begin

   --ikf(g_kf);
   --bc.go(g_kf);
   --
   --mgr_utl.before_fill('ARC_RRP');

       for c in (select 'NONE' as partition_name, partitioned, 0 as partition_position, null as partition_stmt
                    from all_tables
                   where owner='KF'||g_kf
                     and table_name='ARC_RRP'
                     and partitioned='NO'
                   union all
                  select partition_name, 'YES' as partitioned, partition_position, 'partition('||partition_name||')' as partition_stmt
                    from all_tab_partitions
                   where table_owner='KF'||g_kf
                     and table_name='ARC_RRP'
                     and partition_name >= 'ARCRRP_Y2015_Q1'
                   order by partition_position asc
                 )
        loop
            -- проверяем наличие в arc_rrp данных партиции KF<>.arc_rrp
            execute immediate 'select min(dat_a), max(dat_a) from '||mgr_utl.pkf('arc_rrp')||' '||c.partition_stmt into l_min_dat, l_max_dat;
            --
            l_exists := false;
            begin
                select 1
                  into l_num
                  from arc_rrp
                 where dat_a between l_min_dat and l_max_dat
                   and kf=g_kf
                   and rownum=1;
                --
                l_exists := true;
            exception
                when no_data_found then
                    null;
            end;
            --
            if l_exists
            then
                trace('Данные '||pkf('arc_rrp')||' '||c.partition_stmt||' уже импортированы в arc_rrp, пропускаем');
                continue;
            end if;

            l_migration_start_time := sysdate;
            l_start_time := current_timestamp;
            -- наполняем данные партиции
            execute immediate
            'insert /*+ APPEND parallel (8)*/
              into arc_rrp (rec, ref, mfoa, nlsa, mfob, nlsb, dk, s, vob, nd, kv, datd, datp, nam_a, nam_b, nazn, naznk, nazns, id_a, id_b,
                            id_o, ref_a, bis, sign, fn_a, dat_a, rec_a, fn_b, dat_b, rec_b, d_rec, blk, sos, prty, fa_name, fa_ln, fa_t_arm3,
                            fa_t_arm2, fc_name, fc_ln, fc_t1_arm2, fc_t2_arm2, fb_name, fb_ln, fb_t_arm2, fb_t_arm3, fb_d_arm3, kf)
            select  /*+ parallel (8)*/
                                       to_number(rukey(rec)) as rec, rukey(ref) as ref, mfoa, nlsa, mfob, nlsb, dk, s, vob, nd, kv, datd, trunc(datp) as datp, nam_a, nam_b, nazn, naznk, nazns, id_a, id_b,
                                       id_o, ref_a, bis, sign, fn_a, dat_a, rec_a, fn_b, dat_b, rec_b, d_rec, blk, sos, prty, fa_name, fa_ln, fa_t_arm3,
                                       fa_t_arm2, fc_name, fc_ln, fc_t1_arm2, fc_t2_arm2, fb_name, fb_ln, fb_t_arm2, fb_t_arm3, fb_d_arm3, '''||g_kf||'''
            from '||pkf('arc_rrp')||' '||c.partition_stmt;
            --
            commit;
            --
            trace('импортирована партиция %s', c.partition_name);
            --
            l_rowcount        := l_rowcount + sql%rowcount;
        end loop;

    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
  end fill_arc_rrp_part;

  ----
  -- fill_arc_rrp_part_date - локальная процедура, импорт arc_rrp согласно указанным датам с вычеткой данных в паралельном режиме , Partition Pruning - Direct-Path INSERT метод
  --
  procedure fill_arc_rrp_part_date(p_date date default null, p_date_end date default null)
  is
    l_date        DATE;
    l_date_end    DATE;

   begin

   --ikf(g_kf);
   --bc.go(g_kf);
   --
   --mgr_utl.before_fill('arc_rrp');

    l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
    l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');

           execute immediate
           'insert  /*+ APPEND parallel (8)*/
               into arc_rrp (rec, ref, mfoa, nlsa, mfob, nlsb, dk, s, vob, nd, kv, datd, datp, nam_a, nam_b, nazn, naznk, nazns, id_a, id_b,
                             id_o, ref_a, bis, sign, fn_a, dat_a, rec_a, fn_b, dat_b, rec_b, d_rec, blk, sos, prty, fa_name, fa_ln, fa_t_arm3,
                             fa_t_arm2, fc_name, fc_ln, fc_t1_arm2, fc_t2_arm2, fb_name, fb_ln, fb_t_arm2, fb_t_arm3, fb_d_arm3, kf)
            select  /*+ parallel (8)*/
                    to_number(rukey(rec)) as rec, rukey(ref) as ref, mfoa, nlsa, mfob, nlsb, dk, s, vob, nd, kv, datd, trunc(datp) as datp, nam_a, nam_b, nazn, naznk, nazns, id_a, id_b,
                    id_o, ref_a, bis, sign, fn_a, dat_a, rec_a, fn_b, dat_b, rec_b, d_rec, blk, sos, prty, fa_name, fa_ln, fa_t_arm3,
                    fa_t_arm2, fc_name, fc_ln, fc_t1_arm2, fc_t2_arm2, fb_name, fb_ln, fb_t_arm2, fb_t_arm3, fb_d_arm3, '''||g_kf||'''
            from '||pkf('arc_rrp')||' where dat_a between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
          commit;
  end fill_arc_rrp_part_date;

  procedure fill_arc_rrp(p_partitionway varchar2 default null, p_date date default null, p_date_end date default null)
  is
    l_tab          VARCHAR2(30) DEFAULT 'ARC_RRP';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_max_rec      NUMBER;

  begin
    --
    trace('%s: entry point', p);
    --
    --ikf(g_kf);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    mgr_utl.mantain_error_table(l_tab);

    begin
        --
        execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';

        case
            when p_partitionway = 'T'
                 and p_date is null
                 and p_date_end is null
            then fill_arc_rrp_part();
            when p_partitionway = 'T'
                 and p_date is not null
            then fill_arc_rrp_part_date(p_date, p_date_end);
            else fill_arc_rrp_forall(p_date, p_date_end);
        end case;
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    end;
  --
  bc.home();
  --
  -- заново узнаем максимальный REC в ARC_RRP
  select trunc(nvl(max(rec / 100), 0)) + 1
    into l_max_rec
    from arc_rrp;
  -- выставляем последовательность s_arc_rrp
  mgr_utl.reset_sequence('S_ARC_RRP', l_max_rec);

  --trace('собираем статистику');
  --
  -- mgr_utl.gather_table_stats('bars', 'arc_rrp', cascade=>true);
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);

  end fill_arc_rrp;

  ----
  -- clean_zag_k - очистка zag_k
  --
  --
  procedure clean_zag_k
  is
    l_tab          VARCHAR2(30) DEFAULT 'ZAG_K';
    p              CONSTANT VARCHAR2(62) := G_PKG||'.clean_'||l_tab;

  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_clean(l_tab);
    --
    begin
        --
        trace('deleting from '||l_tab);
        --
        delete
          from zag_k
         where kf = g_kf;
        --
        trace('%s rows deleted', to_char(sql%rowcount));
        --
        commit;
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_zag_k;

  ----
  -- fill_zag_k - импорт zag_k
  --
  procedure fill_zag_k
  is
    l_tab                   VARCHAR2(30) DEFAULT 'ZAG_K';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    begin
        l_migration_start_time := sysdate;
        l_start_time := current_timestamp;
        --
        trace('inserting into '||l_tab);
        --
        execute immediate
        '
        insert
          into zag_k (
               ref, kv, fn, dat, n, sde, skr,
               datk, dat_2, k_er, otm, sign, sign_key, kf)
        select rukey(ref) as ref, kv, fn, dat, n, sde, skr,
               datk, dat_2, k_er, otm, sign, sign_key, :g_kf
          from '||pkf('zag_k')
        using g_kf;
    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);
    trace('%s rows inserted', l_rowcount);

    mgr_log.p_save_log_info_mesg(ip_migration_id                  => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );
    end;
        --
        commit;
        --
        bc.home();
        --
        --trace('собираем статистику');
        --
        --mgr_utl.gather_table_stats('bars', 'zag_k', cascade=>true);
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_zag_k;

  ----
  -- clean_zag_f - очистка zag_f
  --
  --
  procedure clean_zag_f
  is
  begin
    mgr_utl.clean_local_table('zag_f', g_kf);
  end clean_zag_f;

  ----
  -- fill_zag_f - импорт zag_f
  --
  procedure fill_zag_f
  is
  begin
    --
    mgr_utl.fill_local_table('zag_f', g_kf,
       'insert
          into zag_f (
               fn, dat, n, otm, datk, err, kf, fnk, txtk)
        select fn, dat, n, otm, datk, err, '''||g_kf||''', fnk, txtk
          from '||pkf('zag_f')
    );
    --
  end fill_zag_f;

  ----
  -- clean_zag_g - очистка zag_g
  --
  --
  procedure clean_zag_g
  is
  begin
    mgr_utl.clean_local_table('zag_g', g_kf);
  end clean_zag_g;

  ----
  -- fill_zag_g - импорт zag_g
  --
  procedure fill_zag_g
  is
  begin
    --
    mgr_utl.fill_local_table('zag_g', g_kf,
       'insert
          into zag_g (
               fn, dat, n, sde, skr, sign_key, sign, kf)
        select fn, dat, n, sde, skr, sign_key, sign, '''||g_kf||'''
          from '||pkf('zag_g')
    );
    --
  end fill_zag_g;

  ----
  -- clean_zag_l - очистка zag_l
  --
  --
  procedure clean_zag_l
  is
  begin
    mgr_utl.clean_local_table('zag_l', g_kf);
  end clean_zag_l;

  ----
  -- fill_zag_l - импорт zag_l
  --
  procedure fill_zag_l
  is
  begin
    --
    mgr_utl.fill_local_table('zag_l', g_kf,
       'insert
          into zag_l (
               fn, dat, n, sign_key, sign, otm, sab, kf)
        select fn, dat, n, sign_key, sign, otm, sab, '''||g_kf||'''
          from '||pkf('zag_l')
    );
    --
  end fill_zag_l;

  ----
  -- clean_zag_mc - очистка zag_mc
  --
  --
  procedure clean_zag_mc
  is
  begin
    mgr_utl.clean_local_table('zag_mc', g_kf);
  end clean_zag_mc;

  ----
  -- fill_zag_mc - импорт zag_mc
  --
  procedure fill_zag_mc
  is
  begin
    --
    mgr_utl.fill_local_table('zag_mc', g_kf,
       'insert
          into zag_mc (
               fn, dat, n, sign_key, sign, fn2, dat2, otm, datk, sab, counter, dat_fm, kf)
        select fn, dat, n, sign_key, sign, fn2, dat2, otm, datk, sab, counter, dat_fm, '''||g_kf||'''
          from '||pkf('zag_mc')
    );
    --
  end fill_zag_mc;

  ----
  -- clean_zag_p - очистка zag_p
  --
  --
  procedure clean_zag_p
  is
  begin
    mgr_utl.clean_local_table('zag_p', g_kf);
  end clean_zag_p;

  ----
  -- fill_zag_p - импорт zag_p
  --
  procedure fill_zag_p
  is
  begin
    --
    mgr_utl.fill_local_table('zag_p', g_kf,
       'insert
          into zag_p (fn, dat, n, last_ses, kf)
        select fn, dat, n, last_ses, '''||g_kf||'''
          from '||pkf('zag_p')
    );
    --
  end fill_zag_p;

  ----
  -- clean_zag_r3 - очистка zag_r3
  --
  --
  procedure clean_zag_r3
  is
  begin
    mgr_utl.clean_local_table('zag_r3', g_kf);
  end clean_zag_r3;

  ----
  -- fill_zag_r3 - импорт zag_r3
  --
  procedure fill_zag_r3
  is
  begin
    --
    mgr_utl.fill_local_table('zag_r3', g_kf,
       'insert
          into zag_r3 (fn, god, kf)
        select fn, god, '''||g_kf||'''
          from '||pkf('zag_r3')
    );
    --
  end fill_zag_r3;

  ----
  -- sync_bopbank - синхронизация bopbank
  --
  procedure sync_bopbank
  is
  begin
    mgr_utl.sync_global_table('bopbank',
        'insert
           into bopbank(regnum, name, address, fio, eladr, bic, regnum_n)
         select regnum, substr(name,1,30), address, fio, null, bic, regnum_n
           from '||pkf('bopbank')
    );
  end sync_bopbank;

  ----
  -- sync_bopcode - синхронизация bopcode
  --
  procedure sync_bopcode
  is
  begin
    mgr_utl.sync_global_table('bopcode',
        'insert
           into bopcode(KIND, KOD_NNN, TRANSCODE, TRANSDESC, TRANSCODE_N)
         select KIND, null, TRANSCODE, TRANSDESC, TRANSCODE_N
           from '||pkf('bopcode')
    );
  end sync_bopcode;

  ----
  -- sync_BOPCOUNT - синхронизация BOPCOUNT
  --
  procedure sync_BOPCOUNT
  is
  begin
    mgr_utl.sync_global_table('BOPCOUNT',
        'insert
           into BOPCOUNT(COUNTRY, ISO_COUNTR, KODC, PR, A2)
         select trim(substr(COUNTRY,1,30)), ISO_COUNTR, KODC, PR, A2
           from '||pkf('BOPCOUNT')
    );
  end sync_BOPCOUNT;

  ----
  -- sync_BP_REASON - синхронизация BP_REASON
  --
  procedure sync_BP_REASON
  is
  begin
    mgr_utl.sync_global_table('BP_REASON',
        'insert
           into BP_REASON(ID, REASON)
         select ID, REASON
           from '||pkf('BP_REASON')
    );
  end sync_BP_REASON;

  ----
  -- sync_RCUKRU - синхронизация RCUKRU
  --
  procedure sync_RCUKRU
  is
  begin
    mgr_utl.sync_global_table('RCUKRU',
        'insert
           into RCUKRU(REESTR, GR, GR1, XX, BU, NF, PR, GLB, PRKB, RC, PRB, KB, NB, MFO, KNB, NKS, GLMFO, PI, NCKS, N_ISEP, ISEP, HCKS, FAX, TNP, NP, NAI_R, KOD_R, ADRESS, FIOPB, TELPB, FIOGB, TELGB, DATAR, D_OPEN, D_CLOSE, DIR, K040, KR, NLF, REGN, TELEFON, KU, KO, OBLUPR, TB, NB1, KODT, PR_EP, VID, N_GLB, N_PRKB, IKOD, PR_F, FULLNAME, SHORTNAME, LICDATE, LICNUM, SID)
         select REESTR, GR, GR1, XX, BU, NF, PR, GLB, PRKB, RC, PRB, KB, NB, MFO, KNB, NKS, GLMFO, PI, NCKS, N_ISEP, ISEP, HCKS, FAX, TNP, NP, NAI_R, KOD_R, ADRESS, FIOPB, TELPB, FIOGB, TELGB, DATAR, D_OPEN, D_CLOSE, DIR, K040, KR, NLF, REGN, TELEFON, KU, KO, OBLUPR, TB, NB1, KODT, PR_EP, VID, N_GLB, N_PRKB, IKOD, PR_F, FULLNAME, SHORTNAME, LICDATE, LICNUM, SID
           from '||pkf('RCUKRU')
    );
  end sync_RCUKRU;

  ----
  -- sync_REP_PROC - синхронизация REP_PROC
  --
  procedure sync_REP_PROC
  is
  begin
    mgr_utl.sync_global_table('REP_PROC',
        'insert
           into REP_PROC(PROCC, NAME, SEMANTIC)
         select PROCC, NAME, SEMANTIC
           from '||pkf('REP_PROC')
    );
  end sync_REP_PROC;

  ----
  -- sync_REPORTSF - синхронизация REPORTSF
  --
  procedure sync_REPORTSF
  is
  begin
    mgr_utl.sync_global_table('REPORTSF',
        'insert
           into REPORTSF(IDF, TYPE, NAME)
         select IDF, TYPE, NAME
           from '||pkf('REPORTSF')
    );
  end sync_REPORTSF;

  ----
  -- sync_bic_acc - синхронизация bic_acc
  --
  procedure sync_bic_acc
  is
  begin
    init();
    --
    mgr_utl.sync_table('BIC_ACC',
                       'insert into bic_acc(bic, acc, transit, their_acc, kf)
                       select bic, rukey(acc), transit, their_acc, '''||g_kf||'''
                       from ' ||pkf('bic_acc'),
                       false);
  end sync_bic_acc;

  ----
  -- sync_bank_acc - синхронизация bank_acc
  --
  procedure sync_bank_acc
  is
  begin
    init();
    --
    mgr_utl.sync_table('BANK_ACC',
                       'insert into bank_acc(kf, acc, mfo)
                       select  '''||g_kf||''', rukey(acc), mfo
                       from '||pkf('bank_acc'),
                       false);
  end sync_bank_acc;
  ------------------------------
  -- sync_BP_BACK - синхронизация BP_BACK
  --
  procedure sync_BP_BACK (p_delete boolean, p_mfo varchar2)
  is
  begin
    mgr_utl.sync_table('BP_BACK',
        'insert
           into BP_BACK(REC_IN, REC_OUT, ID, USERID, KF)
         select REC_IN, REC_OUT, ID, GetNewUserid('||p_mfo||',USERID), '||p_mfo||'
           from '||pkf('BP_BACK')
    ,p_delete);
  end sync_BP_BACK;

  ----
  -- sync_BP_RRP - синхронизация BP_RRP
  --
  procedure sync_BP_RRP
  is
  l_tab                   VARCHAR2(30 CHAR) DEFAULT 'BP_RRP';
  begin
    --
    init();
    --
    mgr_utl.mantain_error_table(l_tab);
    bpa.disable_policies(l_tab);
    mgr_utl.sync_table('BP_RRP',
                       'insert
                       into BP_RRP(RULE, MFO, FA, BODY, NAME, KF)
                       select RULE, MFO, FA, BODY, NAME, KF
                       from '||pkf('BP_RRP')||'
                       where rule is not null
                         and kf = '''||G_KF||'''' ||
                       ' log errors reject limit unlimited'
                       ,true);
    --
    trace('%s', get_errinfo('ERR$_'||l_tab));
    --
    bpa.enable_policies(l_tab);
  end sync_BP_RRP;

  ----
  -- sync_any_table - синхронизация таблицы с данными
  --
  procedure sync_any_table (p_table varchar2, p_delete boolean, p_mfo varchar2, p_insert varchar2)
  is
  begin
    mgr_utl.sync_table(p_table, p_insert, p_delete);
  end sync_any_table;

  ----
  -- sync_any_table_auto - синхронизация таблицы с данными (auto)
  --
  procedure sync_any_table_auto (p_table varchar2, p_delete boolean, p_mfo varchar2)
  is
  begin
    mgr_utl.sync_table_auto(p_table, p_delete);
  end sync_any_table_auto;

  ----
  -- tabsync - вызов mgr_utl.tabsync
  --
  procedure tabsync(p_table varchar2)
  is
  begin
    mgr_utl.tabsync(p_table);
  end tabsync;

  ----
  -- fill_perekr_r - наполнение perekr_r
  --
  procedure fill_perekr_r
  is
  begin
    tabsync('perekr_r');
    mgr_utl.sync_table('perekr_r',
        'insert
           into perekr_r(idr, name)
         values (1, ''1 UR'')'
    );
  end fill_perekr_r;

  ----
  -- fill_perekr_b - наполнение perekr_b
  --
  procedure fill_perekr_b
  is
  begin
    --
    init();
    --
    execute immediate 'alter table PEREKR_B disable constraint CC_PEREKRB_KV_NN';
    --
    mgr_utl.sync_table('PEREKR_B',
    --
    'insert into bars.perekr_b(ids, tt, mfob, nlsb, polu, nazn, kv, s, okpo, idr, koef, vob, id, formula, kod, ord, kf)
            select
              ids, tt, mfob, nlsb, nvl(polu, ''Не задано'') as polu, substr(nvl(nazn, ''Не задано''), 1, 160) as nazn,
              kv, s, okpo, nvl(idr, 1) as idr, koef, vob, s_perekr_b.NEXTVAL as id, formula, kod, null as ord, '''||g_kf||''' as kf
            from '||pkf('perekr_b'),true);
    --
    --
    execute immediate 'alter table PEREKR_B modify constraint CC_PEREKRB_KV_NN enable novalidate';
    --
  end fill_perekr_b;

  ----
  -- fill_perekr_b_update - наполнение perekr_b_update
  --
  procedure fill_perekr_b_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab         VARCHAR2(30) DEFAULT 'PEREKR_B_UPDATE';
    l_max_idupd   bars.perekr_b_update.idupd%type;
  begin
    --mgr_utl.sync_table_auto('perekr_b_update', true,
    --    'idr, "nvl(idr, 1)", polu, "nvl(polu, ''Не задано'')", nazn, "nvl(nazn, ''Не задано'')", idupd, "rukey(idupd)"');
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( id
                        , ids
                        , tt
                        , mfob
                        , nlsb
                        , polu
                        , nazn
                        , okpo
                        , idr
                        , koef
                        , vob
                        , formula
                        , kod
                        , fdat
                        , user_name
                        , idupd
                        , chaction
                        , kf
                       )
                        SELECT id
                        , ids
                        , tt
                        , mfob
                        , nlsb
                        , nvl(polu, ''Не задано'') as polu
                        , substr(nvl(nazn, ''Не задано''), 1, 160) as nazn
                        , okpo
                        , nvl(idr, 1) as idr
                        , koef
                        , vob
                        , formula
                        , kod
                        , fdat
                        , user_name
                        , rukey(idupd) as idupd
                        , chaction
                        , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.perekr_b_update;
    --
    mgr_utl.reset_sequence('s_perekr_b_update', l_max_idupd);
  end fill_perekr_b_update;
--==============================================================================
  ----
  -- fill_banks$settings - наполнение banks$settings
  --
  procedure fill_banks$settings
  is
  begin
    mgr_utl.sync_table('BANKS$SETTINGS',
    'insert
       into banks$settings (
            mfo, fmi, fmo, pm, kodn, mfop)
     select mfo, fmi, fmo, pm, kodn, mfop
       from '||pkf('banks')||'
      where kodn is not null',
    true);
  end fill_banks$settings;

  ----
  -- fill_banks$settings - наполнение banks$settings
  --
  procedure sync_banks$settings
  is
   l_tab  varchar2(30) default 'BANKS$SETTINGS';
 begin
      init();

      bpa.disable_policies('banks$settings');
      mgr_utl.before_clean('banks$settings');
      execute_statement(
      'delete banks$settings where kf = ''' || g_kf || '''',
      'Очистка налаштувань довідника банків для МФО ' || g_kf ||' таблиця '||l_tab, null, 'N');

      execute_statement(
      'insert into banks$settings
       select kf, mfo, fmi, fmo, pm, kodn, mfop
       from ' || pkf('banks$settings') || '
       where kf = ''' || g_kf || '''',
      'Доповнення налаштувань довідника банків для МФО ' || g_kf ||' таблиця '||l_tab);
      bpa.enable_policies('banks$settings');
      mgr_utl.finalize();
  end;

  ----
  -- clean - очистка произвольной таблицы
  --
  procedure clean(p_table varchar2)
  is
  begin
    mgr_utl.clean(p_table);
  end clean;

  ----
  -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
  --
  procedure mantain_error_table(p_table in varchar2)
  is
  begin
    --
    mgr_utl.mantain_error_table(p_table);
    --
  end mantain_error_table;

  ----
  -- fill_tts - наполнение tts и связных таблиц
  --
  -- для МФО 300001 после импорта заменить /300001/ на /
  --
  procedure fill_tts
  is
    l_inscnt    number;
   begin
    trace('fill_tts start');
    --
    mantain_error_table('TTS');
    mantain_error_table('CHKLIST_TTS');
    mantain_error_table('FOLDERS_TTS');
    mantain_error_table('OP_RULES');
    mantain_error_table('PS_TTS');
    mantain_error_table('TTSAP');
    mantain_error_table('VOB');
    mantain_error_table('TTS_VOB');
    mantain_error_table('STAFFTIP_TTS');


    bpa.disable_policies('TTS');        
    bpa.disable_policies('CHKLIST_TTS');
    bpa.disable_policies('FOLDERS_TTS');
    bpa.disable_policies('OP_RULES');
    bpa.disable_policies('PS_TTS');
    bpa.disable_policies('TTSAP');
    bpa.disable_policies('VOB');
    bpa.disable_policies('TTS_VOB');
    bpa.disable_policies('STAFFTIP_TTS');
    --
    bc.go(g_kf);
    --
    -- TTS
    --
        case when g_kf = g_glb_mfo then

         execute_statement(
              'merge into TTS a using (select tt, name, dk, nlsm, kv, nlsk, kvk, nlss,
           nlsa, nlsb, mfob, flc, fli, flv, flr,
           s, s2, sk, proc, s3800, s6201, s7201, rang, flags, nazn
                                                 from '||pkf('TTS')||') s on (a.tt = s.tt) 
                         when matched then update set a.name = substr(s.name,1,70)
                                                    , a.dk = s.dk
                                                    , a.nlsm = s.nlsm
                                                    , a.kv = s.kv
                                                    , a.nlsk = s.nlsk
                                                    , a.kvk = s.kvk
                                                    , a.nlss = s.nlss
                                                    , a.nlsa = s.nlsa
                                                    , a.nlsb = s.nlsb
                                                    , a.mfob = s.mfob
                                                    , a.flc = nvl(s.flc,0)
                                                    , a.fli = nvl(s.fli,0)
                                                    , a.flv = nvl(s.flv,0)
                                                    , a.flr = nvl(s.flr,0)
                                                    , a.s = s.s
                                                    , a.s2 = s.s2
                                                    , a.sk = s.sk
                                                    , a.proc = s.proc
                                                    , a.s3800 = s.s3800
                                                    , a.s6201 = s.s6201
                                                    , a.s7201 = s.s7201
                                                    , a.rang = s.rang
                                                    , a.flags = s.flags
                                                    , a.nazn = s.nazn
                                                    --, a.id = s_tts.nextval
              when not matched then insert values    (  s.tt
                                                      , substr(s.name,1,70)
                                                      , s.dk
                                                      , s.nlsm
                                                      , s.kv
                                                      , s.nlsk
                                                      , s.kvk
                                                      , s.nlss
                                                      , s.nlsa
                                                      , s.nlsb
                                                      , s.mfob
                                                      , nvl(s.flc,0)
                                                      , nvl(s.fli,0)
                                                      , nvl(s.flv,0)
                                                      , nvl(s.flr,0)
                                                      , s.s
                                                      , s.s2
                                                      , s.sk
                                                      , s.proc
                                                      , s.s3800
                                                      , s.s6201
                                                      , s.s7201
                                                      , s.rang
                                                      , s.flags
                                                      , s.nazn
                                                      , s_tts.nextval)',
                    'Доповнення новими значеннями TTS');
        else 
        begin
            execute immediate
           'insert
              into bars.tts (
                   tt, name, dk, nlsm, kv, nlsk, kvk, nlss, nlsa, nlsb, mfob, flc, fli, flv, flr,
                   s, s2, sk, proc, s3800, s6201, s7201, rang, flags, nazn)
            select t.tt, substr(name,1,70), dk, nlsm, kv, nlsk, kvk, nlss,
                   nlsa, nlsb, mfob, nvl(flc,0), nvl(fli,0), nvl(flv,0), nvl(flr,0),
                   s, s2, sk, proc, s3800, s6201, s7201, rang, flags, nazn
              from '||pkf('tts')||' t log errors reject limit unlimited'
            /*using g_kf*/;
            --
            l_inscnt := sql%rowcount;
            --
            trace('TTS: %s строк вставлено %s', to_char(l_inscnt), get_errinfo('err$_tts'));
            --
            commit;
            
        end;
        end case;
        
    --
    -- CHKLIST_TTS
    --
    execute immediate
    'insert
       into bars.chklist_tts(
            tt, idchk, priority, f_big_amount, sqlval, f_in_charge, flags)
     select t.tt, t.idchk, priority, f_big_amount, sqlval, f_in_charge, flags
       from '||pkf('chklist_tts')||' t log errors reject limit unlimited';
    --
    l_inscnt := sql%rowcount;
    --
    trace('CHKLIST_TTS: %s строк вставлено %s',
        to_char(l_inscnt), get_errinfo('err$_chklist_tts')
    );
    --
    commit;

    --
    -- FOLDERS_TTS
    --
    execute immediate
    'insert
       into bars.folders_tts(idfo, tt)
     select t.idfo, t.tt
       from '||pkf('folders_tts')||' t log errors reject limit unlimited';
    --
    l_inscnt := sql%rowcount;
    --
    trace('FOLDERS_TTS: %s строк вставлено %s',
        to_char(l_inscnt), get_errinfo('err$_folders_tts')
    );
    --
    commit;
    --
    -- OP_RULES
    --
    execute immediate
    'insert
       into bars.op_rules(tt, tag, opt, used4input, ord, val, nomodify)
     select t.tt, tag, opt, used4input, ord, val, null as nomodify
       from '||pkf('op_rules')||' t log errors reject limit unlimited';
    --
    l_inscnt := sql%rowcount;
    --
    trace('OP_RULES: %s строк вставлено %s',
        to_char(l_inscnt), get_errinfo('err$_op_rules')
    );
    --
    commit;
    --
    --
    -- PS_TTS
    --
    execute immediate
    'insert
       into bars.ps_tts(id, tt, nbs, dk, ob22)
     select id, tt, nbs, dk, ob22
       from '||pkf('ps_tts')||' t log errors reject limit unlimited';
    --
    l_inscnt := sql%rowcount;
    --
    trace('PS_TTS: %s строк вставлено %s',
        to_char(l_inscnt), get_errinfo('err$_ps_tts')
    );
    --
    commit;

    --
    -- TTSAP
    --
    --if g_kf=g_glb_mfo
    --then
      begin
          execute immediate
          'insert
             into bars.ttsap(tt, ttap, dk)
           select t.tt, t.ttap, t.dk
             from '||pkf('ttsap')||' t log errors reject limit unlimited';
          --
          l_inscnt := sql%rowcount;
          --
          trace('TTSAP: %s строк вставлено %s',
              to_char(l_inscnt), get_errinfo('err$_ttsap')
          );
          --
          commit;
      end;
    --end if;

    --
    -- VOB
    --
        case when g_kf = g_glb_mfo then

         execute_statement(
              'merge into VOB a using (select vob
                                            , name
                                            , flv
                                            , rep_prefix
                                            , ovrd4ipmt
                                            , kdoc
                                            , rep_prefix_fr
                                            , kod
                                         from '||pkf('VOB')||') s on (a.VOB = s.VOB) 
                 when matched then update set a.name = s.name
                                            , a.flv = s.flv
                                            , a.rep_prefix = s.rep_prefix
                                            , a.ovrd4ipmt = s.ovrd4ipmt
                                            , a.kdoc = s.kdoc
                                            , a.rep_prefix_fr = s.rep_prefix_fr
                                            , a.kod = s.kod
              when not matched then insert values    (  s.vob
                                            , s.name
                                            , s.flv
                                            , s.rep_prefix
                                            , s.ovrd4ipmt
                                            , s.kdoc
                                            , s.rep_prefix_fr
                                            , s.kod)',
                    'Доповнення новими значеннями VOB');
        else 
        begin
         execute_statement(
              'merge into VOB a using (select vob
                                            , name
                                            , flv
                                            , rep_prefix
                                            , ovrd4ipmt
                                            , kdoc
                                            , rep_prefix_fr
                                            , kod
                                         from '||pkf('VOB')||') s on (a.VOB = s.VOB) 
              when not matched then insert values    (  s.vob
                                            , s.name
                                            , s.flv
                                            , s.rep_prefix
                                            , s.ovrd4ipmt
                                            , s.kdoc
                                            , s.rep_prefix_fr
                                            , s.kod)',
                    'Доповнення новими значеннями VOB');
        end;
        end case;        
    --
    -- TTS_VOB
    --
    execute immediate
    'insert
       into bars.tts_vob(tt, vob, ord)
     select t.tt, t.vob, t.ord
       from '||pkf('tts_vob')||' t log errors reject limit unlimited';
    --
    l_inscnt := sql%rowcount;
    --
    trace('TTS_VOB: %s строк вставлено %s',
        to_char(l_inscnt), get_errinfo('err$_tts_vob')
    );
    --
    commit;
    --
    -- STAFFTIP_TTS
    --
    execute immediate
    'insert
       into bars.STAFFTIP_TTS(id, tt)
     select t.id, t.tt
       from '||pkf('STAFFTIP_TTS')||' t log errors reject limit unlimited';
    --
    l_inscnt := sql%rowcount;
    --
    trace('STAFFTIP_TTS: %s строк вставлено %s',
        to_char(l_inscnt), get_errinfo('err$_STAFFTIP_TTS')
    );
    --
    commit;

    bc.home();
    --
    bpa.enable_policies('TTS');        
    bpa.enable_policies('CHKLIST_TTS');
    bpa.enable_policies('FOLDERS_TTS');
    bpa.enable_policies('OP_RULES');
    bpa.enable_policies('PS_TTS');
    bpa.enable_policies('TTSAP');
    bpa.enable_policies('VOB');
    bpa.enable_policies('TTS_VOB');
    bpa.enable_policies('STAFFTIP_TTS');
    --

    trace('fill_tts finish');
    --
  end fill_tts;
  ----
  --
  --
  function replace_userid(p_str in varchar2)
  return varchar2
  is
    p   constant varchar2(61) := G_PKG||'.replusrid';
    l_new_uid    varchar2(30);
  begin
    l_new_uid := ruuser(p_str);
    trace('%s: %s -> %s', p, p_str, l_new_uid);
    return l_new_uid;
  end replace_userid;

  ----
  --
  --
  function replace_userid_wrap(p_str in varchar2)
  return varchar2
  is
    p           constant varchar2(61) := G_PKG||'.replusridwrp';
    l_c1        varchar2(1)           := substr(p_str, 1, 1);
    l_c2        varchar2(1)           := substr(p_str, -1, 1);
    l_i1        integer;
    l_i2        integer;
  begin
    trace('%s: p_str = ''%s''', p, p_str);
    --
    if p_str is null
    then
        return null;
    else
        if regexp_like(l_c1,'[^[:digit:]]{1}')
        then
            l_i1 := 1;
        else
            l_i1 := 0;
        end if;
        if regexp_like(l_c2,'[^[:digit:]]{1}')
        then
            l_i2 := 1;
        else
            l_i2 := 0;
        end if;
        -- добавляем в хвост пробел для корректного поиска следующего вхождения
        return substr(p_str,1,l_i1)||replace_userid(substr(p_str,1+l_i1,length(p_str)-l_i1-l_i2))||substr(p_str,-1,l_i2)||' ';
    end if;
    --
  end replace_userid_wrap;

  ----
  -- clean_cur_rates - очистка cur_rates
  --
  procedure clean_cur_rates
  is
    p           constant varchar2(62) := G_PKG||'.clean_cur_rates';
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean('cur_rates$base');
    --
    -- отключаем политику, она не дает удалить данные
    bpa.disable_policies('cur_rates$base');
    --
    begin
        --
        trace('deleting from cur_rates$base');
        --
        delete
          from cur_rates$base
         where branch like '/'||g_kf||'/%';
        --
        trace('%s rows deleted (by %s)', to_char(sql%rowcount), '/'||g_kf||'/%');
        --
        if g_kf=g_glb_mfo
        then
            delete
              from cur_rates$base
             where branch='/';
            --
            trace('%s rows deleted (by /)', to_char(sql%rowcount));
        end if;
        --
        commit;
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    -- включаем политику
    bpa.enable_policies('cur_rates$base');
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_cur_rates;

  ----
  -- fill_cur_rates - наполнение cur_rates
  --
  procedure fill_cur_rates
  is
    l_tab           varchar2(30 char) default 'CUR_RATES$BASE';
    p               constant varchar2(62) := G_PKG||'.fill_'||l_tab;
  begin
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    mgr_utl.mantain_error_table(l_tab);
    --
    begin
        trace('inserting into '||l_tab);
        --
        execute_statement(
       'insert
          into cur_rates$base (
               kv, vdate, bsum, rate_o, rate_b, rate_s,
               rate_spot, rate_forward, lim_pos, branch, otm, official)
        select c.kv, c.vdate, c.bsum, c.rate_o, c.rate_b, c.rate_s,
               c.rate_spot, c.rate_forward, c.lim_pos, b.branch, ''Y'', c.official
          from '||pkf('cur_rates$base')||' c, branch b
         where c.branch = b.branch
           and b.branch like ''/'||g_kf||'/%'''||' log errors reject limit unlimited',
       'Завантаження кусів валют для МФО ' || g_kf ||' таблиця '||l_tab);
        --
        trace('%s rows inserted (by %s)', to_char(sql%rowcount), '/'||g_kf||'/%');
        --
        if g_kf=g_glb_mfo
        then
           execute_statement(
           'insert
              into cur_rates$base (
                   kv, vdate, bsum, rate_o, rate_b, rate_s,
                   rate_spot, rate_forward, lim_pos, branch, otm, official)
            select c.kv, c.vdate, c.bsum, c.rate_o, c.rate_b, c.rate_s,
                   c.rate_spot, c.rate_forward, c.lim_pos, ''/'', ''Y'', c.official
              from '||pkf('cur_rates$base')||' c'||' log errors reject limit unlimited',
       'Завантаження кусів валют для МФО ' || g_kf ||' таблиця '||l_tab);
            trace('%s rows inserted (by /)', to_char(sql%rowcount));
        end if;
        --
        commit;
    --
    bc.home();
    --
    --trace('собираем статистику');
    --
    --mgr_utl.gather_table_stats('bars', 'cur_rates$base', cascade=>true);
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end fill_cur_rates;


  ----
  -- clean_dyn_filter - очистка dyn_filter
  --
  procedure clean_dyn_filter
  is
    p           constant varchar2(62) := G_PKG||'.clean_dyn_filter';
  begin
    --
    trace('%s: entry point', p);
    --
    bc.home();
    --
    mgr_utl.before_clean('dyn_filter');
    --
    begin
        --
        trace('deleting from dyn_filter');
        --
        delete
          from dyn_filter
         where userid is not null
           and userid in (select id
                            from staff$base
                           where branch like g_branch_mask
                         );
        --
        trace('%s rows deleted', to_char(sql%rowcount));
        --
        commit;
        --
    exception
        when others then
            rollback;
            mgr_utl.save_error();
    end;
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    trace('%s: finished', p);
    --
  end clean_dyn_filter;


  ----
  -- fill_dyn_filter - наполнение dyn_filter
  --
  procedure fill_dyn_filter
   is
  l_tab                   VARCHAR2(30 CHAR) DEFAULT 'DYN_FILTER';
  begin
  --
  init();
  --
  mgr_utl.mantain_error_table(l_tab);
  --
  mgr_utl.sync_table('DYN_FILTER',
                     'insert into dyn_filter
                     select
                            d.filter_id||'''||g_ru||''' filter_id,
                            m.tabid tabid,
                            GetNewUserid('''||g_kf||''',d.userid) userid,
                            nvl(d.semantic,''Не заполнено''),
                            d.from_clause,
                            d.where_clause,
                            d.pkey,
                            case when pkey is null then '''||'/'||g_kf||'/'||''' else ''/'' end branch,
                            null as CONDITION_LIST 
                     from '||pkf('dyn_filter')||' d , '||pkf('meta_tables')||'  km, meta_tables m
                     where d.where_clause is not null
                     and d.tabid=km.tabid
                     and km.tabname=m.tabname
                     log errors reject limit unlimited',
                     false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_dyn_filter;

  ----
  -- fill_otdel - наполнение otdel
  --
  procedure fill_otdel
     is
     p           constant varchar2(62) := G_PKG||'.fill_otdel';
  begin
   --
     trace('%s: entry point', p);
   --
     mgr_utl.before_clean('otdel');
   --
       begin
            trace('inserting into OTDEL');
          --Надо импортить на свой BRANCH
            execute immediate 'insert into otdel(id, name, branch) select rukey(id), name, ''/''||:g_kf||''/'' from '||pkf('otdel') using g_kf;
          --
            trace('%s rows insert', to_char(sql%rowcount));
          --
            commit;
          --
            exception
                when others then
                     rollback;
            mgr_utl.save_error();
        end;

       --
        mgr_utl.finalize();
       --
        trace('%s: finished', p);
       --
                --mgr_utl.sync_table_auto(
                --    p_table             => 'OTDEL',
                --    p_delete            => true,
                --    p_column_replace    => 'id, "rukey(id)"'
                --);

  end fill_otdel;

  ----
  -- fill_otd_user
  --
  procedure fill_otd_user
     is
     p           constant varchar2(62) := G_PKG||'.fill_otd_user';
  begin
   --
    /* trace('%s: entry point', p);
   --
     mgr_utl.before_clean('otd_user');
   --
       begin
            trace('inserting into otd_user');
          --Надо импортить на свой BRANCH
          execute immediate 'insert into otd_user(otd, userid, pr, branch) select rukey(otd), ruuser(userid), pr,  ''/''||:g_kf||''/'' from '||pkf('otd_user') using g_kf;
          --
            trace('%s rows insert', to_char(sql%rowcount));
          --
            commit;
          --
            exception
                when others then
                     rollback;
            mgr_utl.save_error();

        end;*/
                      mgr_utl.sync_table('OTD_USER',
                             'insert into bars.OTD_USER
                             select otd, ruuser(userid) as userid, pr
                             from '||mgr_utl.pkf('OTD_USER'),
                             true);

       --
        mgr_utl.finalize();
       --
        trace('%s: finished', p);
       --

  end fill_otd_user;



  ----
  -- diff_zapros - создает протокол расхождений по таблице zapros
  --
  procedure diff_zapros
  is
  begin
    mgr_utl.tabdiff(pkf('zapros'), 'bars.zapros',
                           'pkey', null, null,
                           'name', 'namef', 'bindvars',
                           'CREATE_STMT',
                           'RPT_TEMPLATE',
                           'FORM_PROC',
                           'DEFAULT_VARS',
                           'BIND_SQL',
                           p_col_clob_1 => 'TXT'
                          );
  end diff_zapros;

  ----
  -- fill_operlist - наполнение operlist
  --
  procedure fill_operlist
  is
    --l_cnt          number;
    --l_errtab       constant varchar2(30) := 'ERR$_OPERLIST';
    l_tab          constant varchar2(30) := 'OPERLIST';
    l_codeoper     number;-- := OperListNextId();

  begin
        bc.home();
        --
        select nvl(max(codeoper),0)+1
          into l_codeoper
          from bars.operlist;
        --
        bc.go(g_kf);
    --
    mantain_error_table(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    --
    mgr_utl.sync_table(
       'OPERLIST',
       'insert
          into bars.operlist (
               codeoper,
               name,
               dlgname,
               funcname,
               semantic,
               runable,
               parentid,
               rolename,
               frontend,
               usearc)
        select
               '||l_codeoper||'+rownum as codeoper,
               name,
               dlgname,
               funcname,
               semantic,
               runable,
               parentid,
               upper(rolename),
               frontend,
               usearc
        from '||pkf('operlist')||chr(10)||
      'where funcname is not null
         and funcname not in (select funcname from bars.operlist)
      log errors reject limit unlimited', false);

    --l_cnt := get_rowcount(l_errtab);
    mgr_utl.enable_table_triggers(l_tab);

    /*if l_cnt>0
    then
        trace('%s', get_errinfo(l_errtab));
        -- Обработка ошибок
        begin
            select 1
              into l_num
              from err$_operlist
             where ora_err_mesg$ not like 'ORA-00001: unique constraint (BARS.I_OPERLIST_FUNCNAME) violated%';
            -- есть ошибки отличные от неуникальных funcname? => караул!!
            raise_application_error(-20000, 'Возникли критичные ошибки, проанализируйте протокол!');
        exception when no_data_found then
            trace('Обрабатываем ошибки уникальности путем переноса записей в корень');
            update operlist
               set branch = '/',
                   name='/ '||name
             where branch <> '/'
               and funcname in
                   (select funcname
                      from err$_operlist
                   );
            trace('%s записей перенесено в корень', to_char(sql%rowcount));
            commit;
        end;
    end if;*/
    --
    trace('%s', get_errinfo('ERR$_'||l_tab));
    --
  end fill_operlist;

  procedure fill_operlist_deps
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'OPERLIST_DEPS',
                         p_stmt  => 'insert into bars.operlist_deps(id_parent, id_child)
                                    SELECT id_parent, id_child
                                    FROM (SELECT o.codeoper ID_PARENT, o2.codeoper ID_CHILD
                                          FROM '||pkf('operlist_deps')||' kod,
                                               '||pkf('operlist')||' ko,
                                               '||pkf('operlist')||' ko2,
                                               operlist o,
                                               operlist o2
                                         WHERE     KOD.ID_PARENT = KO.CODEOPER
                                               AND KOD.ID_CHILD = ko2.codeoper
                                               AND ko.funcname = o.funcname
                                               AND ko2.funcname = o2.funcname)
                                    WHERE (id_parent, id_child) NOT IN (SELECT id_parent, id_child FROM operlist_deps)',
                         p_delete => false);
  end fill_operlist_deps;

  procedure fill_operlist_deps_acs
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'OPERLIST_DEPS_ACS',
                         p_stmt  => 'insert into bars.operlist_deps_acs(id_parent, id_child)
                                    SELECT distinct id_parent, id_child
                                    FROM (SELECT o.codeoper ID_PARENT, o2.codeoper ID_CHILD
                                          FROM '||pkf('operlist_deps_acs')||' kod,
                                               '||pkf('operlist')||' ko,
                                               '||pkf('operlist')||' ko2,
                                               operlist o,
                                               operlist o2
                                         WHERE     KOD.ID_PARENT = KO.CODEOPER
                                               AND KOD.ID_CHILD = ko2.codeoper
                                               AND ko.funcname = o.funcname
                                               AND ko2.funcname = o2.funcname)
                                    WHERE (id_parent, id_child) NOT IN (SELECT id_parent, id_child FROM operlist_deps_acs)',
                         p_delete => false);
  end fill_operlist_deps_acs;

  procedure fill_operlist_acspub
    is
    begin
      init();
      mgr_utl.sync_table(p_table  => 'OPERLIST_ACSPUB',
                         p_stmt   => 'insert into bars.operlist_acspub
                                      select * from '||pkf('operlist_acspub')||' where funcname not in(select funcname from operlist_acspub)',
                         p_delete  => false);
  end fill_operlist_acspub;

  -- fill_applist - наполнение applist
  --
  procedure fill_applist
  is
  l_id           applist.id%TYPE;

  begin
    --
    bc.home();
    select nvl(max(id), 0) + 1 into l_id from bars.applist;
    --      mgr_utl.reset_sequence('', id);
    bc.go(g_kf);
    --
    execute immediate 'alter table OPERAPP disable constraint FK_OPERAPP_APPLIST';
    --
    mgr_utl.sync_table(
       'APPLIST',
       'insert
          into bars.applist (
               codeapp,
               name,
               hotkey,
               frontend,
               id)
        select codeapp,
               name,
               hotkey,
               frontend,
               '||l_id||'+rownum as id
          from '||pkf('applist')||'
         where codeapp not in (select substr(codeapp,1,4) from bars.applist)', false);
  --
  end fill_applist;

  ----
  -- fill_operapp - наполнение operapp
  --
  procedure fill_operapp
  is
    l_errtab    constant varchar2(30) := 'ERR$_OPERAPP';
  begin
    mantain_error_table('OPERAPP');
    mgr_utl.sync_table(
       'OPERAPP',
       'insert
          into bars.operapp (
               codeapp,
               codeoper,
               hotkey,
               approve,
               adate1,
               adate2,
               rdate1,
               rdate2,
               reverse,
               revoked,
               grantor)
        select d.codeapp,
               c.codeoper,
               a.hotkey,
               a.approve,
               a.adate1,
               a.adate2,
               a.rdate1,
               a.rdate2,
               a.reverse,
               a.revoked,
               ruuser(a.grantor) as grantor
         from '||pkf('operapp')||' a, '||pkf('operlist')||' b, bars.operlist c, bars.applist d
         where a.codeoper=b.codeoper
           and b.funcname=c.funcname
           and b.funcname is not null
           and a.codeapp = d.codeapp
        log errors reject limit unlimited' , false);

    trace('%s', get_errinfo(l_errtab));
  --
  execute immediate 'alter table OPERAPP enable constraint FK_OPERAPP_APPLIST';
  --
  end fill_operapp;

  ----
  -- fill_refapp - наполнение refapp
  --
  procedure fill_refapp
  is
    l_errtab    constant varchar2(30) := 'ERR$_REFAPP';
  begin
    mantain_error_table('REFAPP');
    mgr_utl.sync_table(
       'REFAPP',
       'insert
          into bars.refapp (
               tabid,
               codeapp,
               acode,
               approve,
               adate1,
               adate2,
               rdate1,
               rdate2,
               revoked,
               grantor)
        select c.tabid,
               d.codeapp,
               nvl(a.acode,''RO''),
               a.approve,
               a.adate1,
               a.adate2,
               a.rdate1,
               a.rdate2,
               a.revoked,
               ruuser(a.grantor) as grantor
         from '||pkf('refapp')||' a, '||pkf('meta_tables')||' b, bars.meta_tables c, bars.applist d
         where a.tabid=b.tabid
           and upper(b.tabname)=c.tabname
           and a.codeapp = d.codeapp
        log errors reject limit unlimited', false);

    trace('%s', get_errinfo(l_errtab));

  end fill_refapp;

  ----
  -- fill_app_rep - наполнение app_rep
  --
  procedure fill_app_rep
  is
    l_errtab    constant varchar2(30) := 'ERR$_APP_REP';
  begin
    mantain_error_table('APP_REP');
    mgr_utl.sync_table(
       'APP_REP',
       'insert
          into bars.app_rep (
               codeapp,
               coderep,
               approve,
               adate1,
               adate2,
               rdate1,
               rdate2,
               revoked,
               acode,
               grantor)
        select d.codeapp,
               a.coderep,
               a.approve,
               a.adate1,
               a.adate2,
               a.rdate1,
               a.rdate2,
               a.revoked,
               null as acode,
               ruuser(a.grantor) as grantor
         from '||pkf('app_rep')||' a, bars.applist d
         where a.codeapp = d.codeapp
        log errors reject limit unlimited', false);

    trace('%s', get_errinfo(l_errtab));

  end fill_app_rep;

  ----
  -- fill_applist_staff - наполнение applist_staff
  --
  procedure fill_applist_staff
  is
    l_errtab    constant varchar2(30) := 'ERR$_APPLIST_STAFF';
  begin
    mantain_error_table('APPLIST_STAFF');
    -- сначала заберем у пользователей права на АРМы, если оны были выданы
    /*
    for c in (select *
                from bars.applist_staff
               where branch like '/'||g_kf||'/%'
               order by codeapp, id
             )
    loop
        trace('revoke arm ''%s'' privs from user_id ''%s'' ', c.codeapp, to_char(c.id));
        usr_revoke_arm(c.id, c.codeapp);
    end loop;
    */
    --
    mgr_utl.sync_table(
       'APPLIST_STAFF',
       'insert
          into bars.applist_staff (
               id,
               codeapp,
               approve,
               adate1,
               adate2,
               rdate1,
               rdate2,
               revoked,
               grantor)
        select rukey(a.id) as id,
               d.codeapp,
               a.approve,
               a.adate1,
               a.adate2,
               a.rdate1,
               a.rdate2,
               a.revoked,
               ruuser(a.grantor) as grantor
          from '||pkf('applist_staff')||' a, bars.applist d
         where a.codeapp = d.codeapp
        log errors reject limit unlimited',
        false);
    --
    trace('%s', get_errinfo(l_errtab));
/*
    --
    -- выдаем права на АРМы
    for c in (select id, codeapp, approve, adate1, adate2, rdate1, rdate2, revoked, grantor
                from bars.applist_staff
               where 1=1 -- rfc = g_kf
               order by codeapp, id
             )
    loop
        trace('grant arm ''%s'' privs to user_id ''%s'' ', c.codeapp, to_char(c.id));
        usr_grant_arm(c.id, c.codeapp);
    end loop;
*/
    --
  end fill_applist_staff;

  ----
  -- fill_staff_tts - наполнение staff_tts
  --
  procedure fill_staff_tts
  is
    l_errtab    constant varchar2(30) := 'ERR$_STAFF_TTS';
  begin
    mantain_error_table('STAFF_TTS');
    --
    mgr_utl.sync_table(
       'STAFF_TTS',
       'insert
          into bars.staff_tts (
               tt,
               id,
               approve,
               adate1,
               adate2,
               rdate1,
               rdate2,
               revoked,
               grantor)
        select a.tt,
               ruuser(a.id),
               a.approve,
               a.adate1,
               a.adate2,
               a.rdate1,
               a.rdate2,
               a.revoked,
               ruuser(a.grantor) as grantor
          from '||pkf('staff_tts')||' a
         where (a.id>1 or a.id=1 and '''||g_kf||'''='''||g_glb_mfo||''')
        log errors reject limit unlimited
       '
       ,
       false
    );
    --
    trace('%s', get_errinfo(l_errtab));
    --
  end fill_staff_tts;

  ----
  -- fill_staff_chk - наполнение staff_chk
  --
  procedure fill_staff_chk
  is
    l_errtab    constant varchar2(30) := 'ERR$_STAFF_CHK';
  begin
    mantain_error_table('STAFF_CHK');
    --
    mgr_utl.sync_table(
       'STAFF_CHK',
       'insert
          into bars.staff_chk (
               id,
               chkid,
               approve,
               adate1,
               adate2,
               rdate1,
               rdate2,
               revoked,
               grantor)
        select decode(a.id,1,1,to_number(a.id||'''||g_ru||''')),
               a.chkid,
               a.approve,
               a.adate1,
               a.adate2,
               a.rdate1,
               a.rdate2,
               a.revoked,
               ruuser(a.grantor) as grantor
          from '||pkf('staff_chk')||' a
         where (a.id>1 or a.id=1 and '''||g_kf||'''='''||g_glb_mfo||''')
        log errors reject limit unlimited', false);
    --
    trace('%s', get_errinfo(l_errtab));
    --
  end fill_staff_chk;

  ----
  -- fill_staff_klf00 - наполнение staff_klf00
  --
  procedure fill_staff_klf00
  is
    l_errtab    constant varchar2(30) := 'ERR$_STAFF_KLF00';
  begin
    mantain_error_table('STAFF_KLF00');
    --
    mgr_utl.sync_table(
       'STAFF_KLF00',
       'insert
          into bars.staff_klf00 (
               id,
               kodf,
               a017,
               approve,
               adate1,
               adate2,
               rdate1,
               rdate2,
               reverse,
               revoked,
               grantor)
        select decode(a.id,1,1,to_number(a.id||'''||g_ru||''')) as usrid,
               a.kodf,
               a.a017,
               a.approve,
               a.adate1,
               a.adate2,
               a.rdate1,
               a.rdate2,
               a.reverse,
               a.revoked,
               ruuser(a.grantor) as grantor
          from '||pkf('staff_klf00')||' a
         where (a.id>1 or a.id=1 and '''||g_kf||'''='''||g_glb_mfo||''')
        log errors reject limit unlimited', false);
    --
    trace('%s', get_errinfo(l_errtab));
    --
  end fill_staff_klf00;

  ----
  -- adjust_role_grants - выдает недостающие роли пользователям
  --
  procedure adjust_role_grants
  is
  begin
    for c in
    (-- роли, которые должны быть выданы
        select unique grantee, granted_role
        from
        (
        select logname as grantee, rolename as granted_role
        from staff$base s, applist_staff ss, operapp p, operlist f
        where s.id=ss.id
          and ss.codeapp=p.codeapp
          and p.codeoper=f.codeoper
          and f.rolename is not null
        union all
        select s.logname as grantee, r.role2edit as granted_role
        from staff$base s, applist_staff ss, refapp p, references r
        where s.id=ss.id
          and ss.codeapp=p.codeapp
          and p.tabid=r.tabid
          and r.role2edit is not null
        )
        minus
        -- реально выданные роли
        select unique p.grantee, p.granted_role
        from all_users u, DBA_ROLE_PRIVS p, staff$base s
        where u.username=p.grantee
          and u.username=s.logname
  )
  loop
   begin
      execute immediate 'grant '||c.granted_role||' to '||c.grantee;
      exception when others then null;
    end;
  end loop;
  --
  end adjust_role_grants;

  ----
  -- check_local_tables - проверяет наличие данных в таблицах с полями KF, BRANCH, RFC и пр.
  --
  procedure check_local_tables
  is
    l_stmt  varchar2(1024);
    l_cnt   number;
  begin
      trace('KF='||g_kf);
      --
      /*
      trace('KF-tables:');
      --
      for c in (select t.table_name
                  from user_tables t, user_tab_columns c
                 where c.column_name='KF'
                   and t.table_name=c.table_name
                   and t.table_name not like 'MGR\_%' escape '\'
                   and t.table_name<>'KF_RU'
                 order by t.table_name)
      loop
        l_stmt := 'select count(*) from '||c.table_name||' where kf='''||g_kf||'''';
        --
        execute immediate l_stmt into l_cnt;
        --
        if l_cnt>0
        then
            trace(c.table_name||', count='||l_cnt);
        end if;
        --
      end loop;
      --
      */
      trace('----');
      trace('BRANCH-tables:');
      --
      for c in (select t.table_name, c.column_name
                  from user_tables t, user_tab_columns c
                 where c.column_name in ('BRANCH', 'TOBO', 'BRANCH_K', 'CURRENT_BRANCH')
                   and t.table_name=c.table_name
                   and t.table_name not like 'MGR\_%' escape '\'
                   and t.table_name<>'BRANCH'
                 order by t.table_name)
      loop
        l_stmt := 'select count(*) from '||c.table_name||' where '||c.column_name||' like ''/'||g_kf||'/%''';
        --
        execute immediate l_stmt into l_cnt;
        --
        if l_cnt>0
        then
            trace(c.table_name||', count='||l_cnt);
        end if;
        --
      end loop;
      --
  end check_local_tables;

 ---
 -- Процедура импорта NLK_REF + _UPDATE
 --
 procedure fill_nlk_ref
    is
 begin
    --
    init();
    --
    mgr_utl.sync_table('NLK_REF',
    --
    'insert into bars.nlk_ref(ref1, acc)
            select to_number(ref1||'''||g_ru||'''), rukey(acc)
            from '||pkf('nlk_ref')||' where ref2 is null',true);
    --
 end fill_nlk_ref;

 procedure fill_nlk_ref_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'NLK_REF_UPDATE';
    l_max_idupd   bars.nlk_ref_update.idupd%type;

    begin
    init();
    --bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table('NLK_REF_UPDATE',
                       'INSERT INTO NLK_REF_UPDATE
                        SELECT rukey(ref1) as ref1,rukey(ref2) as ref2, rukey(acc) as acc, '''||g_kf||''' as kf,
                               ref2_state, chgdate, chgaction, ruuser(DONEBY) as doneby, rukey(idupd) as idupd
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.nlk_ref_update;
    --
    mgr_utl.reset_sequence('s_nlk_ref_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    --bpa.enable_policies(l_tab);
    --
  end fill_nlk_ref_update;

  ---
  -- Процедура импорта ALIEN
  --
  procedure fill_alien
    is
  begin
    --
        init();
    --
     mgr_utl.sync_table('ALIEN',
    --
    'insert into alien(mfo, nls, nlsalt, kv, okpo, name, crisk, notesec, id, rec_id)
         select mfo, nls, nlsalt, kv, okpo, name, crisk, notesec, id, s_alien.nextval from '||pkf('alien')||' ',false);
    --
  end fill_alien;

  ---
  -- Импорт SPOT
  --
  procedure fill_spot
    is
   begin
    --
        init();
    --
        mgr_utl.sync_table('spot',
    --
            'insert into spot(kv, vdate, rate_k,rate_p, acc, branch, rate_spot)
            select kv, vdate, rate_k,rate_p, rukey(acc), branch, null as rate_spot
            from '||pkf('spot'),false);

   end fill_spot;

   procedure fill_t902
    is
   begin
    --
        init();
    --
        mgr_utl.sync_table('T902',
    --
            'insert into bars.t902(ref, rec, otm, dat, rec_o, s, stmp, blk)
                select rukey(ref) as ref, rukey(rec) as rec, otm, dat, rukey(rec_o) as rec_o, s, stmp, blk
                from '||pkf('t902'),true);
    --

   end fill_t902;

  procedure fill_vp_list_tmp
  is
   l_tab varchar2(50) default 'VP_LIST';

    begin
      init();
      mgr_utl.disable_table_triggers          (l_tab);
      mgr_utl.disable_foreign_keys            (l_tab);
      --
      mgr_utl.sync_table('VP_LIST', 'insert into vp_list(acc3800, acc3801, acc6204, comm, acc_rrd, acc_rrr, acc_rrs, kf)
                                    select rukey(acc3800), rukey(acc3801), rukey(acc6204), comm, rukey(acc_rrd), rukey(acc_rrr), rukey(acc_rrs),  '''||g_kf||''' as kf
                                    from ' ||pkf('vp_list'), false);
      mgr_utl.enable_table_triggers         (l_tab);
      mgr_utl.enable_foreign_keys           (l_tab);

  end fill_vp_list_tmp;

  procedure fill_vp_list
   is
    l_tab                          VARCHAR2(30) DEFAULT 'VP_LIST';
    p                              CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    l_migration_start_time         date default sysdate;
    l_start_time                   timestamp default current_timestamp;
    l_end_time                     timestamp default current_timestamp;
    l_rowcount                     number default 0;
    l_time_duration                interval day(3) to second(3);

  begin
  --trace('%s: entry point', p);
  l_migration_start_time := sysdate;
  l_start_time := current_timestamp;
  --
  bc.go(g_kf);
  --
  mgr_utl.before_fill(l_tab);
  --
  -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
  mgr_utl.mantain_error_table(l_tab);

    begin
        --dbms_lock.sleep(5); --for test
    execute immediate
             'insert into vp_list(acc3800, acc3801, acc6204, comm, acc_rrd, acc_rrr, acc_rrs, kf)
              select rukey(acc3800), rukey(acc3801), rukey(acc6204), comm, rukey(acc_rrd), rukey(acc_rrr), rukey(acc_rrs),  '''||g_kf||''' as kf
              from ' ||pkf('vp_list')||' log errors reject limit unlimited';

    l_rowcount        := l_rowcount + sql%rowcount;
    l_end_time        := current_timestamp;
    l_time_duration   := (l_end_time - l_start_time);

    mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                ,ip_migration_start_time          => l_migration_start_time
                                ,ip_table_name                    => l_tab
                                ,ip_operation                     => p
                                ,ip_row_count                     => l_rowcount
                                ,ip_task_start_time               => l_start_time
                                ,ip_task_end_time                 => l_end_time
                                ,ip_time_duration                 => l_time_duration
                                ,ip_log_message                   => 'Done'
                                 );
    exception when others then
      rollback;
      --mgr_utl.save_error();
    mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                            ,ip_migration_start_time              => l_migration_start_time
                            ,ip_table_name                        => l_tab
                            ,ip_operation                         => p
                            ,ip_row_count                         => l_rowcount
                            ,ip_task_start_time                   => l_start_time
                            ,ip_task_end_time                     => l_end_time
                            ,ip_time_duration                     => l_time_duration
                            ,ip_log_message                       => 'Error'
                            );

    end;
    --
    commit;
    --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_vp_list;

  procedure fill_klf00
    is
  begin
    --
    init();
    --
    bars_policy_adm.disable_policies('KL_F00$LOCAL');
    mgr_utl.sync_table('KL_F00$LOCAL',
                        'insert into bars.kl_f00$local(policy_group, branch, kodf, a017, uuu, zzz, path_o, datf, nom, kf)
                        select ''FILIAL'', '''||'/' ||g_kf||'/'||''' branch,
                               kodf, a017, uuu, zzz, path_o, datf, nom, '''||g_kf||''' as kf
                        from '||pkf('kl_f00$local')||' where (a017, kodf) in (select a017, kodf from kl_f00$global) and branch<>''/''',true);
    --
    bars_policy_adm.enable_policies('KL_F00$LOCAL');
  end fill_klf00;

  procedure fill_sw_nostro_que
    is
  begin
        init();
    --
        mgr_utl.sync_table('sw_nostro_que',
    --
            'insert into sw_nostro_que(ref)
            select rukey(ref)
            from '||pkf('sw_nostro_que'),false);

    --
  end fill_sw_nostro_que;

  procedure fill_sos_track
    is
    l_min_ref number;
    l_max_ref number;
  begin
    init();
    
    select trunc(max(t.ref)/100)
      into l_max_ref
      from bars.sos_track t
     where kf = g_kf;
     
    if l_max_ref is null 
    then
      begin                    
      -- было  -- смотрели на загруженный в ММФО ОПЕР
      -- оставляем этот кусок, работает, если собрать статистику
         execute immediate 'select trunc(nvl(op.ref/100, 1))
                           from (select min(ref) as ref
                                 from bars.oper
                                 where ref > 0
                                 and kf=:g_kf
                                 )op'
                           into l_min_ref using g_kf;
      --
      -- стало -- смотрим на Источник в ОПЕР
        /* execute immediate 'select min(ref) as ref
                                 from '||pkf('OPER')||'
                                 where ref > 0
                                 and PDAT >= to_date(''01.01.2015'', ''DD.MM.YYYY'')' -- литерал --поменять при необходимости
                           into l_min_ref;
      --
         commit;*/
      
        mgr_utl.sync_table('sos_track',

            'insert into sos_track(ref, sos_tracker, old_sos, new_sos, change_time, userid, kf)
            select rukey(ref), sos_tracker, old_sos, new_sos, change_time, ruuser(userid), '''||g_kf||''' as kf
            from '||pkf('sos_track')||' where ref>='||l_min_ref||'
             and CHANGE_TIME < trunc(sysdate, ''Q'')', false);

      --
      end;
    else
      begin        
                    
        mgr_utl.sync_table('sos_track',
      --
            'insert into sos_track(ref, sos_tracker, old_sos, new_sos, change_time, userid, kf)
            select rukey(ref), sos_tracker, old_sos, new_sos, change_time, ruuser(userid), '''||g_kf||''' as kf
            from '||pkf('sos_track')||' where ref > '||l_max_ref, false);

      --
      end;
    end if;        
  end fill_sos_track;

  procedure fill_sos0que
    is
    --l_min_ref number;
  begin
    init();
    --
       mgr_utl.sync_table('sos0que',
    --
            'insert into sos0que(ref, kf)
            select rukey(ref),  '''||g_kf||''' as kf
            from '||pkf('sos0que'),true);
    --
  end fill_sos0que;

  ---
  -- Импорт инф. запросов
  --
  procedure fill_tzapros
   is
   l_tab                   VARCHAR2(30) DEFAULT 'TZAPROS';
   l_min_rec               bars.arc_rrp.rec%TYPE;
   p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab||'_prl';

   begin
    --
    init();
    --
        execute immediate 'select trunc(nvl(a.rec/100, 1))
                              from (select min(rec) as rec
                                    from bars.arc_rrp
                                    where kf=:g_kf
                                    )a'
                              into l_min_rec using g_kf;

        mgr_utl.sync_table('TZAPROS',
                           'insert into bars.tzapros(rec, isp, otm, dat, rec_o, stmp, kf)
                           select rukey(rec) as rec, ruuser(isp), otm, dat, rukey(rec_o) as rec_o, stmp, '''||g_kf||''' as kf
                           from '||pkf('tzapros')||' where rec > '||l_min_rec,true);
  end fill_tzapros;

  procedure fill_cash_open
    is
    begin
      init();
      mgr_utl.sync_table('cash_open',
                         'insert into bars.cash_open(branch, opdate, shift, userid, lastref, kf)
                         select branch, opdate, shift, ruuser(userid) as userid, lastref, kf
                         from '||pkf('cash_open'), false);
  end fill_cash_open;

  procedure fill_cash_refque
  is
  begin
    mgr_utl.sync_table_auto('cash_refque', false,
        'userid, "ruuser(userid)", ref, "rukey(ref)"'
    );
  end fill_cash_refque;

  procedure fill_cash_snapshot
  is
  begin
    init();
      mgr_utl.sync_table('cash_snapshot',
                         'insert into bars.cash_snapshot(branch, opdate, acc, ostf, kf)
                         select '''||'/' ||g_kf||'/'||''' as branch, opdate, rukey(acc) as acc, ostf, ''' || g_kf || ''' as kf
                         from '||pkf('cash_snapshot'), true);
  end fill_cash_snapshot;

  procedure fill_fin_calculations
  is
  begin
    mgr_utl.sync_table_auto('fin_calculations', true,
        'rnk, "rukey(rnk)",nd,"rukey(nd)"'
    );
  end fill_fin_calculations;

  procedure fill_fin_obu_pawn
    is
   begin
    --
    init();
    --
        mgr_utl.sync_table('fin_obu_pawn',
    --
            'insert into bars.fin_obu_pawn(id, nd, rnk, acc, pawn, kv, s_spv, p_zast, datp, kf)
                select S_FIN_OBU_PAWN.nextval, decode(nd,-1,-1,rukey(nd)),
                rukey(rnk), decode(acc, null, null,rukey(acc)), pawn, kv, s_spv, p_zast, datp,  '''||g_kf||''' as kf
                 from '||pkf('fin_obu_pawn'),true);
   end fill_fin_obu_pawn;

  procedure fill_fin_fm
     is
     begin
       init();
       mgr_utl.sync_table('FIN_FM',
       'insert into fin_fm(okpo, fdat, fm, date_f1, date_f2, ved)
        select okpo, fdat, fm, date_f1, date_f2, ved
        from '||pkf('FIN_FM')||' where (okpo, fdat) not in (select okpo, fdat from fin_fm)', false);

  end fill_fin_fm;

  procedure fill_fin_fm_upd(p_schema varchar2 default null,  p_dblink varchar2 default null)
     is
      l_tab         VARCHAR2(30) DEFAULT 'FIN_FM_UPDATE';
      l_max_idupd   bars.FIN_FM_UPDATE.idupd%type;
     begin
       init();
      --      
      l_max_idupd := get_max_idupd(l_tab);
      --
       --mgr_utl.sync_table_auto('FIN_FM_UPDATE',false, 'doneby,"ruuser(doneby)",idupd,"rukey(idupd)"');
       mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( okpo
                         ,fdat
                         ,fm
                         ,date_f1
                         ,date_f2
                         ,chgdate
                         ,chgaction
                         ,doneby
                         ,idupd
                         ,kf
                       )
                        SELECT 
                          okpo
                         ,fdat
                         ,fm
                         ,date_f1
                         ,date_f2
                         ,chgdate
                         ,chgaction
                         ,ruuser(doneby) as doneby
                         ,rukey(idupd) as idupd
                         , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);       --
       bc.home();
       --
       select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.fin_fm_update;
       --
       mgr_utl.reset_sequence('s_fin_fm_update', l_max_idupd);
       --
       mgr_utl.enable_table_triggers(l_tab);
       mgr_utl.enable_foreign_keys(l_tab);
       mgr_utl.p_constraints_enable(l_tab);
  end fill_fin_fm_upd;

  procedure fill_fin_nd
     is
     begin
       init();
       mgr_utl.sync_table_auto('FIN_ND',false, 'nd,"rukey(nd)",rnk,"rukey(rnk)"');
  end fill_fin_nd;

  procedure fill_fin_nd_upd(p_schema varchar2 default null,  p_dblink varchar2 default null)
     is
      l_tab         VARCHAR2(30) DEFAULT 'FIN_ND_UPDATE';
      l_max_idupd   bars.FIN_ND_UPDATE.idupd%type;
     begin
       init();
       --mgr_utl.sync_table_auto('FIN_ND_UPDATE',false, 'nd,"rukey(nd)",rnk,"rukey(rnk)",doneby,"ruuser(doneby)",idupd,"rukey(idupd)"');
       --      
       l_max_idupd := get_max_idupd(l_tab);
       --
       mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( fdat
                         ,idf
                         ,kod
                         ,s
                         ,nd
                         ,chgdate
                         ,chgaction
                         ,doneby
                         ,idupd
                         ,rnk
                         ,kf
                       )
                        SELECT 
                          fdat
                         ,idf
                         ,kod
                         ,s
                         ,rukey(nd) as nd
                         ,chgdate
                         ,chgaction
                         ,ruuser(doneby) as doneby
                         ,rukey(idupd) as idupd
                         ,rukey(rnk) as rnk
                        , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);       
       --
       bc.home();
       --
       select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.fin_nd_update;
       --
       mgr_utl.reset_sequence('s_fin_nd_update', l_max_idupd);
       --
       mgr_utl.enable_table_triggers(l_tab);
       mgr_utl.enable_foreign_keys(l_tab);
       mgr_utl.p_constraints_enable(l_tab);
  end fill_fin_nd_upd;

  procedure fill_fin_rnk
     is
     begin
       init();

       mgr_utl.sync_table('FIN_RNK','insert into fin_rnk(fdat, idf, kod, s, okpo, branch, ss)
                                    select fdat, idf, kod, s, okpo, branch, ss
                                 from '||pkf('FIN_RNK')||' where (okpo, fdat)
                                 not in (select okpo, fdat from fin_fm)', false);
  end fill_fin_rnk;

--********************DPT*****************************--
  procedure  fill_dpt_deposit_all
  is
  begin
    bpa.disable_policies('DPT_DEPOSIT_ALL');
    mgr_utl.sync_table_auto('DPT_DEPOSIT_ALL', false,
                            'deposit_id,"rukey(deposit_id)"');
    bpa.enable_policies('DPT_DEPOSIT_ALL');
  end fill_dpt_deposit_all;

  procedure  fill_dpt_deposit
    is
    wb_exist number;
   begin
    --
    init();
    --
    bpa.disable_policies('DPT_DEPOSIT');
    begin
    execute immediate '   
       select count(wb) from '|| mgr_utl.pkf('DPT_DEPOSIT')||' t 
        where rownum = 1'
         into wb_exist;
    exception when others then
           if sqlcode = -00904 then wb_exist := 0; else raise; end if;
    end;
    if wb_exist = 1 then        
       mgr_utl.sync_table('DPT_DEPOSIT',
                          'INSERT INTO DPT_DEPOSIT
                          SELECT rukey(deposit_id) deposit_id,
                                 vidd,
                                 rukey(acc) acc,
                                 kv,
                                 rukey(rnk) rnk,
                                 dat_begin,
                                 dat_end,
                                 comments,
                                 mfo_p,
                                 nls_p,
                                 LIMIT,
                                 deposit_cod,
                                 name_p,
                                 datz,
                                 okpo_p,
                                 dat_ext_int,
                                 cnt_dubl,
                                 cnt_ext_int,
                                 freq,
                                 nd,
                                 branch,
                                 status,
                                 dpt_d,
                                 rukey(acc_d) acc_d,
                                 mfo_d,
                                 nls_d,
                                 nms_d,
                                 okpo_d,
                                 dat_end_alt,
                                 stop_id,
                                 kf,
                                 ruuser(userid),
                                 case when archdoc_id = -1 then to_number(archdoc_id)
                                      when archdoc_id is null then 0
                                       else to_number(rukey(archdoc_id))
                                         end archdoc_id,
                                 forbid_extension,
                                 wb
                           FROM '|| mgr_utl.pkf('DPT_DEPOSIT'), false);
    else 
       mgr_utl.sync_table('DPT_DEPOSIT',
                          'INSERT INTO DPT_DEPOSIT
                          SELECT rukey(deposit_id) deposit_id,
                                 vidd,
                                 rukey(acc) acc,
                                 kv,
                                 rukey(rnk) rnk,
                                 dat_begin,
                                 dat_end,
                                 comments,
                                 mfo_p,
                                 nls_p,
                                 LIMIT,
                                 deposit_cod,
                                 name_p,
                                 datz,
                                 okpo_p,
                                 dat_ext_int,
                                 cnt_dubl,
                                 cnt_ext_int,
                                 freq,
                                 nd,
                                 branch,
                                 status,
                                 dpt_d,
                                 rukey(acc_d) acc_d,
                                 mfo_d,
                                 nls_d,
                                 nms_d,
                                 okpo_d,
                                 dat_end_alt,
                                 stop_id,
                                 kf,
                                 ruuser(userid),
                                 case when archdoc_id = -1 then to_number(archdoc_id)
                                      when archdoc_id is null then 0
                                       else to_number(rukey(archdoc_id))
                                         end archdoc_id,
                                 forbid_extension,
                                 ''N'' as wb
                           FROM '|| mgr_utl.pkf('DPT_DEPOSIT'), false);
        
    end if;
    bpa.enable_policies('DPT_DEPOSIT');
  end  fill_dpt_deposit;

  procedure  fill_dpt_deposit_clos
    is
    wb_exist number;
   begin
    --
    init();
    --
    bpa.disable_policies('DPT_DEPOSIT_CLOS');
    begin
    execute immediate '   
       select count(wb) from '|| mgr_utl.pkf('DPT_DEPOSIT_CLOS')||' t 
        where rownum = 1'
         into wb_exist;
    exception when others then
           if sqlcode = -00904 then wb_exist := 0; else raise; end if;
    end;
    if wb_exist = 1 then        
        mgr_utl.sync_table('DPT_DEPOSIT_CLOS',
                           'INSERT INTO DPT_DEPOSIT_CLOS
                           SELECT  rukey(deposit_id) deposit_id,
                                   vidd, rukey(acc) acc,
                                   kv,
                                   rukey(rnk) rnk,
                                   dat_begin,
                                   dat_end,
                                   comments,
                                   mfo_p,
                                   nls_p,
                                   LIMIT,
                                   deposit_cod,
                                   name_p,
                                   action_id,
                                   ruuser(actiion_author),
                                   when,
                                   okpo_p,
                                   datz,
                                   freq,
                                   nd,
                                   branch,
                                   dpt_d,
                                   rukey(acc_d) acc_d,
                                   mfo_d,
                                   nls_d,
                                   nms_d,
                                   okpo_d,
                                   rukey(idupd),
                                   bdate,
                                   rukey(ref_dps),
                                   dat_end_alt,
                                   stop_id,
                                   kf,
                                   cnt_dubl,
                                   cnt_ext_int,
                                   dat_ext_int,
                                   ruuser(userid),
                                   case when archdoc_id = -1 then to_number(archdoc_id)
                                        when archdoc_id > 0  then to_number(rukey(archdoc_id))
                                          end archdoc_id,
                                   forbid_extension,
                                   wb
                           FROM '|| mgr_utl.pkf('DPT_DEPOSIT_CLOS'), true);
    else
        mgr_utl.sync_table('DPT_DEPOSIT_CLOS',
                           'INSERT INTO DPT_DEPOSIT_CLOS
                           SELECT  rukey(deposit_id) deposit_id,
                                   vidd, rukey(acc) acc,
                                   kv,
                                   rukey(rnk) rnk,
                                   dat_begin,
                                   dat_end,
                                   comments,
                                   mfo_p,
                                   nls_p,
                                   LIMIT,
                                   deposit_cod,
                                   name_p,
                                   action_id,
                                   ruuser(actiion_author),
                                   when,
                                   okpo_p,
                                   datz,
                                   freq,
                                   nd,
                                   branch,
                                   dpt_d,
                                   rukey(acc_d) acc_d,
                                   mfo_d,
                                   nls_d,
                                   nms_d,
                                   okpo_d,
                                   rukey(idupd),
                                   bdate,
                                   rukey(ref_dps),
                                   dat_end_alt,
                                   stop_id,
                                   kf,
                                   cnt_dubl,
                                   cnt_ext_int,
                                   dat_ext_int,
                                   ruuser(userid),
                                   case when archdoc_id = -1 then to_number(archdoc_id)
                                        when archdoc_id > 0  then to_number(rukey(archdoc_id))
                                          end archdoc_id,
                                   forbid_extension,
                                   ''N'' as wb
                           FROM '|| mgr_utl.pkf('DPT_DEPOSIT_CLOS'), true);
    end if;
     bpa.enable_policies('DPT_DEPOSIT_CLOS');
  end  fill_dpt_deposit_clos;

  procedure  fill_dpt_payments
  is
    l_tab                    VARCHAR2(50) DEFAULT 'DPT_PAYMENTS';
    p                        CONSTANT VARCHAR2(62) := 'mrg_utl.fill_'||l_tab;
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 50000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_min_ref                NUMBER;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

  /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
  */

  TYPE t_dpt_payments_row IS TABLE OF dpt_payments%ROWTYPE;

  v_curs t_dpt_payments_row;
  ---------------------------------------------------------------------------------
        /*local procedure for save error to err$table*/
     PROCEDURE error_logging IS
        /* Associative array type of the exceptions table... */
        TYPE t_cur_exception IS TABLE OF ERR$_DPT_PAYMENTS%ROWTYPE INDEX BY PLS_INTEGER;

        v_cur_exceptions   t_cur_exception;

        v_indx          PLS_INTEGER;

        /* Emulate DML error logging behaviour... */
        PRAGMA AUTONOMOUS_TRANSACTION;
     BEGIN
        FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
           v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

           /* Populate as many values as available... */
           v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
           v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
           v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
           v_cur_exceptions (i).ora_err_optyp$         := 'I';
           v_cur_exceptions (i).dpt_id                 := v_curs (v_indx).dpt_id;
           v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
           v_cur_exceptions (i).kf                     := v_curs (v_indx).kf;
           --v_cur_exceptions (i).effectdate             := v_curs (v_indx).effectdate;
           --v_cur_exceptions (i).acc                    := v_curs (v_indx).acc;
        END LOOP;

        /* Load the exceptions into the exceptions table... */
        FORALL i IN INDICES OF v_cur_exceptions
           INSERT INTO ERR$_DPT_PAYMENTS
                VALUES v_cur_exceptions (i);

        COMMIT;
     END error_logging;

   BEGIN
    trace('%s: entry point', p);
    --переход в импортируемое МФО
    bc.go(g_kf);
    --
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.before_fill(l_tab);
    bpa.disable_policies(l_tab);

    -- переводим индекс в состояние unusable, после заливки сделаем ребилд
    --execute immediate 'ALTER INDEX i1_dptpayments UNUSABLE';

         execute immediate 'select trunc(nvl(op.ref/100, 1))
                           from (select min(ref) as ref
                                 from bars.oper
                                 where ref > 0
                                 and kf=:g_kf
                                 )op'
                           into l_min_ref using g_kf;

   BEGIN
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

      OPEN l_cur FOR
          'select
            rukey(dpt_id)
           ,rukey(ref)
           ,kf
           ,branch
           ,rukey(rnk) as rnk
         from '||pkf('dpt_payments')||' where ref>='||l_min_ref;
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.DPT_PAYMENTS
                                    VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
     -- Clear collection for v_curs
    v_curs.delete;
    END;

    --execute immediate 'ALTER INDEX i1_dptpayments REBUILD';
    bpa.enable_policies(l_tab);
    --
    bc.home();
    --
    mgr_utl.finalize();
    --
    --trace('собираем статистику');

    -- mgr_utl.gather_table_stats (ownname => 'BARS', tabname => l_tab,  cascade=>true);

    trace('%s: finished', p);

  end  fill_dpt_payments;

 procedure  fill_dpt_accounts
  is
  begin
  bpa.disable_policies('DPT_ACCOUNTS');
  mgr_utl.sync_table_auto('DPT_ACCOUNTS', false, 'dptid,"rukey(dptid)",accid,"rukey(accid)"');
  bpa.enable_policies('DPT_ACCOUNTS');
  end fill_dpt_accounts;

  procedure  fill_dpt_deposit_details
  is
  begin
  bpa.disable_policies('DPT_DEPOSIT_DETAILS');
  mgr_utl.sync_table_auto('DPT_DEPOSIT_DETAILS', false, 'dpt_id,"rukey(dpt_id)"');
  bpa.enable_policies('DPT_DEPOSIT_DETAILS');
  end fill_dpt_deposit_details;

  procedure  fill_dpt_bonus_requests
  is
  begin
  bpa.disable_policies('DPT_BONUS_REQUESTS');
  mgr_utl.sync_table_auto('DPT_BONUS_REQUESTS', false, 'dpt_id,"rukey(dpt_id)",req_id,"rukey(req_id)",request_user,"ruuser(request_user)",process_user,"ruuser(process_user)"');
  bpa.enable_policies('DPT_BONUS_REQUESTS');
  end fill_dpt_bonus_requests;

  procedure  fill_dpt_requests
  is
  begin
   bpa.disable_policies('DPT_REQUESTS');
   mgr_utl.sync_table_auto('DPT_REQUESTS', false,
        'req_id,"rukey(req_id)",req_cruserid,"ruuser(req_cruserid)",req_prcuserid,"ruuser(req_prcuserid)",dpt_id,"rukey(dpt_id)"');
   bpa.enable_policies('DPT_REQUESTS');
   end fill_dpt_requests;

  procedure fill_dpt_trustee
    is
    begin
      init();
      bpa.disable_policies('DPT_TRUSTEE');
      mgr_utl.sync_table('DPT_TRUSTEE',
                         'insert into bars.dpt_trustee(id, dpt_id, typ_tr, rnk_tr, rnk, add_num, add_dat, fl_act, undo_id, kf, branch)
                         select rukey(id) as id, rukey(dpt_id) as dpt_id, typ_tr, rukey(rnk_tr) as rnk_tr, rukey(rnk) as rnk, rukey(add_num) as add_num,
                                add_dat, fl_act, rukey(undo_id) as undo_id, kf, branch
                         from '||pkf('dpt_trustee'), false);
      bpa.enable_policies('DPT_TRUSTEE');
  end fill_dpt_trustee;


  procedure  fill_dpt_inheritors
  is
  begin
  bpa.disable_policies('DPT_INHERITORS');
  mgr_utl.sync_table_auto('DPT_INHERITORS', false,
                          'dpt_id,"rukey(dpt_id)",inherit_custid,"rukey(inherit_custid)"');
  bpa.enable_policies('DPT_INHERITORS');
  end  fill_dpt_inheritors;

    procedure fill_dpt_depositw
    is
    begin
      init();
      bpa.disable_policies('DPT_DEPOSITW');
      mgr_utl.sync_table('DPT_DEPOSITW',
                         'insert into bars.DPT_DEPOSITW(dpt_id, tag, value, kf, branch)
                         select rukey(dpt_id) as dpt_id, tag, value, kf, branch
                         from '||pkf('DPT_DEPOSITW'), false);
      bpa.enable_policies('DPT_DEPOSITW');
      end fill_dpt_depositw;

  procedure  fill_dpt_extconsent
  is
  begin
  bpa.disable_policies('DPT_EXTCONSENT');
  mgr_utl.sync_table_auto('DPT_EXTCONSENT', false,
                          'dpt_id,"rukey(dpt_id)"');
  bpa.enable_policies('DPT_EXTCONSENT');
  end fill_dpt_extconsent;

  procedure  fill_dpt_req_chgints
  is
  begin
  bpa.disable_policies('DPT_REQ_CHGINTS');
  mgr_utl.sync_table_auto('DPT_REQ_CHGINTS',false,
                          'req_id,"rukey(req_id)"');
  bpa.enable_policies('DPT_REQ_CHGINTS');
  end fill_dpt_req_chgints;

  procedure  fill_dpt_req_deldeals
  is
  begin
  bpa.disable_policies('DPT_REQ_DELDEALS');
  mgr_utl.sync_table_auto('DPT_REQ_DELDEALS', false,
                          'req_id,"rukey(req_id)",user_id,"ruuser(user_id)"');
  bpa.enable_policies('DPT_REQ_DELDEALS');
   end fill_dpt_req_deldeals;

  procedure  fill_dpt_techaccounts
  is
  begin
   bpa.disable_policies('DPT_TECHACCOUNTS');
   mgr_utl.sync_table_auto('DPT_TECHACCOUNTS', false,
                           'dpt_id,"rukey(dpt_id)",tech_acc,"rukey(tech_acc)",rnk,"rukey(rnk)",dpt_acc,"rukey(dpt_acc)",dpt_idupd,"rukey(dpt_idupd)"');
   bpa.enable_policies('DPT_TECHACCOUNTS');
   end fill_dpt_techaccounts;

  procedure  fill_dpt_immobile
  is
  begin
   bpa.disable_policies('DPT_IMMOBILE');
   mgr_utl.sync_table_auto('DPT_IMMOBILE', false,
                           'dpt_id,"rukey(dpt_id)",transfer_ref,"rukey(transfer_ref)",transfer_author,"ruuser(transfer_author)"');
   bpa.enable_policies('DPT_IMMOBILE');
   end fill_dpt_immobile;

    procedure fill_dpt_agreements
    is
    begin
      init();
      bpa.disable_policies('DPT_AGREEMENTS');
      mgr_utl.sync_table('DPT_AGREEMENTS',
                         'insert into bars.DPT_AGREEMENTS(agrmnt_id, agrmnt_date, agrmnt_num, agrmnt_type, dpt_id, branch, cust_id, bankdate, template_id,
                                                          trustee_id, transfer_bank, transfer_account, amount_cash, amount_cashless, amount_interest,
                                                          date_begin, date_end, denom_amount, denom_count, denom_ref, agrmnt_state, comiss_ref, undo_id,
                                                          transfdpt, transfint, doc_ref, rate_reqid, comiss_reqid, rate_value, rate_date, kf)
                         select rukey(agrmnt_id) as agrmnt_id, agrmnt_date, agrmnt_num, agrmnt_type, rukey(dpt_id) as dpt_id, branch, rukey(cust_id) as cust_id,
                                bankdate, template_id, rukey(trustee_id) as trustee_id,
                                transfer_bank, transfer_account, amount_cash, amount_cashless, amount_interest, date_begin, date_end, denom_amount,
                                denom_count, rukey(denom_ref) as denom_ref, agrmnt_state, rukey(comiss_ref) as comiss_ref, rukey(undo_id)as undo_id,
                                transfdpt, transfint, rukey(doc_ref) as doc_ref, rukey(rate_reqid) as rate_reqid, rukey(comiss_reqid) as comiss_reqid,
                                rate_value, rate_date, kf
                         from '||pkf('DPT_AGREEMENTS'), false);
      bpa.enable_policies('DPT_AGREEMENTS');
      end fill_dpt_agreements;

  procedure  fill_dpt_agrw
  is
  begin
  bpa.disable_policies('DPT_AGRW');
  mgr_utl.sync_table_auto('DPT_AGRW', false, 'agreement_id,"rukey(agreement_id)"');
  bpa.enable_policies('DPT_AGRW');
  end fill_dpt_agrw;

  procedure  fill_ead_docs
  is
    l_tab         VARCHAR2(30) DEFAULT 'EAD_DOCS';
    l_max_id   bars.EAD_DOCS.id%type;
  begin
   execute immediate 'alter table '||l_tab||' disable constraint СС_EADDOCS_TYPEID';
   bpa.disable_policies(l_tab);
   --
   select trunc(nvl(max(id / 100), 0)) + 1 
     into l_max_id 
     from bars.EAD_DOCS
    where kf = G_KF ;

   --
   mgr_utl.sync_table(p_table => l_tab,
                      p_stmt => 
                      'Insert --+ append
                         into '||l_tab||'
                             (id, 
                              crt_date, 
                              crt_staff_id, 
                              crt_branch, 
                              type_id, 
                              template_id, 
                              scan_data, 
                              ea_struct_id, 
                              sign_date, 
                              rnk, 
                              agr_id, 
                              page_count, 
                              kf
                             )
                       select 
                              rukey(id) as id, 
                              crt_date, 
                              ruuser(crt_staff_id) as crt_staff_id, 
                              crt_branch, 
                              type_id, 
                              template_id, 
                              scan_data, 
                              ea_struct_id, 
                              sign_date, 
                              rukey(rnk) as rnk, 
                              rukey(agr_id) as agr_id, 
                              page_count, 
                              '''||G_KF||'''
                         from '||PKF(l_tab)||'
                        where id >= '||l_max_id
                      ,p_delete => false
                     );                             
    bpa.disable_policies('EAD_DOCS');
   execute immediate 'alter table EAD_DOCS modify constraint СС_EADDOCS_TYPEID enable novalidate';
   bpa.enable_policies(l_tab);
  end fill_ead_docs;
   
  procedure  fill_acc_balance_changes
  is
  begin
   bpa.disable_policies('ACC_BALANCE_CHANGES');
   mgr_utl.sync_table_auto('ACC_BALANCE_CHANGES', false,
                           'id,"rukey(id)",rnk,"rukey(rnk)",ref,"rukey(ref)",acc,"rukey(acc)"');
   bpa.enable_policies('ACC_BALANCE_CHANGES');
   end fill_acc_balance_changes;

  procedure fill_acc_balance_chng_upd
   is
    l_tab         VARCHAR2(30) DEFAULT 'ACC_BALANCE_CHANGES_UPDATE';
    l_max_idupd   number(30);

    begin
    init();
    bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --
    mgr_utl.sync_table('ACC_BALANCE_CHANGES_UPDATE',
                        'INSERT INTO ACC_BALANCE_CHANGES_UPDATE
                        SELECT rukey(id) as id, change_time, rukey(rnk) as rnk, rukey(acc) as acc, ostc, dos_delta, kos_delta,
                               rukey(ref) as ref, tt, nlsb, nlsa, '''||g_kf||''' as kf
                        FROM '||pkf('ACC_BALANCE_CHANGES_UPDATE'),
                        false);
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    bpa.enable_policies(l_tab);
    --
  end fill_acc_balance_chng_upd;

  procedure  fill_dpt_soc_turns
  is
  begin
   bpa.disable_policies('DPT_SOC_TURNS');
   mgr_utl.sync_table_auto('DPT_SOC_TURNS', false,
                           'acc,"rukey(acc)"');
   bpa.enable_policies('DPT_SOC_TURNS');
   end fill_dpt_soc_turns;

    procedure fill_dpt_jobs_jrnl(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
       l_max_run_id DPT_JOBS_JRNL.RUN_ID%type;
    begin
      init();
      bpa.disable_policies('DPT_JOBS_JRNL');
      mgr_utl.sync_table('DPT_JOBS_JRNL',
                         'insert into bars.DPT_JOBS_JRNL(run_id, job_id, start_date, finish_date, bank_date, user_id, status, errmsg, branch, deleted, kf)
                         select rukey(run_id) as run_id, job_id, start_date, finish_date, bank_date, ruuser(user_id) as user_id, status, errmsg, branch, deleted, kf
                         from '||pkf('DPT_JOBS_JRNL', p_schema, p_dblink), false);
      bpa.enable_policies('DPT_JOBS_JRNL');
        
        select trunc(nvl(max(run_id / 100), 0)) + 1
          into l_max_run_id
          from dpt_jobs_jrnl;

      mgr_utl.reset_sequence('s_dpt_jobs_jrnl', l_max_run_id);--забрали в процедуру миграции
    end fill_dpt_jobs_jrnl;

  procedure  fill_dpt_jobs_log(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab                    VARCHAR2(50) DEFAULT 'DPT_JOBS_LOG';
    p                        CONSTANT VARCHAR2(62) := 'mrg_oschad.fill_'||l_tab;
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 50000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_max_run_id             NUMBER;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);
    l_max_rec_id             DPT_JOBS_LOG.REC_ID%type;

   /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

  /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
  */

  TYPE t_dpt_jobs_log_row IS TABLE OF dpt_jobs_log%ROWTYPE;

  v_curs t_dpt_jobs_log_row;
  ---------------------------------------------------------------------------------
        /*local procedure for save error to err$table*/
     PROCEDURE error_logging IS
        /* Associative array type of the exceptions table... */
        TYPE t_cur_exception IS TABLE OF ERR$_DPT_JOBS_LOG%ROWTYPE INDEX BY PLS_INTEGER;

        v_cur_exceptions   t_cur_exception;

        v_indx          PLS_INTEGER;

        /* Emulate DML error logging behaviour... */
        PRAGMA AUTONOMOUS_TRANSACTION;
     BEGIN
        FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
           v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

           /* Populate as many values as available... */
           v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
           v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
           v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
           v_cur_exceptions (i).ora_err_optyp$         := 'I';
           v_cur_exceptions (i).rec_id                 := v_curs (v_indx).rec_id;
           v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
           v_cur_exceptions (i).kf                     := v_curs (v_indx).kf;
           v_cur_exceptions (i).rate_dat               := v_curs (v_indx).rate_dat;
           --v_cur_exceptions (i).acc                    := v_curs (v_indx).acc;
        END LOOP;

        /* Load the exceptions into the exceptions table... */
        FORALL i IN INDICES OF v_cur_exceptions
           INSERT INTO ERR$_DPT_JOBS_LOG
                VALUES v_cur_exceptions (i);

        COMMIT;
     END error_logging;

   BEGIN
    trace('%s: entry point', p);
    --переход в импортируемое МФО
    bc.go(g_kf);
    --
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.before_fill(l_tab);
    bpa.disable_policies(l_tab);
    -- переводим индекс в состояние unusable, после заливки сделаем ребилд
    --execute immediate 'ALTER INDEX idx_dptjobslog_dptid UNUSABLE';
    --execute immediate 'ALTER INDEX idx_dptjobslog_runid UNUSABLE';

   BEGIN
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;
    --
    bc.home();
    select nvl(max(rec_id), 0) + 1 into l_max_rec_id from dpt_jobs_log;
    --
    mgr_utl.reset_sequence('s_dpt_jobs_log', l_max_rec_id);
    --
    bc.go(g_kf);

      OPEN l_cur FOR
          'select s_dpt_jobs_log.nextval as rec_id,
                  rukey(dl.run_id) as run_id,
                  dl.job_id,
                  rukey(dl.dpt_id) as dpt_id,
                  dl.branch,
                  rukey(dl.ref) as ref,
                  rukey(dl.rnk) as rnk,
                  dl.kv,
                  dl.dpt_sum,
                  dl.int_sum,
                  dl.status,
                  dl.errmsg,
                  dl.nls,
                  dl.contract_id,
                  dl.deal_num,
                  dl.rate_val,
                  dl.rate_dat,
                  dl.kf
          from '|| pkf('dpt_jobs_log', p_schema, p_dblink) || ' dl, '||  pkf('dpt_jobs_jrnl', p_schema, p_dblink) || ' dj where dj.run_id = dl.run_id and to_char(dj.bank_date, ''yyyy'') = to_char(bankdate, ''yyyy'')';
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.DPT_JOBS_LOG
                                    VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
       l_end_time := current_timestamp;
       l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
     -- Clear collection for v_curs
    v_curs.delete;
    END;

    --execute immediate 'ALTER INDEX idx_dptjobslog_dptid REBUILD';
    --execute immediate 'ALTER INDEX idx_dptjobslog_runid REBUILD';

    bpa.enable_policies(l_tab);
    --
    bc.home();
    --
    mgr_utl.finalize();
    --trace('собираем статистику');

    --mgr_utl.gather_table_stats (ownname => 'BARS', tabname => l_tab,  cascade=>true);
    trace('%s: finished', p);

  end fill_dpt_jobs_log;

  procedure fill_cust_req_access
  is
    begin
     bpa.disable_policies('CUST_REQ_ACCESS');
     mgr_utl.sync_table_auto('CUST_REQ_ACCESS', false, 'req_id,"rukey(req_id)",CONTRACT_ID,"rukey(CONTRACT_ID)"');
     bpa.enable_policies('CUST_REQ_ACCESS');
  end fill_cust_req_access;

  procedure fill_cust_requests
  is
    begin
    bpa.disable_policies('CUST_REQUESTS');
    mgr_utl.sync_table_auto('CUST_REQUESTS', false, 'req_id,"rukey(req_id)"');
    bpa.enable_policies('CUST_REQUESTS');
  end fill_cust_requests;

  procedure fill_person_val_doc_upd
    is
    l_tab         VARCHAR2(30) DEFAULT 'PERSON_VALID_DOCUMENT_UPDATE';
    l_max_idupd   bars.nlk_ref_update.idupd%type;

    begin
    init();
    --bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --
    mgr_utl.sync_table('PERSON_VALID_DOCUMENT_UPDATE',
                       'INSERT INTO PERSON_VALID_DOCUMENT_UPDATE
                        SELECT rukey(rnk) as rnk, chgdate, doc_state, ruuser(userid) as userid, '''||g_kf||''' as kf
                        FROM '
                        ||pkf('PERSON_VALID_DOCUMENT_UPDATE'),
                         true);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    --bpa.enable_policies(l_tab);
    --
  end fill_person_val_doc_upd;

  procedure fill_person_valid_document
  is
   begin
    mgr_utl.sync_table_auto('person_valid_document', false,  'rnk,"rukey(rnk)"');
  end fill_person_valid_document;

  procedure  dpt_reset_sqnc
  is
      l_max_deposit_id     dpt_deposit_all.deposit_id%type;
      l_max_idupd          dpt_deposit_clos.idupd%type ;
      l_max_req_id         dpt_requests.req_id%type;
      l_max_tid            dpt_trustee.id%type;
      l_max_agrmnt_id      dpt_agreements.agrmnt_id%type;
      l_max_did            ead_docs.id%type;
      l_max_sid            ead_sync_queue.id%type;
      l_max_run_id         dpt_jobs_jrnl.run_id%type;
      l_max_rec_id         dpt_jobs_log.rec_id%type;
      l_max_creq_id        cust_requests.req_id%type;
      l_max_id             dpt_stop.id%type;

    begin
    bpa.disable_policies('DPT_DEPOSIT_ALL');
    bpa.disable_policies('DPT_DEPOSIT_CLOS');
    bpa.disable_policies('DPT_REQUESTS');
    bpa.disable_policies('DPT_TRUSTEE');
    bpa.disable_policies('DPT_AGREEMENTS');
    bpa.disable_policies('EAD_DOCS');
    bpa.disable_policies('DPT_JOBS_JRNL');
    bpa.disable_policies('DPT_JOBS_LOG');
    bpa.disable_policies('CUST_REQUESTS');

    bc.home();
        --
    select trunc(nvl(max(deposit_id / 100), 0)) + 1
          into l_max_deposit_id
          from dpt_deposit_all;

    select trunc(nvl(max(idupd / 100), 0)) + 1
          into l_max_idupd
          from dpt_deposit_clos;

    select trunc(nvl(max(req_id / 100), 0)) + 1
          into l_max_req_id
          from dpt_requests;

    select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_tid
          from dpt_trustee;

    select trunc(nvl(max(agrmnt_id / 100), 0)) + 1
          into l_max_agrmnt_id
          from dpt_agreements;

    select substr(trunc(nvl(max(id / 100), 0)),3) + 1
          into l_max_did
          from ead_docs;

    select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_sid
          from ead_sync_queue;

    /*select trunc(nvl(max(run_id / 100), 0)) + 1
          into l_max_run_id
          from dpt_jobs_jrnl;

    select trunc(nvl(max(rec_id / 100), 0)) + 1
          into l_max_rec_id
          from dpt_jobs_log;*/

    select trunc(nvl(max(req_id / 100), 0)) + 1
          into l_max_creq_id
          from cust_requests;

    select trunc(nvl(max(id), 0)) + 1
          into l_max_id
          from dpt_stop;

      --
      bc.go(g_kf);
      --
      mgr_utl.reset_sequence('s_cc_deal', l_max_deposit_id);
      mgr_utl.reset_sequence('s_dpt_deposit_clos', l_max_idupd);
      mgr_utl.reset_sequence('s_dptreqs', l_max_req_id);
      mgr_utl.reset_sequence('s_dpt_trustee', l_max_tid);
      mgr_utl.reset_sequence('s_dpt_agreements', l_max_agrmnt_id);
      mgr_utl.reset_sequence('s_eaddocs', l_max_did);
      mgr_utl.reset_sequence('s_eadsyncqueue', l_max_sid);
      --mgr_utl.reset_sequence('s_dpt_jobs_jrnl', l_max_run_id);--забрали в процедуру миграции
      --mgr_utl.reset_sequence('s_dpt_jobs_log', l_max_rec_id);--забрали в процедуру миграции
      mgr_utl.reset_sequence('s_cust_requests', l_max_creq_id);
      mgr_utl.reset_sequence('s_dpt_stop_id', l_max_id);
      --
  bpa.enable_policies('DPT_DEPOSIT_ALL');
  bpa.enable_policies('DPT_DEPOSIT_CLOS');
  bpa.enable_policies('DPT_REQUESTS');
  bpa.enable_policies('DPT_TRUSTEE');
  bpa.enable_policies('DPT_AGREEMENTS');
  bpa.enable_policies('EAD_DOCS');
  bpa.enable_policies('DPT_JOBS_JRNL');
  bpa.enable_policies('DPT_JOBS_LOG');
  bpa.enable_policies('CUST_REQUESTS');

  end dpt_reset_sqnc;
  --********************end DPT*****************************--

  procedure  fill_dpu_deal
  is
  begin
   /*mgr_utl.sync_table_auto('DPU_DEAL', false,
                           'DPU_ID,"rukey(DPU_ID)",DPU_GEN,"rukey(DPU_GEN)",TRUSTEE_ID,"rukey(TRUSTEE_ID)"');*/
   mgr_utl.sync_table_auto('DPU_DEAL', false,
                           'DPU_ID,"rukey(DPU_ID)",DPU_GEN,"rukey(DPU_GEN)",RNK,"rukey(RNK)",ACC,"rukey(ACC)",USER_ID,"ruuser(USER_ID)",TRUSTEE_ID,"rukey(TRUSTEE_ID)"');
  end fill_dpu_deal;

  procedure  fill_dpu_deal_upd
  is
    l_tab         VARCHAR2(30) DEFAULT 'DPU_DEAL_UPDATE';
    l_max_idu     number(30);
  begin
    init();
     
         mgr_utl.sync_table( l_tab
                            ,'insert into '||l_tab||'(idu, useru, dateu, typeu, dpu_id, 
                                                      nd, vidd, rnk, acc, user_id, freqv, 
                                                      sum, dat_begin, dat_end, datz, 
                                                      datv, mfo_d, nls_d, nms_d, mfo_p, 
                                                      nls_p, nms_p, comments, closed, 
                                                      comproc, dpu_gen, dpu_add, min_sum, 
                                                      id_stop, branch, trustee_id, 
                                                      acc2, kf, bdate, cnt_dubl, 
                                                      okpo_p, effectdate
                                                     )
                                              select  rukey(IDU) as idu, 
                                                      ruuser(USERU) as useru, 
                                                      dateu, 
                                                      typeu, 
                                                      ruuser(DPU_ID) as dpu_id, 
                                                      nd, 
                                                      vidd, 
                                                      rukey(rnk) as rnk, 
                                                      rukey(acc) as acc, 
                                                      ruuser(user_id) as userid, 
                                                      freqv, 
                                                      sum, 
                                                      dat_begin, 
                                                      dat_end, 
                                                      datz, 
                                                      datv, 
                                                      mfo_d, 
                                                      nls_d, 
                                                      nms_d, 
                                                      mfo_p, 
                                                      nls_p, 
                                                      nms_p, 
                                                      comments, 
                                                      closed, 
                                                      comproc, 
                                                      rukey(DPU_GEN) as dpu_gen, 
                                                      dpu_add, 
                                                      min_sum, 
                                                      id_stop, 
                                                      branch, 
                                                      rukey(TRUSTEE_ID) as trustee_id, 
                                                      acc2, 
                                                      '''||g_kf||''' as kf, 
                                                      bdate, 
                                                      cnt_dubl, 
                                                      okpo_p, 
                                                      effectdate
                                                 from '||pkf(l_tab)  ,false);
         --
        bc.home;
       --mgr_utl.p_constraints_enable(l_tab);
        --
        select nvl(max(idu), 0)+ 1 into l_max_idu from BARS.DPU_DEAL_UPDATE;

        mgr_utl.reset_sequence('s_dpu_deal_update', l_max_idu); 
        --
                           
  end fill_dpu_deal_upd;

  procedure fill_dpu_jobs_jrnl(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
       l_max_run_id DPU_JOBS_JRNL.RUN_ID%type;
    begin
      init();
    mgr_utl.sync_table('DPU_JOBS_JRNL',
                       'insert into bars.DPU_JOBS_JRNL(run_id, job_id, start_date, finish_date, bank_date, user_id, status, errmsg, branch, kf)
                       select rukey(RUN_ID) as run_id, job_id, start_date, finish_date, bank_date, ruuser(user_id) as user_id, status, errmsg, branch, kf
                       from '||pkf('DPU_JOBS_JRNL', p_schema, p_dblink), false);

        select trunc(nvl(max(run_id / 100), 0)) + 1
          into l_max_run_id
          from dpu_jobs_jrnl;
          
     mgr_utl.reset_sequence('s_dpu_jobs_jrnl',       l_max_run_id);--забрали в процедуру миграции
  end fill_dpu_jobs_jrnl;
  
  procedure  fill_dpu_jobs_log
  is
  begin
   bc.go(g_kf);
   mgr_utl.sync_table_auto('DPU_JOBS_LOG', false,
                           'RUN_ID,"rukey(RUN_ID)",REC_ID,"S_DPU_JOBS_LOG.NextVal",DPT_ID,"rukey(DPT_ID)",REF,"rukey(REF)"');
  end fill_dpu_jobs_log;

  procedure  sync_dpu_jobs_log(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
  l_tab  varchar2(30) default 'DPU_JOBS_LOG';
  l_max_rec_id             DPU_JOBS_LOG.REC_ID%type;
  begin
      bars_policy_adm.disable_policies('dpu_jobs_log');

      mgr_utl.before_clean('dpu_jobs_log');
    --
    bc.home();
    select nvl(max(rec_id), 0) + 1 into l_max_rec_id from dpu_jobs_log;
    --
    mgr_utl.reset_sequence('s_dpu_jobs_log', l_max_rec_id);
    --
    bc.go(g_kf);

      execute_statement(
      'delete dpu_jobs_log
       where kf = ''' || g_kf || '''',
       'Очистка логів роботи dpt_jobs для МФО ' || g_kf ||' таблиця '||l_tab, null, 'N');

      execute_statement(
      'insert into dpu_jobs_log
              (rec_id, run_id, job_id, dpt_id, branch, ref, rnk, kv, dpt_sum, int_sum,
               status, errmsg, nls, deal_num, rate_val, rate_dat, kf)
       select s_dpu_jobs_log.nextval as rec_id, rukey(run_id) as run_id, job_id, rukey(dpt_id) as dpt_id, branch, rukey(ref) as ref, rukey(rnk) as rnk, kv, dpt_sum, int_sum,
              status, errmsg, nls, deal_num, rate_val, rate_dat, kf
       from ' || pkf('dpu_jobs_log', p_schema, p_dblink),
       'Завантаження логів роботи dpt_jobs для МФО ' || g_kf ||' таблиця '||l_tab);

      mgr_utl.finalize();
      bars_policy_adm.enable_policies('dpu_jobs_log');
  end;
  
  procedure  fill_dpu_deal_swtags
  is
  begin
   mgr_utl.sync_table_auto('DPU_DEAL_SWTAGS', false,
                           'DPU_ID,"rukey(DPU_ID)"');
  end fill_dpu_deal_swtags;

  procedure  fill_dpu_dealw
  is
  begin
   mgr_utl.sync_table_auto('DPU_DEALW', false,
                           'DPU_ID,"rukey(DPU_ID)"');
  end fill_dpu_dealw;


  procedure  fill_dpu_dealw_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
    l_tab         VARCHAR2(30) DEFAULT 'DPU_DEALW_UPDATE';
    l_max_idupd   bars.DPU_DEALW_UPDATE.idupd%type;
  begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
--   mgr_utl.sync_table_auto('DPU_DEALW_UPDATE', false,
--                           'DPU_ID,"rukey(DPU_ID)",DONEBY,"rukey(DONEBY)",IDUPD,"rukey(IDUPD)"');
    mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                        , chgaction
                        , chgdate
                        , bdate
                        , doneby
                        , dpu_id
                        , tag
                        , value
                        , kf
                       )
                        SELECT 
                          rukey(IDUPD) as idupd
                        , chgaction
                        , chgdate
                        , bdate
                        , rukey(DONEBY) as doneby
                        , rukey(DPU_ID) as dpu_id
                        , tag
                        , value
                        , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home();
    --    
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.DPU_DEALW_UPDATE;
    --
    mgr_utl.reset_sequence('S_DPU_DEALW_UPDATE', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
  end fill_dpu_dealw_update;

  procedure  fill_dpu_agreements
  is
  begin
   mgr_utl.sync_table_auto('DPU_AGREEMENTS', false,
                           'DPU_ID,"rukey(DPU_ID)",AGRMNT_ID,"rukey(AGRMNT_ID)",UNDO_ID,"rukey(UNDO_ID)"');
  end fill_dpu_agreements;

  procedure  fill_dpu_payments
  is
  begin
   mgr_utl.sync_table_auto('DPU_PAYMENTS', false,
                           'DPU_ID,"rukey(DPU_ID)",REF,"rukey(REF)"');
  end fill_dpu_payments;

  procedure  fill_dpu_accounts
  is
  begin
   mgr_utl.sync_table_auto('DPU_ACCOUNTS', false,
                           'DPUID,"rukey(DPUID)",ACCID,"rukey(ACCID)"');
  end fill_dpu_accounts;

  procedure  dpu_reset_sqnc
  is
      l_max_idu          dpu_deal_update.idu%type;
      l_max_run_id       dpu_jobs_jrnl.run_id%type;
      l_max_rec_id       dpu_jobs_log.rec_id%type;
      l_max_idupd        dpu_dealw_update.idupd%type;
      l_max_agrmnt_id    dpu_agreements.agrmnt_id%type;
      l_max_vidd         dpu_vidd.vidd%type;
      l_max_vr_id        dpu_vidd_rate.id%type;
      l_max_at_id        dpu_agreement_types.id%type;

   begin

   -- подстраиваем последовательность
        bc.home();
        --
        select trunc(nvl(max(idu / 100), 0)) + 1
          into l_max_idu
          from dpu_deal_update;

        /*select trunc(nvl(max(run_id / 100), 0)) + 1
          into l_max_run_id
          from dpu_jobs_jrnl;

        select trunc(nvl(max(rec_id / 100), 0)) + 1
          into l_max_rec_id
          from dpu_jobs_log;*/

        select trunc(nvl(max(idupd / 100), 0)) + 1
          into l_max_idupd
          from dpu_dealw_update;

        select trunc(nvl(max(agrmnt_id / 100), 0)) + 1
          into l_max_agrmnt_id
          from dpu_agreements;

        select trunc(nvl(max(vidd), 0)) + 1
          into l_max_vidd
          from dpu_vidd;

        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_vr_id
          from dpu_vidd_rate;

        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_at_id
          from dpu_agreement_types;

        --
        bc.go(g_kf);
        --
      mgr_utl.reset_sequence('s_dpu_deal_update',     l_max_idu);
      --mgr_utl.reset_sequence('s_dpu_jobs_jrnl',       l_max_run_id);--забрали в процедуру миграции
      --mgr_utl.reset_sequence('s_dpu_jobs_log',        l_max_rec_id);--забрали в процедуру миграции
      mgr_utl.reset_sequence('s_dpu_dealw_update',    l_max_idupd);
      mgr_utl.reset_sequence('s_dpu_agreements',      l_max_agrmnt_id);
      mgr_utl.reset_sequence('s_dpu_vidd',            l_max_vidd);
      mgr_utl.reset_sequence('s_dpu_vidd_rate',       l_max_vr_id);
      mgr_utl.reset_sequence('s_dpu_agreement_types', l_max_at_id);
        --
  end dpu_reset_sqnc;

  procedure fill_sto_grp
    is
    begin
      init();
      mgr_utl.sync_table('STO_GRP',
                         'INSERT INTO STO_GRP (IDG, NAME)
                         SELECT idg, name
                         FROM ' ||pkf('STO_GRP') || ' WHERE (idg) NOT IN (SELECT idg FROM sto_grp)', false);

  end fill_sto_grp;

  procedure fill_sto_lst
  is
    begin
     init();
     mgr_utl.sync_table('STO_LST',
                        'INSERT INTO STO_LST (ids, rnk, name, sdat, idg, kf, branch)
                        SELECT rukey(ids), rukey(rnk), name, sdat, idg, kf, branch
                        FROM ' ||pkf('STO_LST'), true);
  end fill_sto_lst;

  procedure fill_sto_det
   is
   l_tab varchar2(50) default 'STO_DET';
     begin
      init();
          mgr_utl.disable_table_triggers(l_tab);
          mgr_utl.disable_foreign_keys(l_tab);
          mgr_utl.sync_table('STO_DET',
                             'INSERT INTO STO_DET
                             SELECT rukey(ids), vob, dk, tt, nlsa, kva, nlsb, kvb, mfob, polu, nazn, fsum, okpo, dat1, dat2,
                                     freq, dat0, wend, stmp, rukey(idd), ord, kf, dr, branch, ruUSER(userid_made), branch_made,
                                     datetimestamp, branch_card,  ruUSER(userid), null as status_id, null as disclaim_id, null as status_date, null as status_uid
                              FROM ' ||pkf('STO_DET'), true);
          mgr_utl.enable_table_triggers(l_tab);
          mgr_utl.enable_foreign_keys(l_tab);

  end fill_sto_det;



  procedure fill_sto_det_agr
   is
    begin
     bpa.disable_policies('STO_DET_AGR');
     mgr_utl.sync_table_auto('STO_DET_AGR',false,'IDD,"rukey(IDD)",AGR_ID,"rukey(AGR_ID)"');
     bpa.enable_policies('STO_DET_AGR');
  end fill_sto_det_agr;

  procedure fill_sto_operw
   is
    begin
     mgr_utl.sync_table_auto('STO_OPERW',TRUE,'IDD,"rukey(IDD)",VALUE,"rukey(VALUE)"');
  end fill_sto_operw;

  procedure fill_sto_dat
   is
    begin
      init();
      mgr_utl.sync_table('STO_DAT', 'INSERT INTO STO_DAT
                         SELECT rukey(idd), dat, rukey(ref), kf
                         FROM '||pkf('STO_DAT'), true);
  end fill_sto_dat;

  procedure fill_sto_det_upd(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab         VARCHAR2(30) DEFAULT 'STO_DET_UPDATE';
    l_max_idupd   bars.STO_DET_UPDATE.idupd%type;
    begin
      init();
      mgr_utl.disable_table_triggers(l_tab);
      mgr_utl.disable_foreign_keys(l_tab);
      --      
      l_max_idupd := get_max_idupd(l_tab);
      --
      mgr_utl.sync_table(l_tab,
                         'INSERT INTO '||l_tab||'
                         SELECT rukey(ids), vob, dk, tt, nlsa, kva, nlsb, kvb, mfob, polu, nazn, fsum, okpo,
                                dat1, dat2, freq, dat0, wend, stmp, rukey(idd), ord, kf, dr, branch, action,
                                rukey(idupd), when, ruuser(userid), ruuser(userid_made), branch_made,
                                datetimestamp, branch_card, null as status_id, null as disclaim_id, null as status_date, null as status_uid
                         FROM ' ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, false);
    --
    bc.home();
    --    
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.STO_DET_UPDATE;
    --
    mgr_utl.reset_sequence('S_STO_DET_UPDATE', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
  end fill_sto_det_upd;


  procedure fill_sto_dat_upd(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'STO_DAT_UPDATE';
    l_max_idupd   bars.STO_DAT_UPDATE.idupd%type;
    begin
      init();
      --      
      l_max_idupd := get_max_idupd(l_tab);
      --
      mgr_utl.sync_table(l_tab,
                         'INSERT INTO '||l_tab||'
                         SELECT rukey(idd), dat, rukey(ref), kf, action,
                                rukey(idupd), when, ruuser(userid)
                         FROM ' || pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home();
    --    
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.STO_DAT_UPDATE;
    --
    mgr_utl.reset_sequence('S_STO_DAT_UPDATE', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
  end fill_sto_dat_upd;

  procedure fill_zayavka
   is
      begin
        --execute immediate 'alter table ZAYAVKA disable constraint CC_ZAYAVKA_P122C';
        mgr_utl.sync_table_auto('ZAYAVKA',
                                false,
                                'RNK,"rukey(RNK)",ACC0,"rukey(ACC0)",ACC1,"rukey(ACC1)",RNK_PF,"rukey(RNK_PF)",REF,"rukey(REF)",ID,"rukey(ID)",IDENTKB,"rukey(IDENTKB)",REF_SPS,"rukey(REF_SPS)",REF_PF,"rukey(REF_PF)",REFOPER,"rukey(REFOPER)"');
        --execute immediate 'alter table ZAYAVKA enable constraint CC_ZAYAVKA_P122C';
  end fill_zayavka;

  procedure fill_zayavka_ru
   is
        begin
          init();
          bpa.disable_policies('ZAYAVKA_RU');
          mgr_utl.sync_table('ZAYAVKA_RU',
                             'insert into bars.zayavka_ru
                             select z.id||k.ru, z.mfo, decode(z.req_id, null, null, z.req_id||k.ru), z.dk, z.obz, z.nd, z.fdat, z.datt, z.rnk||k.ru, z.nmk, decode(z.nd_rnk, null, null, z.nd_rnk||k.ru),
                                    z.kv_conv, z.lcv_conv, z.kv2, z.lcv, z.dig, z.s2, z.s2s, z.s3, z.kom, z.skom, z.kurs_z, z.kurs_f, z.vdate, z.datz, decode(z.acc0, null, null, z.acc0||k.ru), z.nls_acc0,
                                    z.mfo0, z.nls0, z.okpo0, z.ostc0, decode(z.acc1, null, null, z.acc1||k.ru), z.ostc, z.nls, z.sos, decode(z.ref, null, null, z.ref||k.ru), z.viza, z.priority, z.priorname,
                                    z.priorverify, z.idback, z.fl_pf, z.mfop, z.nlsp, z.okpop, decode(z.rnk_pf, null, null, z.rnk_pf||k.ru), z.pid, z.contract, z.dat2_vmd, z.meta, z.aim_name, z.basis,
                                    z.product_group, z.product_group_name, z.num_vmd, z.dat_vmd, z.dat5_vmd, z.country, z.benefcountry, z.bank_code, z.bank_name, decode(z.userid, null, null, z.userid||k.ru),
                                    z.branch, z.fl_kursz, decode(z.identkb, null, null, z.identkb||k.ru), z.comm, z.cust_branch, z.kurs_kl, z.contact_fio, z.contact_tel, z.verify_opt, z.close_type,
                                    z.close_type_name, z.aims_code, z.s_pf, decode(z.ref_pf, null, null, z.ref_pf||k.ru), decode(z.ref_sps, null, null, z.ref_sps||k.ru), z.start_time, z.state, z.operid_nokk,
                                    z.req_type, decode(z.ref_sps_check, null, null, z.ref_sps_check||k.ru), z.vdate_plan, z.custtype, z.reason_comm
                             from '||pkf('zayavka_ru')||' z, bars.kf_ru k where z.mfo = k.kf',
                             false);
          bpa.enable_policies('ZAYAVKA_RU');
  end fill_zayavka_ru;

  procedure fill_zay_baop
  is
    begin
    mgr_utl.sync_table_auto('ZAY_BAOP',
                            false,
                            'ID,"rukey(ID)",IDENTKB,"rukey(IDENTKB)"');
  end fill_zay_baop;

  procedure fill_zay_currency_income
  is
    begin
    bpa.disable_policies('ZAY_CURRENCY_INCOME');
    mgr_utl.sync_table_auto('ZAY_CURRENCY_INCOME',
                            false,
                            'REF,"rukey(REF)",RNK,"rukey(RNK)"');
    bpa.enable_policies('ZAY_CURRENCY_INCOME');
  end fill_zay_currency_income;


  procedure fill_zay_comiss
  is
    begin
    mgr_utl.sync_table_auto('ZAY_COMISS',
                            false,
                            'ID,"rukey(ID)",RNK,"rukey(RNK)"');
  end fill_zay_comiss;

  procedure fill_zay_currency_income_ru
  is
    begin
    bpa.disable_policies('ZAY_CURRENCY_INCOME_RU');
    mgr_utl.sync_table('ZAY_CURRENCY_INCOME_RU',
                       'insert into bars.zay_currency_income_ru
                       select z.mfo, z.branch, z.pdat, z.tt, z.ref||k.ru, z.nazn, z.kv, z.lcv, z.rnk||k.ru, z.okpo, z.nmk, z.s,z.s_obz, z.txt
                       from '||pkf('zay_currency_income_ru')||' z, bars.kf_ru k where z.mfo = k.kf',
                       false);
    bpa.enable_policies('ZAY_CURRENCY_INCOME_RU');
  end fill_zay_currency_income_ru;

  procedure fill_zay_data_transfer
  is
    begin
    mgr_utl.sync_table_auto('ZAY_DATA_TRANSFER',
                            false,
                            'ID,"rukey(ID)",REQ_ID,"rukey(REQ_ID)"');
  end fill_zay_data_transfer;


  procedure fill_zay_data_transfer_log
  is
    begin
    mgr_utl.sync_table_auto('ZAY_DATA_TRANSFER_LOG',
                            false,
                            'ID,"rukey(ID)",REQ_ID,"rukey(REQ_ID)"');
  end fill_zay_data_transfer_log;

  procedure fill_zay_debt
  is
    begin
           mgr_utl.sync_table('ZAY_DEBT',
                             'insert into bars.ZAY_DEBT(ref, refd, tip, sos, zay_sum, kf)
                             select rukey(REF) as ref, rukey(REFD) as refd, tip, sos, zay_sum, '''||g_kf||''' as kf 
                             from '||mgr_utl.pkf('ZAY_DEBT'),
                             false);
  end fill_zay_debt;

  procedure fill_zay_debt_klb
  is
    begin
    mgr_utl.sync_table_auto('ZAY_DEBT_KLB',
                            false,
                            'RNK,"rukey(RNK)",ACC0,"rukey(ACC0)",IDENTKB,"rukey(IDENTKB)"');
  end fill_zay_debt_klb;

  procedure fill_zay_que
  is
    begin
    mgr_utl.sync_table_auto('ZAY_QUEUE', false, 'ID,"rukey(ID)"');
  end fill_zay_que;

  procedure fill_zay_track
  is
    l_max_track_id NUMBER;
    begin
    bpa.disable_policies('ZAY_TRACK');
    mgr_utl.sync_table_auto('ZAY_TRACK',
                            false,
                            'TRACK_ID,"rukey(TRACK_ID)",ID,"rukey(ID)",USERID,"ruuser(USERID)"');
    --
    bc.home();
    select trunc(nvl(max(track_id / 100), 0)) + 1
      into l_max_track_id
      from BARS.ZAY_TRACK;
    --
    mgr_utl.reset_sequence('S_ZAY_TRACK', l_max_track_id);
    bpa.enable_policies('ZAY_TRACK');
  end fill_zay_track;

  procedure fill_zay_track_ru
  is
    begin
    bpa.disable_policies('ZAY_TRACK_RU');
    mgr_utl.sync_table('ZAY_TRACK_RU',
                       'insert into bars.zay_track_ru(change_time, fio, mfo, req_id , sos, track_id, viza, viza_name)
                       select z.change_time, z.fio, z.mfo, z.req_id||k.ru , z.sos, z.track_id, z.viza, z.viza_name
                       from '||pkf('zay_track_ru')||' z, bars.kf_ru k where z.mfo = k.kf',
                       false);
    bpa.enable_policies('ZAY_TRACK_RU');
  end fill_zay_track_ru;

  procedure sync_zay_mfo_nls29
  is
  l_tab                   varchar2(30) default 'ZAY_MFO_NLS29';
    begin
      init();
        if g_kf=g_glb_mfo
        then
            mgr_utl.tabsync(l_tab);
            trace('%s rows inserted (by /)', to_char(sql%rowcount));
        end if; 
       execute_statement(
      'update zay_mfo_nls29 set nls29ca = (select nlsb from ' || pkf('tts') ||' where tt = ''GO2'')
      where mfo = ' || g_kf,
      'Оновлення торгового рахунку 29% для МФО ' || g_kf ||' таблиця '||l_tab, null, 'Y');
  end;

  procedure  zay_reset_sqnc
  is
    l_max_zid        zayavka.id%type;
    l_max_zb_id      zay_baop.id%type;
    l_max_zc_id      zay_comiss.id%type;
    l_max_zd_id      zay_data_transfer.id%type;
    l_max_zt_id      zay_track.track_id%type;
    l_max_dk_code    diler_kurs.code%type;
    l_max_dfk_code   diler_kurs_fact.code%type;

   begin

   -- подстраиваем последовательность
        bc.home();
        --
        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_zid
          from zayavka;

        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_zb_id
          from zay_baop;

        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_zc_id
          from zay_comiss;

        select trunc(nvl(max(id / 100), 0)) + 1
          into l_max_zd_id
          from zay_data_transfer;

        select trunc(nvl(max(track_id / 100), 0)) + 1
          into l_max_zt_id
          from zay_track;

        select trunc(nvl(max(code / 100), 0)) + 1
          into l_max_dk_code
          from diler_kurs;

        select trunc(nvl(max(code / 100), 0)) + 1
          into l_max_dfk_code
          from diler_kurs_fact;

        --
        bc.go(g_kf);
        --
      mgr_utl.reset_sequence('s_zayavka',           l_max_zid);
      mgr_utl.reset_sequence('s_zay_baop',          l_max_zb_id);
      mgr_utl.reset_sequence('s_zay_comiss',        l_max_zc_id);
      mgr_utl.reset_sequence('s_zay_data_transfer', l_max_zd_id);
      mgr_utl.reset_sequence('s_zay_track',         l_max_zt_id);
      mgr_utl.reset_sequence('s_diler_kurs',        l_max_dk_code);
      mgr_utl.reset_sequence('s_diler_kurs_fact',   l_max_dfk_code);
        --
  end zay_reset_sqnc;


 --************************************meta*********************************************--
 ------------------
-- meta_tables
------------------
  procedure fill_meta_tables
    is
    l_max_tabid  meta_tables.tabid%type;
    begin
      init();
        -- подстраиваем последовательность
     bc.home();
     --
        select nvl(max(tabid),0)+1
          into l_max_tabid
          from bars.meta_tables;
     --
     mgr_utl.reset_sequence('s_metatables', l_max_tabid);
     --
     bc.go(g_kf);
     --
     mgr_utl.sync_table('META_TABLES',
     'insert into meta_tables (tabid, tabrelation, tabname, tabldel, semantic, branch, linesdef)
      select s_metatables.nextval, tabrelation, tabname, tabldel, semantic, branch, linesdef
      from ' ||pkf('META_TABLES') ||
    ' where tabname not in (select tabname from bars.meta_tables)', false);
  end fill_meta_tables;

------------------
-- meta_filtercodes
------------------
  procedure fill_meta_filtercodes
    is
    begin
      init();

      mgr_utl.sync_table('META_FILTERCODES',
                         'insert into meta_filtercodes(name, condition, code, branch)
                         select name, condition, code, '''||'/'||g_kf||'/'||''' branch
                         from ' || pkf('META_FILTERCODES') ||
                         ' where code not in (select code from bars.meta_filtercodes)', false);
  end fill_meta_filtercodes;
------------------
-- meta_actiontbl
------------------
  procedure fill_meta_actiontbl
    is
    begin
      init();
      mgr_utl.sync_table('META_ACTIONTBL',
                         'insert into meta_actiontbl(tabid, branch, action_proc, action_code)
                         select t2.tabid, '''||'/'||g_kf||'/'||''' branch,  action_proc, action_code
                         from ' ||pkf('META_TABLES')|| ' t1,
                              bars.meta_tables t2,
                              ' || pkf('meta_actiontbl') || ' ma1 ' ||
                         ' where t2.tabname = t1.tabname and t1.tabid = ma1.tabid and t2.tabid not in (select tabid from bars.meta_actiontbl)', false);
  end fill_meta_actiontbl;

------------------
-- meta_columns
------------------
  procedure fill_meta_columns
    is
    begin
      init();
      mgr_utl.sync_table('META_COLUMNS',
                         'insert into meta_columns(tabid,  colid, colname, simple_filter, showwidth, showretval, showresult, showrel_ctype, showref, showpos, showmaxchar, showin_ro, showin_fltr, showformat, semantic, not_to_show, not_to_edit, instnssemantic, form_name, extrnval, coltype,  case_sensitive, branch, web_form_name, oper_id, input_in_new_record)
                         select t2.tabid, mc1.colid, mc1.colname, mc1.simple_filter, mc1.showwidth, mc1.showretval, mc1.showresult,
                                mc1.showrel_ctype, mc1.showref, mc1.showpos, mc1.showmaxchar, mc1.showin_ro,
                                mc1.showin_fltr, mc1.showformat, mc1.semantic, mc1.not_to_show, mc1.not_to_edit,
                                mc1.instnssemantic, mc1.form_name, mc1.extrnval, mc1.coltype,  mc1.case_sensitive, mc1.branch, mc1.web_form_name, mc1.oper_id, null as input_in_new_record
                         from ' || pkf('meta_tables') ||' t1,
                                   bars.meta_tables t2, ' ||
                                   pkf('meta_columns') || ' mc1 ' ||
                         ' where t2.tabname = t1.tabname
                           and mc1.tabid = t1.tabid
                           and t1.tabname not in (select t.tabname from bars.meta_tables t)',
                           false);
  end fill_meta_columns;

------------------
-- meta_browsetbl
------------------
  procedure fill_meta_browsetbl
    is
    begin
      init();
      mgr_utl.sync_table('META_BROWSETBL',
                         'insert into meta_browsetbl(hosttabid, addtabid, var_colid, hostcolkeyid, cond_tag, addtabalias, addcolkeyid, branch)
                         with tabk as (select t1.tabid old_tabid, t2.tabid new_tabid, t2.tabname
                                       from ' ||pkf('meta_tables')|| ' t1,
                                                bars.meta_tables t2
                                                where t1.tabname = t2.tabname)
                         select t1.new_tabid hosttabid, t2.new_tabid  addtabid, var_colid,  hostcolkeyid, cond_tag,  addtabalias, addcolkeyid, '''||'/'||g_kf||'/'||''' branch
                           from tabk t1, tabk t2, ' ||pkf('meta_browsetbl')|| ' m1
                          where t1.old_tabid = m1.hosttabid
                            and t2.old_tabid = m1.addtabid
                            and (t1.new_tabid, t2.new_tabid) not in (select hosttabid, addtabid from bars.meta_browsetbl)',
                         false);
  end fill_meta_browsetbl;
-----------------
-- meta_extrnval
-----------------
  procedure fill_meta_extrnval
    is
    begin
      init();
      mgr_utl.sync_table('META_EXTRNVAL', 'insert into meta_extrnval(tabid, srctabid,  colid, tab_cond, tab_alias,  src_cond,  srccolid,  branch, dyn_tabname, col_dyn_tabname)
                         with tabk as (select t1.tabid old_tabid, t2.tabid new_tabid, t2.tabname
                                       from ' ||pkf('meta_tables')|| ' t1, bars.meta_tables t2
                                       where t1.tabname = t2.tabname)
                         select t1.new_tabid, t2.new_tabid, m1.colid, tab_cond, tab_alias, src_cond, srccolid, branch, dyn_tabname, null as col_dyn_tabname
                           from tabk t1, tabk t2, ' ||pkf('meta_extrnval')|| ' m1
                          where t1.old_tabid = m1.tabid
                            and t2.old_tabid = m1.srctabid
                            and (t1.new_tabid, m1.colid) not in (select tabid, colid from bars.meta_extrnval)
                          order by  t1.new_tabid, t2.new_tabid, m1.colid', false);
  end fill_meta_extrnval;
-----------------
-- meta_filtertbl
-----------------
  procedure fill_meta_filtertbl
    is
    begin
      init();
      mgr_utl.sync_table('META_FILTERTBL', 'insert into meta_filtertbl(tabid, flag_upd, flag_ins, flag_del, filter_tabid, filter_code, colid, branch)
                         with tabk as (select t1.tabid old_tabid, t2.tabid new_tabid, t2.tabname
                                         from ' ||pkf('meta_tables')|| ' t1, bars.meta_tables t2
                                        where t1.tabname = t2.tabname)
                         select t1.new_tabid, flag_upd, flag_ins, flag_del, filter_tabid, filter_code, colid, '''||'/'||g_kf||'/'||''' branch
                           from tabk t1, ' ||pkf('meta_filtertbl')|| ' m1
                          where t1.old_tabid = m1.tabid
                            and (t1.new_tabid) not in (select tabid from bars.meta_filtertbl)',
                          false);
  end fill_meta_filtertbl;
-----------------
-- meta_sortorder
-----------------
  procedure fill_meta_sortorder
    is
    begin
      init();
      mgr_utl.sync_table('META_SORTORDER',
                         'insert into meta_sortorder(tabid, sortway, sortorder, colid, branch)
                         with tabk as (select t1.tabid old_tabid, t2.tabid new_tabid, t2.tabname
                                         from ' ||pkf('meta_tables')|| ' t1, bars.meta_tables t2
                                        where t1.tabname = t2.tabname)
                         select t1.new_tabid, sortway, sortorder, colid, '''||'/'||g_kf||'/'||''' branch
                           from tabk t1, ' ||pkf('meta_sortorder')|| ' m1
                          where t1.old_tabid = m1.tabid and (t1.new_tabid) not in (select tabid from bars.meta_sortorder)', false);
  end fill_meta_sortorder;
-----------------
-- meta_tblcolor
-----------------
  procedure fill_meta_tblcolor
  is
    begin
      init();
      mgr_utl.sync_table('META_TBLCOLOR', 'insert into meta_tblcolor(tabid, ord, condition, color_name, color_index, colid)
                         with tabk as (select t1.tabid old_tabid, t2.tabid new_tabid, t2.tabname
                                         from ' ||pkf('meta_tables')|| ' t1, bars.meta_tables t2
                                        where t1.tabname = t2.tabname)
                         select t1.new_tabid, ord, condition, color_name, color_index, colid
                           from tabk t1, ' ||pkf('meta_tblcolor')|| ' m1
                          where t1.old_tabid = m1.tabid
                            and (t1.new_tabid) not in (select tabid from bars.meta_tblcolor)',
                         false);
  end fill_meta_tblcolor;
-----------------
-- meta_nsifunction
-----------------
  procedure fill_meta_nsifunction
    is
    begin
      init();
      mgr_utl.sync_table('META_NSIFUNCTION',
                         'insert into meta_nsifunction(tabid, proc_name, qst, proc_par,  proc_exec, msg, funcid, form_name, descr, check_func, web_form_name, icon_id)
                         with tabk as (select t1.tabid old_tabid, t2.tabid new_tabid, t2.tabname
                                         from ' ||pkf('meta_tables')|| ' t1, bars.meta_tables t2
                                        where t1.tabname = t2.tabname)
                         select  t1.new_tabid,  proc_name, qst, proc_par,  proc_exec, msg, funcid, form_name, descr, check_func, web_form_name, icon_id
                           from tabk t1, ' ||pkf('meta_nsifunction')|| ' m1
                          where  t1.old_tabid = m1.tabid
                            and (t1.new_tabid, funcid) not in (select tabid, funcid from bars.meta_nsifunction)',
                         false);
  end fill_meta_nsifunction;

  --************************************end meta*********************************************--
  procedure fill_skrynka
    is
    begin
      init();
      mgr_utl.sync_table('SKRYNKA',
                         'insert into skrynka(o_sk, n_sk, snum, keyused, isp_mo, keynumber, branch, kf)
                         select  o_sk, n_sk, snum, keyused, isp_mo, keynumber, branch, kf
                         from ' ||pkf('skrynka'),
                         false);
  end fill_skrynka;

  procedure fill_skrynka_acc
    is
    begin
      init();
      mgr_utl.sync_table('SKRYNKA_ACC',
                         'insert into skrynka_acc(acc, n_sk, tip, branch, kf)
                          select rukey(acc) as acc, n_sk, tip, branch, kf
                            from ' ||pkf('skrynka_acc'),
                         false);

  end fill_skrynka_acc;

  procedure fill_skrynka_nd
    is
    begin
      mgr_utl.sync_table_auto('SKRYNKA_ND',false,'ND,"rukey(ND)",ISP_DOV,"ruuser(ISP_DOV)",RNK,"rukey(RNK)"');
  end fill_skrynka_nd;

  procedure fill_skrynka_nd_upd(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'SKRYNKA_ND_UPDATE';
    l_max_idupd   bars.skrynka_nd_update.idupd%type;
    begin
    --mgr_utl.sync_table_auto('SKRYNKA_ND_UPDATE',false,'ND,"rukey(ND)",ISP_DOV,"ruuser(ISP_DOV)",IDUPD,"rukey(IDUPD)"');
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       (   nd
                         , n_sk
                         , sos
                         , fio
                         , dokum
                         , issued
                         , adres
                         , dat_begin
                         , dat_end
                         , tel
                         , dover
                         , nmk
                         , dov_dat1
                         , dov_dat2
                         , dov_pasp
                         , mfok
                         , nlsk
                         , custtype
                         , o_sk
                         , isp_dov
                         , ndov
                         , nls
                         , ndoc
                         , docdate
                         , sdoc
                         , tariff
                         , fio2
                         , issued2
                         , adres2
                         , pasp2
                         , okpo1
                         , okpo2
                         , s_arenda
                         , s_nds
                         , sd
                         , keycount
                         , prskidka
                         , peny
                         , datr2
                         , mr2
                         , mr
                         , datr
                         , addnd
                         , amort_date
                         , branch
                         , kf
                         , chgdate
                         , chgaction
                         , doneby
                         , idupd
                         , rnk
                       )
                        SELECT 
                           rukey(ND) as nd
                         , n_sk
                         , sos
                         , fio
                         , dokum
                         , issued
                         , adres
                         , dat_begin
                         , dat_end
                         , tel
                         , dover
                         , nmk
                         , dov_dat1
                         , dov_dat2
                         , dov_pasp
                         , mfok
                         , nlsk
                         , custtype
                         , o_sk
                         , ruuser(ISP_DOV) as isp_dov
                         , ndov
                         , nls
                         , ndoc
                         , docdate
                         , sdoc
                         , tariff
                         , fio2
                         , issued2
                         , adres2
                         , pasp2
                         , okpo1
                         , okpo2
                         , s_arenda
                         , s_nds
                         , sd
                         , keycount
                         , prskidka
                         , peny
                         , datr2
                         , mr2
                         , mr
                         , datr
                         , addnd
                         , amort_date
                         , branch
                         , '''||g_kf||''' as kf 
                         , chgdate
                         , chgaction
                         , doneby
                         , rukey(IDUPD) as idupd
                         , rukey(rnk) as rnk                      
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.skrynka_nd_update;

    mgr_utl.reset_sequence('s_skrynka_nd_update', l_max_idupd);
    --
  end fill_skrynka_nd_upd;

  procedure fill_skrynka_nd_acc
    is
    begin
      mgr_utl.sync_table_auto('SKRYNKA_ND_ACC',false,'ND,"rukey(ND)",RNK,"rukey(RNK)"');
  end fill_skrynka_nd_acc;

  procedure fill_skrynka_nd_arc
    is
    begin
      mgr_utl.sync_table_auto('SKRYNKA_ND_ARC',false,'ND,"rukey(ND)",ISP_DOV,"ruuser(ISP_DOV)",RNK,"rukey(RNK)"');
  end fill_skrynka_nd_arc;

  procedure fill_skrynka_nd_ref
    is
    begin
      mgr_utl.sync_table_auto('SKRYNKA_ND_REF',false,'ND,"rukey(ND)",REF,"rukey(REF)"');
  end fill_skrynka_nd_ref;

  procedure fill_skrynka_tip
    is
    begin
     init();
      mgr_utl.sync_table('SKRYNKA_TIP',
                         'insert into skrynka_tip(o_sk, name, s, branch, kf, etalon_id, cell_count)
                         select  o_sk, name, s, branch, kf, etalon_id, cell_count
                         from ' ||pkf('skrynka_tip'),
                         false);
  end fill_skrynka_tip;

  procedure fill_skrynka_visit
    is
    begin
      mgr_utl.sync_table_auto('SKRYNKA_VISIT',false,'ND,"rukey(ND)"');
 end fill_skrynka_visit;

  procedure fill_skr_import_safes
    is
    begin
      init();
      mgr_utl.sync_table('SKR_IMPORT_SAFES',
                         'insert into skr_import_safes(snum, o_sk, branch, error, imported)
                          select  snum, o_sk, branch, error, imported
                            from ' ||pkf('skr_import_safes'),
                         false);

  end fill_skr_import_safes;

  procedure fill_skr_import_deals
    is
    begin
      init();
      mgr_utl.sync_table('SKR_IMPORT_DEALS',
                         'insert into skr_import_deals(safe_num, safe_type_id, key_used, key_number, key_count, bail_sum, day_sum, peny_sum,
                                                       future_sum, deal_num, deal_date, deal_start_date, deal_end_date, custtype, fio, okpo, doc, issued,
                                                       address, birthplace, birthdate, phone, nmk, nlsk, mfok, branch, error, imported, nls2909, nls3600)
                         select safe_num, safe_type_id, key_used, key_number, key_count, bail_sum, day_sum, peny_sum, future_sum, deal_num,
                                deal_date, deal_start_date, deal_end_date, custtype, fio, okpo, doc, issued, address, birthplace, birthdate,
                                phone, nmk, nlsk, mfok, branch, error, imported, nls2909, nls3600
                         from ' ||pkf('skr_import_deals'),
                         false);
  end fill_skr_import_deals;

  procedure fill_skrynka_sync_queue
    is
      begin
      mgr_utl.sync_table_auto('SKRYNKA_SYNC_QUEUE',false,'id,"s_skrynka_sync_queue.nextval"');
  end fill_skrynka_sync_queue;

  procedure fill_skrynka_attorney
   is
      begin
      mgr_utl.sync_table_auto('SKRYNKA_ATTORNEY',false,'nd,"rukey(nd)"');
  end fill_skrynka_attorney;

  procedure fill_skrynka_nd_branch
   is
      begin
      mgr_utl.sync_table_auto('SKRYNKA_ND_BRANCH',false,'nd,"rukey(nd)"');
  end fill_skrynka_nd_branch;

  procedure fill_cc_deal
   is
      begin
      mgr_utl.sync_table_auto('CC_DEAL',false,'ND,"rukey(ND)",RNK,"rukey(RNK)",USER_ID,"rukey(USER_ID)"');
  end fill_cc_deal;

  procedure fill_cc_add
   is
      begin
      mgr_utl.sync_table_auto('CC_ADD',false,'ND,"rukey(ND)",ACCP,"rukey(ACCP)",ACCS,"rukey(ACCS)",SWI_REF,"rukey(SWI_REF)",SWO_REF,"rukey(SWO_REF)"');
  end fill_cc_add;

  procedure fill_nd_acc
   is
      begin
      mgr_utl.sync_table_auto('ND_ACC',false,'ND,"rukey(ND)"');
  end fill_nd_acc;

  procedure fill_nd_acc_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab         VARCHAR2(30) DEFAULT 'ND_ACC_UPDATE';
    l_max_idupd   bars.ND_ACC_UPDATE.idupd%type;

    begin
    --bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table(l_tab,
                        'INSERT INTO '||l_tab||'
                        SELECT rukey(idupd) as idupd, chgaction, effectdate, chgdate,
                               ruuser(doneby) as doneby, rukey(nd) as nd, rukey(acc) as acc, '''||g_kf||''' as kf, global_bdate
                        FROM '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                        false);
    --
    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.nd_acc_update;
    --
    mgr_utl.reset_sequence('s_ndacc_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    --bpa.enable_policies(l_tab);
    --
  end fill_nd_acc_update;

  procedure fill_nd_txt
  is
     begin
     mgr_utl.sync_table_auto('ND_TXT',false,'ND,"rukey(ND)"');
  end fill_nd_txt;

  procedure sync_nd_txt
   is
   l_tab                   varchar2(30) default 'ND_TXT';
    begin
        init();
        mgr_utl.mantain_error_table('nd_txt');
        mgr_utl.before_clean('nd_txt');
        bars_policy_adm.disable_policies('nd_txt');

        execute_statement(
        'delete nd_txt where kf = '''||g_kf||'''',
        'Очистка додаткових атрибутів кредитних угод для МФО ' || g_kf ||' таблиця '||l_tab, null, 'N');

        mgr_utl.finalize();
        mgr_utl.before_fill('nd_txt');

        execute_statement(
        'insert into nd_txt (nd, tag, txt, kf)
        select rukey(nd), tag, txt, kf from ' || pkf('nd_txt') ||
        ' log errors reject limit unlimited',
        'Завантаження додаткових атрибутів кредитних угод для МФО ' || g_kf ||' таблиця '||l_tab);

        trace('%s', get_errinfo('err$_nd_txt'));
        mgr_utl.finalize();
        bars_policy_adm.enable_policies('nd_txt');
  end;

  procedure fill_mbd_k_r
   is
      begin
      mgr_utl.sync_table_auto('MBD_K_R',false,'ND,"rukey(ND)",ref,"rukey(ref)"');
  end fill_mbd_k_r;

  procedure fill_cdb_deal_comment
   is
      begin
      mgr_utl.sync_table_auto('CDB_DEAL_COMMENT',false,'ND,"rukey(ND)"');
  end fill_cdb_deal_comment;

  procedure fill_proc_dr
   is
     begin
     init();
     mgr_utl.sync_table('PROC_DR$BASE','insert into proc_dr$base select * from '||pkf('PROC_DR$BASE')||' ', true);
  end fill_proc_dr;

  procedure execute_statement(
    p_statement in varchar2,
    p_log_label in varchar2,
    p_table_name in varchar2 default null,
    p_mgr_log_label in varchar2 default 'Y')
      is
        l_trace_message         varchar2(32767 byte);
        l_tab                   varchar2(50);
        l_migration_start_time  date default sysdate;
        l_start_time            timestamp default current_timestamp;
        l_end_time              timestamp default current_timestamp;
        l_rowcount              number default 0;
        l_time_duration         interval day(3) to second(3);
    begin
        begin
             l_tab                  := case when p_table_name is null then upper(substr(p_log_label, instr(p_log_label,' ', -1, 1)+1)) else p_table_name end;
             l_migration_start_time := sysdate;
             l_start_time           := current_timestamp;
             l_trace_message        := p_log_label || chr(10) || p_statement;
        execute immediate p_statement;
             l_rowcount        := l_rowcount + sql%rowcount;
             l_end_time        := current_timestamp;
             l_time_duration   := (l_end_time - l_start_time);
             bars_audit.info(l_trace_message || chr(10) || 'виконано успішно - кількість оброблених рядків : ' || l_rowcount);

             case when p_mgr_log_label = 'Y' then
             mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                          ,ip_migration_start_time          => l_migration_start_time
                                          ,ip_table_name                    => l_tab
                                          ,ip_operation                     => p_log_label
                                          ,ip_row_count                     => l_rowcount
                                          ,ip_task_start_time               => l_start_time
                                          ,ip_task_end_time                 => l_end_time
                                          ,ip_time_duration                 => l_time_duration
                                          ,ip_log_message                   => 'Done'
                                          );
             else dbms_output.put_line(l_trace_message);
             end case;
        commit;
        exception
             when others then
                  rollback;
                  l_trace_message := l_trace_message || chr(10) || 'помилка при виконанні : ' || sqlerrm || chr(10) || dbms_utility.format_error_backtrace();
                  mgr_log.p_save_log_error(ip_migration_id             => g_kf
                                           ,ip_migration_start_time     => l_migration_start_time
                                          ,ip_table_name               => l_tab
                                          ,ip_operation                => p_log_label
                                          ,ip_row_count                => l_rowcount
                                          ,ip_task_start_time          => l_start_time
                                          ,ip_task_end_time            => l_end_time
                                          ,ip_time_duration            => l_time_duration
                                          ,ip_log_message              => 'Error'
                                          );
                  bars_audit.error(l_trace_message);
                  dbms_output.put_line(l_trace_message);
        end;
    end;

  procedure reset_sto_sbon_sequence
  is
  l_max_table_id integer;
    begin
        bc.home();
        --
        select nvl(max(trunc(id / 100)), 0) + 1
        into   l_max_table_id
        from   sto_product;

        mgr_utl.reset_sequence('sto_product_seq', l_max_table_id);

        select nvl(max(trunc(id / 100)), 0) + 1
        into   l_max_table_id
        from   sto_order;

        mgr_utl.reset_sequence('sto_order_seq', l_max_table_id);

        select nvl(max(trunc(id / 100)), 0) + 1
        into   l_max_table_id
        from   sto_payment;

        mgr_utl.reset_sequence('sto_payment_seq', l_max_table_id);

        select nvl(max(trunc(id / 100)), 0) + 1
        into   l_max_table_id
        from   sto_payment_tracking;

        mgr_utl.reset_sequence('sto_payment_tracking_seq', l_max_table_id);

/*        select nvl(max(trunc(id / 100)), 0) + 1
        into   l_max_table_id
        from   sto_order_tracking;

        mgr_utl.reset_sequence('sto_order_tracking_seq', l_max_table_id);*/
    end;

  procedure grant_sto_sbon
   is
    begin
     init();

      begin
              execute immediate 'CREATE ROLE SBON_ROLE';
      exception
        when others then
      --"ORA-01921: role name 'x' conflicts with another user or role name"
        if sqlcode = -01921 then null;
        else
          raise;
        end if;
      end;
        begin
           execute immediate 'GRANT BARS_CONNECT TO SBON_ROLE';
           execute immediate 'GRANT EXECUTE ON SBON.STO_SBON_API TO SBON_ROLE';
           execute immediate 'GRANT SELECT ON SBON.V_SB_DOV_ORG TO SBON_ROLE';
           execute immediate 'GRANT SELECT ON SBON.V_SB_POST_PLAT TO SBON_ROLE';
           execute immediate 'GRANT SBON_ROLE TO SBON'||g_ru;
        exception
        when others then
      --"ORA-04042: procedure, function, package, or package body does not exist"
        if sqlcode = -04042 then null;
        else
          raise;
        end if;
      end;
  end grant_sto_sbon;

  procedure fill_sto_sbon
    is
    l_log_label varchar2(32767 byte) := 'mgr_oschad.fill_sto_sbon';
    begin
        mgr_utl.before_fill('sto_product, sto_sbon_product, sto_prod_extra_attributes, sto_order, sto_sbon_order_contr, sto_sbon_order_free, sto_sbon_order_no_contr, ' ||
                            'sto_sep_order, sto_order_extra_attributes, sto_payment, sto_payment_document_link, sto_payment_tracking, sto_payment_que');

        execute_statement('insert into sto_product' ||
                          ' select rukey(id), product_code, product_name, order_type_id, branch_access_mode, state, branch, ''' || g_kf || '''' ||
                          ' from ' || pkf('sto_product'),
                          l_log_label, 'STO_PRODUCT');

        execute_statement('insert into sto_sbon_product' ||
                          ' select rukey(id), contract_id, contract_number, receiver_mfo, receiver_account, receiver_name, receiver_edrpou, payment_name, transit_account' ||
                          ' from ' || pkf('sto_sbon_product'),
                          l_log_label, 'STO_SBON_PRODUCT');

        execute_statement('insert into sto_prod_extra_attributes' ||
                          ' select rukey(product_id), extra_attributes_metadata' ||
                          ' from ' || pkf('sto_prod_extra_attributes'),
                          l_log_label, 'STO_PROD_EXTRA_ATTRIBUTES');

        execute_statement('insert into sto_order' ||
                          ' select rukey(id), order_type_id, rukey(payer_account_id), rukey(product_id), start_date, stop_date, payment_frequency,'||
                          ' holiday_shift, cancel_date, priority, state, getnewuserid(''' || g_kf || ''', user_id), branch, kf, registration_date, send_sms' ||
                          ' from ' || pkf('sto_order'),
                          l_log_label, 'STO_ORDER');

        execute_statement('insert into sto_sbon_order_contr' ||
                          ' select rukey(id), customer_account, regular_amount, ceiling_amount' ||
                          ' from ' || pkf('sto_sbon_order_contr'),
                          l_log_label, 'STO_SBON_ORDER_CONTR');

        execute_statement('insert into sto_sbon_order_free' ||
                          ' select rukey(id), regular_amount, receiver_mfo, receiver_account, receiver_name, receiver_edrpou, purpose' ||
                          ' from ' || pkf('sto_sbon_order_free'),
                          l_log_label, 'STO_SBON_ORDER_FREE');

        execute_statement('insert into sto_sbon_order_no_contr' ||
                          ' select rukey(id), customer_account, regular_amount' ||
                          ' from ' || pkf('sto_sbon_order_no_contr'),
                          l_log_label, 'STO_SBON_ORDER_NO_CONTR');

        execute_statement('insert into sto_sep_order' ||
                          ' select rukey(id), regular_amount, receiver_mfo, receiver_account, receiver_name, receiver_edrpou, purpose, send_sms' ||
                          ' from ' || pkf('sto_sep_order'),
                          l_log_label, 'STO_SEP_ORDER');

        execute_statement('insert into sto_order_extra_attributes' ||
                          ' select rukey(order_id), extra_attributes' ||
                          ' from ' || pkf('sto_order_extra_attributes'),
                          l_log_label, 'STO_ORDER_EXTRA_ATTRIBUTES');

       /* execute_statement('insert into sto_order_tracking' ||
                          ' select rukey(id), rukey(order_id), getnewuserid(''' || g_kf || ''', user_id), comment_text, sys_time' ||
                          ' from ' || pkf('sto_order_tracking'),
                          l_log_label);*/

        execute_statement('insert into sto_payment' ||
                          ' select rukey(id), rukey(order_id), state, value_date, debt_amount, payment_amount, fee_amount, purpose,' ||
                          ' receiver_mfo, receiver_account, receiver_edrpou, '''||'/' ||g_kf||'/'||''' branch, ''' || g_kf || '''' ||
                          ' from ' || pkf('sto_payment'),
                          l_log_label, 'STO_PAYMENT');

        execute_statement('insert into sto_payment_document_link' ||
                          ' select rukey(payment_id), rukey(document_id)' ||
                          ' from ' || pkf('sto_payment_document_link'),
                          l_log_label, 'STO_PAYMENT_DOCUMENT_LINK');

        execute_statement('insert into sto_payment_tracking' ||
                          ' select rukey(id), rukey(payment_id), state, comment_text, sys_time' ||
                          ' from ' || pkf('sto_payment_tracking'),
                          l_log_label, 'STO_PAYMENT_TRACKING');

        execute_statement('insert into sto_payment_que' ||
                          ' select rukey(id)' ||
                          ' from ' || pkf('sto_payment_que'),
                          l_log_label, 'STO_PAYMENT_QUE');

        reset_sto_sbon_sequence();

        grant_sto_sbon();

        mgr_utl.finalize();
    end;

    procedure clean_sto_sbon
    is
        l_log_label varchar2(32767 byte) := 'mgr_oschad.clean_sto_sbon';
    begin
        /*sto_order_tracking,sto_payment_que*/
        mgr_utl.before_clean('sto_product, sto_sbon_product, sto_prod_extra_attributes, sto_order, sto_sbon_order_contr, sto_sbon_order_free, sto_sbon_order_no_contr, ' ||
                             'sto_sep_order, sto_order_extra_attributes, sto_payment, sto_payment_document_link, sto_payment_tracking, sto_payment_que');

        execute_statement('delete sto_payment_que where id in (select id from sto_payment where order_id in (select id from sto_order where kf = ''' || g_kf || '''))', l_log_label, null, 'N');

        execute_statement('delete sto_payment_document_link where payment_id in (select id from sto_payment where order_id in (select id from sto_order where kf = ''' || g_kf || '''))', l_log_label, null, 'N');

        execute_statement('delete sto_payment_tracking where payment_id in (select id from sto_payment where order_id in (select id from sto_order where kf = ''' || g_kf || '''))', l_log_label, null, 'N');

        execute_statement('delete sto_payment where order_id in (select id from sto_order where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

       -- execute_statement('delete sto_order_tracking where order_id in (select id from sto_order where kf = ''' || g_kf || ''')', l_log_label, 'N');

        execute_statement('delete sto_order_extra_attributes where order_id in (select id from sto_order where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

        execute_statement('delete sto_sep_order where id in (select id from sto_order where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

        execute_statement('delete sto_sbon_order_no_contr where id in (select id from sto_order where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

        execute_statement('delete sto_sbon_order_free where id in (select id from sto_order where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

        execute_statement('delete sto_sbon_order_contr where id in (select id from sto_order where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

        execute_statement('delete sto_order where kf = ''' || g_kf || '''', l_log_label, null, 'N');

        execute_statement('delete sto_prod_extra_attributes where product_id in (select id from sto_product where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

        execute_statement('delete sto_sbon_product where id in (select id from sto_product where kf = ''' || g_kf || ''')', l_log_label, null, 'N');

        execute_statement('delete sto_product where kf = ''' || g_kf || '''', l_log_label, null, 'N');

        reset_sto_sbon_sequence();

        mgr_utl.finalize();
    end;

   procedure fill_xml_impfiles
    is
    begin
      init();
      mgr_utl.sync_table('XML_IMPFILES',
                         'insert into bars.xml_impfiles(userid, kf, fn, dat, branch)
                          select ruuser(userid) as userid, kf, fn, dat, '''||'/' ||g_kf||'/'||''' branch
                          from ' ||pkf('xml_impfiles'),
                          false);
  end fill_xml_impfiles;

  procedure fill_xml_impdocs
    is
    l_max_impref    xml_impdocs.impref%type;
    l_tab           VARCHAR2(30 CHAR) DEFAULT 'XML_IMPDOCS';

  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('XML_IMPDOCS',
                         'insert into  bars.xml_impdocs(userid, ref, impref, vob, vdat, tt, status, sk, seq, s2, s, ref_a, nlsb, nlsa, nd, nazn, nam_b, nam_a, mfob, mfoa, kv2, kv, kf, id_b, id_a, fn, errmsg, errcode, d_rec, dk, datp, datd, dat, bis)
                         select ruuser(userid) as userid, rukey(ref) as ref, rukey(impref) as impref, vob, vdat,  tt, status, sk, seq, s2, s, ref_a,  nlsb, nlsa, nd, nazn, nam_b, nam_a, mfob, mfoa, kv2, kv, kf, id_b, id_a, fn, errmsg, errcode, d_rec, dk, datp, datd, dat, bis
                         from ' ||pkf('xml_impdocs')||' log errors reject limit unlimited',
                         false);

     -- подстраиваем последовательность
     bc.home();
     select trunc(nvl(max(impref / 100), 0)) + 1 into l_max_impref from xml_impdocs;
     --
     mgr_utl.reset_sequence('s_xmlimpdocs', l_max_impref);
     --
     trace('%s', get_errinfo('ERR$_'||l_tab));
     --
  end fill_xml_impdocs;

  procedure fill_xml_impdocsw
    is
    begin
      init();
      mgr_utl.sync_table('XML_IMPDOCSW', 'insert into  bars.xml_impdocsw(value, tag, impref)
                         select value, tag, rukey(impref) impref
                         from ' ||pkf('xml_impdocsw')
                         || ' where impref in (select impref from '
                         ||pkf('xml_impdocs')|| ' )',
                         false);
  end fill_xml_impdocsw;

  -------------------------------------------

  ----
  -- fill_zapros - наполнение zapros
  --
  procedure fill_zapros
  is
  l_kodz  zapros.kodz%type;

  begin
    --
    bc.home();
    select nvl(max(kodz), 0) + 1 into l_kodz from bars.zapros;
    --
    mgr_utl.reset_sequence('s_zapros', l_kodz);
    --
    bc.go(g_kf);
    --
    --update для записей ГРЦ
    case when g_kf = g_glb_mfo then
        execute immediate
             'begin
               for cur in(select ruuser(id) as id,
                            case when branch = ''/''
                                 then creator
                                 else to_number(ruuser(creator))
                            end as creator,
                            pkey
                          from bars.zapros
                          where branch = ''/'||g_kf||'/''
                             or branch = ''/'')
               loop
                     update bars.zapros set id=cur.id, creator = cur.creator
                     where pkey=cur.pkey;
               end loop;
               commit;
               end;';
    else
    mgr_utl.sync_table(
        'ZAPROS', --
        'insert into zapros
               (kodz,
                id,
                name,
                namef,
                bindvars,
                create_stmt,
                rpt_template,
                kodr,
                form_proc,
                default_vars,
                creator,
                bind_sql,
                xsl_data,
                txt,
                xsd_data,
                xml_encoding,
                pkey,
                branch,
                last_updated)
         select s_zapros.nextval kodz,
                ruuser(id) as id,
                name,
                namef,
                bindvars,
                create_stmt,
                rpt_template,
                kodr,
                form_proc,
                default_vars,
                ruuser(creator) as creator,
                bind_sql,
                xsl_data,
                txt,
                xsd_data,
                xml_encoding,
                pkey,
                ''/'||g_kf||'/'' as branch,
                null as last_updated
         from '||PKF('zapros')||' where pkey not in(select pkey from zapros)'
              ,true);
  --
  end case;

    execute immediate
    'begin
       for c in(
              select
                    (select kodz from zapros where pkey=
                      (select pkey
                         from  '||PKF('zapros')||
                      ' where kodz=kfz.kodr)
                     )kodr,
                     pkey
              from '||PKF('zapros')||' kfz
              where kfz.pkey in(select pkey from zapros where branch= ''/'||g_kf||'/'')
              and kfz.kodr is not null
              )
       loop
          update zapros
             set kodr=c.kodr
           where pkey=c.pkey;
       end loop;
       commit;
    end;';

  end fill_zapros;

  procedure fill_zapros_attr
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'ZAPROS_ATTR',
                         p_stmt  => 'insert into zapros_attr(id, name, sql_text, kodz)
                                    select kfza.id, kfza.name, kfza.sql_text, bz.kodz
                                    from '||pkf('zapros_attr')||' kfza, '||pkf('zapros')||' kfz, zapros bz
                                    where kfza.id not in(select id from zapros_attr)
                                    and kfza.kodz=KFZ.KODZ(+)
                                    and kfz.pkey=bz.pkey(+)',
                         p_delete => false);
  end fill_zapros_attr;

  procedure fill_reports
  is
   begin
     ---
     --ініціалізуємся
     init();

   mgr_utl.sync_table(
        'REPORTS',
        'insert into reports
                        (id, name, description, form,
                        param,
                        ndat,
                        wt, mask, namew, path,
                        wt2,
                        idf,
                        nodel,
                        dbtype,
                        branch,
                        usearc,
                        emptyfiles)
         select r.id, r.name, r.description, r.form,
                to_char(bz.kodz)||substr(r.param,instr(r.param,'','')) param,
                r.ndat,
                r.wt, r.mask, r.namew, r.path,
                r.wt2,
                r.idf,
                r.nodel,
                r.dbtype,
                 ''/'||g_kf||'/'' as branch,
                r.usearc,
                r.emptyfiles
                from  '||pkf('reports')||' r, '||pkf('zapros')||' z, zapros bz
                where r.id not in(select id from reports)
                and tools.is_valid_number(substr(r.param,1,instr(r.param,'','')-1)) = ''Y''
                and substr(r.param,1,instr(r.param,'','')-1)=z.kodz(+)
                and z.pkey=bz.pkey(+)',
         true);
  --
  end fill_reports;

  procedure fill_sparam_list
    is
    begin
      init();
      mgr_utl.sync_table('SPARAM_LIST',
                         'insert into bars.sparam_list(spid, type, tag, tabname, tabcolumn_check, sqlcondition,  semantic, pkname,
                                                       nsisqlwhere, nsiname, name, max_char, inuse, hist, delonnull, code, branch)
                         select (select nvl(max(spid),0) from sparam_list ) +  rownum, type, tag, tabname, tabcolumn_check, sqlcondition,
                                 semantic, pkname, nsisqlwhere, nsiname, name, max_char, inuse, hist, delonnull, code, '''||'/'||g_kf||'/'||''' as branch
                         from '||pkf('sparam_list')||'
                         where (name, tabname, nvl(tag,'''')) not in (select name, tabname,  nvl(tag,'''')  from bars.sparam_list) ',
                         false);
  end fill_sparam_list;

  procedure fill_references
    is
    begin
      init();
      mgr_utl.sync_table('REFERENCES',
                         'insert into references(tabid, type, dlgname,role2edit)
                         select  bm.tabid, kfr.type, KFR.DLGNAME, KFR.ROLE2EDIT from '||pkf('references')||' kfr, '||pkf('meta_tables')||' kfm, meta_tables bm
                         where kfr.tabid=kfm.tabid
                         and KFM.TABNAME=bm.tabname
                         and bm.tabid not in(select tabid from bars.references)',
                         false);
  end fill_references;


  procedure alter_all_policies
   is
      begin
        for k in(
            select table_name from bars.policy_table)
        loop
            begin
            bars.bpa.alter_policies(k.table_name);
            exception when others then
            trace('%s: error alter policy', k.table_name);
            end;
        end loop;
      commit;
  end alter_all_policies;

  procedure fill_wcs_bids
   is
    begin
      init();
      mgr_utl.sync_table(p_table => 'WCS_BIDS',
                         p_stmt => 'insert into WCS_BIDS (id, subproduct_id, crt_date, inn, rnk, mgr_id, branch, last_date)
                                    select id, subproduct_id, crt_date, inn, rukey(rnk) as rnk, mgr_id, branch, last_date
                                    from '||PKF('WCS_BIDS'),
                         p_delete => false);
  end fill_wcs_bids;

  procedure fill_wcs_bck_reports
      is
      begin
        mgr_utl.sync_table_auto(p_table => 'WCS_BCK_REPORTS',
                                p_delete => false,
                                p_column_replace => 'rep_id,"rukey(rep_id)"');
  end fill_wcs_bck_reports;

  procedure fill_wcs_bck_results
   is
    begin
      init();
      mgr_utl.sync_table(p_table => 'WCS_BCK_RESULTS',
                         p_stmt => 'insert into WCS_BCK_RESULTS (id, rep_id, tag_name, tag_block, tag_value, seq_id)
                                    select rukey(id) as id, rukey(rep_id) as rep_id, tag_name, tag_block, tag_value, seq_id
                                    from '||PKF('WCS_BCK_RESULTS'),
                         p_delete => false);

  end fill_wcs_bck_results;

  procedure fill_wcs_cc_members
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'WCS_CC_MEMBERS',
                         p_stmt  => 'insert into WCS_CC_MEMBERS (branch, head, mbr1, mbr2, mbr3, mbr4, mbr5, mbr6, mbr7, mbr8, mbr9, mbr10)
                                    select branch, head, mbr1, mbr2, mbr3, mbr4, mbr5, mbr6, mbr7, mbr8, mbr9, mbr10
                                    from '||PKF('WCS_CC_MEMBERS'),
                         p_delete => false);
  end fill_wcs_cc_members;

  procedure fill_wcs_power_of_attorneys
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'WCS_POWER_OF_ATTORNEYS',
                         p_stmt  => 'insert into WCS_POWER_OF_ATTORNEYS (branch, ord, active, fio, fio_r, post, post_r, poa_doc, poa_date, poa_notary, poa_notary_num, branch_adr, branch_loc, branch_name, poa_cert, district_name)
                                    select branch, ord, active, fio, fio_r, post, post_r, poa_doc, poa_date, poa_notary, poa_notary_num, branch_adr, branch_loc, branch_name, poa_cert, district_name
                                    from '||PKF('WCS_POWER_OF_ATTORNEYS'),
                         p_delete => false);
  end fill_wcs_power_of_attorneys;

  procedure fill_wcs_subproduct_branches
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'WCS_SUBPRODUCT_BRANCHES',
                         p_stmt  => 'insert into WCS_SUBPRODUCT_BRANCHES (SUBPRODUCT_ID, START_DATE, END_DATE, APPLY_HIERARCHY,BRANCH)
                                    select SUBPRODUCT_ID, START_DATE, END_DATE, APPLY_HIERARCHY,BRANCH
                                    from '||PKF('WCS_SUBPRODUCT_BRANCHES')||' where branch<>''/''',
                         p_delete => false);
  end fill_wcs_subproduct_branches;

  procedure fill_wcs_subproduct_macs
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'WCS_SUBPRODUCT_MACS',
                         p_stmt  => 'insert
                                    into WCS_SUBPRODUCT_MACS (SUBPRODUCT_ID, MAC_ID, VAL_TEXT, VAL_NUMB, VAL_DECIMAL, VAL_DATE, VAL_LIST, VAL_REFER, VAL_FILE, VAL_BOOL, APPLY_DATE, BRANCH)
                                    select SUBPRODUCT_ID, MAC_ID, VAL_TEXT, VAL_NUMB, VAL_DECIMAL, VAL_DATE, VAL_LIST, VAL_REFER, VAL_FILE, VAL_BOOL, APPLY_DATE,BRANCH
                                    from '||PKF('WCS_SUBPRODUCT_MACS')||' where branch<>''/''',
                         p_delete => false);
  end fill_wcs_subproduct_macs;

  procedure fill_wcs_user_responsibility
    is
    begin
      init();
      mgr_utl.sync_table(p_table => 'wcs_user_responsibility',
                         p_stmt  => 'insert into wcs_user_responsibility (STAFF_ID, SRV_ID, SRV_HIERARCHY, BRANCH)
                                    select ruuser(STAFF_ID), SRV_ID, SRV_HIERARCHY, BRANCH
                                    from '||PKF('WCS_USER_RESPONSIBILITY'),
                         p_delete => false);
  end fill_wcs_user_responsibility;

  procedure fill_cp_dat
    is
    begin
      mgr_utl.sync_table_auto('CP_DAT', false);
  end fill_cp_dat;

  procedure fill_cp_dat_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'CP_DAT_UPDATE';
    l_max_idupd   bars.CP_DAT_UPDATE.idupd%type;
  begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
      --mgr_utl.sync_table_auto('CP_DAT_UPDATE', false, 'DONEBY,"ruuser(DONEBY)"');
      --Не было обернуто rukey(idupd), обернул
        mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( id
                         ,npp
                         ,dok
                         ,kup
                         ,chg_date
                         ,action
                         ,nom
                         ,idupd
                         ,doneby
                         ,effectdate
                         ,expiry_date
                         ,ir
                         ,kf
                       )
                        SELECT 
                         id
                         ,npp
                         ,dok
                         ,kup
                         ,chg_date
                         ,action
                         ,nom
                         ,rukey(idupd) as idupd
                         ,ruuser(DONEBY) as doneby
                         ,effectdate
                         ,expiry_date
                         ,ir
                         , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home();
    --    
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.CP_DAT_UPDATE;
    --
    mgr_utl.reset_sequence('S_CP_DAT_UPDATE', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
  end fill_cp_dat_update;

  procedure fill_cp_kod
    is
    begin
      bars_policy_adm.disable_policies('CP_KOD');
      init();
      mgr_utl.sync_table(p_table => 'CP_KOD',
                         p_stmt => 'insert into cp_kod (id, emi, dox, cp_id, kv, name, country, datp, ir, tip, dat_em, amort, dcp, cena, basey, cena_kup, ky, dok, dnk,
                                                        rnk, period_kup, idt, dat_rr, pr1_kup, pr_amr, fin23, kat23, k23, vncrr, pr_akt, metr, gs, cena_kup0,
                                                        cena_start, quot_sign, datzr, datvk, io, riven, in_br, expiry, vncrp, zal_cp, pawn, hierarchy_id)
                                    select id, nvl(emi,0) as emi, nvl(dox,0) as dox, cp_id, kv, name, country, datp, ir, nvl(tip,0) as tip, dat_em, amort, dcp, cena, basey, cena_kup, ky, dok, dnk,
                                                        nvl(rukey(rnk),0) as rnk, period_kup, idt, dat_rr, pr1_kup, pr_amr, fin23, kat23, k23, vncrr, pr_akt, metr, gs, cena_kup0,
                                                        cena_start, quot_sign, datzr, datvk, io, riven, in_br, expiry, vncrp, zal_cp, pawn, hierarchy_id
                                    from '||PKF('CP_KOD'),
                         p_delete => false);

      bars_policy_adm.enable_policies('CP_KOD');
  end fill_cp_kod;

  procedure fill_cp_deal
    is
    begin
    mgr_utl.sync_table_auto('cp_deal', false,
                            'acc,"rukey(acc)",accd,"rukey(accd)",accr,"rukey(accr)",accr2,"rukey(accr2)",accs,"rukey(accs)",accp,"rukey(accp)",accr3,"rukey(accr3)",acc,"rukey(acc)",accs5,"rukey(accs5)",accs6,"rukey(accs6)",accunrec,"rukey(accunrec)",accexpr,"rukey(accexpr)",accexpn,"rukey(accexpn)",ref_old,"rukey(ref_old)",ref_new,"rukey(ref_new)",initial_ref,"rukey(initial_ref)",ref,"rukey(ref)"');
      end fill_cp_deal;


  procedure fill_oper_from_cp_deal
    is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_oper_from_cp_deal';
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

  /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
  */

    TYPE t_oper_row IS TABLE OF oper%ROWTYPE;
    vv_cur_oper t_oper_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_oper IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPER%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_oper (v_indx).ref;
         v_cur_exceptions (i).kf                     := vv_cur_oper (v_indx).kf;
         v_cur_exceptions (i).pdat                   := vv_cur_oper (v_indx).pdat;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPER
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_oper;

    --
    BEGIN
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    trace('%s: entry point', p);
    --
    bc.go(g_kf);

    mgr_utl.before_fill(l_tab);

    mgr_utl.mantain_error_table(l_tab);
             --
            BEGIN
            OPEN l_cur FOR
              'select
                       rukey(ref) as ref
                      ,deal_tag
                      ,tt
                      ,vob
                      ,nd
                      ,pdat
                      ,vdat
                      ,kv
                      ,dk
                      ,s
                      ,sq
                      ,sk
                      ,datd
                      ,datp
                      ,nam_a
                      ,nlsa
                      ,mfoa
                      ,nam_b
                      ,nlsb
                      ,mfob
                      ,nazn
                      ,d_rec
                      ,id_a
                      ,id_b
                      ,id_o
                      ,sign
                      ,sos
                      ,vp
                      ,chk
                      ,s2
                      ,kv2
                      ,kvq
                      ,rukey(refl) as refl
                      ,prty
                      ,sq2
                      ,currvisagrp
                      ,nextvisagrp
                      ,ref_a
                      ,tobo
                      ,otm
                      ,signed
                      ,branch
                      ,ruuser(userid) as userid
                      ,ruuser(respid) as respid
                      ,'''||g_kf||'''
                      ,bis
                      ,sos_tracker
                      ,next_visa_branches
                      ,sos_change_time
                      ,odat
                      ,bdat
              from '||pkf('oper')||' op_kf
              where exists
                          (select null
                           from (select substr(ref,1,length(ref)-2) AS ref
                                 from bars.cp_deal cd
                                 where not exists (select null
                                                   from bars.oper op
                                                   where op.ref = cd.ref)
                                 )nex
                           where nex.ref = op_kf.ref
                           )';
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_oper LIMIT c_limit;
               EXIT WHEN vv_cur_oper.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_oper SAVE EXCEPTIONS
              INSERT INTO bars.oper
                                        VALUES vv_cur_oper(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_oper ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
           -- Clear collection for vv_cur_oper
           vv_cur_oper.delete;
         END;
   --
  bc.home();
   --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);

  end fill_oper_from_cp_deal;

  procedure fill_opldok_from_cp_deal
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPLDOK';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_opldok_from_cp_deal';
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_opldok_row IS TABLE OF opldok%ROWTYPE;

    vv_cur_opldok t_opldok_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_opldok IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPLDOK%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_opldok (v_indx).ref;
         v_cur_exceptions (i).kf                     := vv_cur_opldok (v_indx).kf;
         v_cur_exceptions (i).acc                    := vv_cur_opldok (v_indx).acc;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPLDOK
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_opldok;

    BEGIN
      v_count          := 0;
      c_n              := 0;
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

          BEGIN
          OPEN l_cur FOR
                  'select
                       rukey(ref) as ref
                       ,tt
                       ,dk
                       ,rukey(acc) as acc
                       ,fdat
                       ,s
                       ,sq
                       ,txt
                       ,rukey(stmt) as stmt
                       ,sos
                       ,'''||g_kf||''' as kf
                       ,otm
                       ,to_number(rukey(id)) as id
                       --,null as id
                  from '||pkf('opldok')||' op_kf
              where exists
                          (select null
                           from (select substr(ref,1,length(ref)-2) AS ref
                                 from bars.cp_deal cd
                                 where not exists (select null
                                                   from bars.opldok op
                                                   where op.ref = cd.ref)
                                 )nex
                           where nex.ref = op_kf.ref
                           )';
    --
         LOOP
           FETCH l_cur BULK COLLECT INTO vv_cur_opldok LIMIT c_limit;
             EXIT WHEN vv_cur_opldok.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF vv_cur_opldok SAVE EXCEPTIONS
            INSERT INTO bars.opldok
                                      VALUES vv_cur_opldok(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_opldok ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for vv_cur_opldok
        vv_cur_opldok.delete;
        END;
    --
    bc.home();

      --  trace('собираем статистику');

      --  mgr_utl.gather_table_stats (ownname => 'BARS', tabname => 'OPLDOK',  cascade=>true);

    mgr_utl.finalize();
    --
    trace('%s: finished', p);

  end fill_opldok_from_cp_deal;

  procedure fill_oper_from_cp_arch
    is
    l_tab                   VARCHAR2(30) DEFAULT 'OPER';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_oper_from_cp_arch';
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

  /*
   * Source data record and associative array type. Needed to
   * enable LIMIT-based fetching...
  */

    TYPE t_oper_row IS TABLE OF oper%ROWTYPE;
    vv_cur_oper t_oper_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_oper IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPER%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_oper (v_indx).ref;
         v_cur_exceptions (i).kf                     := vv_cur_oper (v_indx).kf;
         v_cur_exceptions (i).pdat                   := vv_cur_oper (v_indx).pdat;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPER
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_oper;

    --
    BEGIN
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;

    trace('%s: entry point', p);
    --
    bc.go(g_kf);

    mgr_utl.before_fill(l_tab);

    mgr_utl.mantain_error_table(l_tab);
             --
      BEGIN
      OPEN l_cur FOR
              'select
                       rukey(ref) as ref
                      ,deal_tag
                      ,tt
                      ,vob
                      ,nd
                      ,pdat
                      ,vdat
                      ,kv
                      ,dk
                      ,s
                      ,sq
                      ,sk
                      ,datd
                      ,datp
                      ,nam_a
                      ,nlsa
                      ,mfoa
                      ,nam_b
                      ,nlsb
                      ,mfob
                      ,nazn
                      ,d_rec
                      ,id_a
                      ,id_b
                      ,id_o
                      ,sign
                      ,sos
                      ,vp
                      ,chk
                      ,s2
                      ,kv2
                      ,kvq
                      ,rukey(refl) as refl
                      ,prty
                      ,sq2
                      ,currvisagrp
                      ,nextvisagrp
                      ,ref_a
                      ,tobo
                      ,otm
                      ,signed
                      ,branch
                      ,ruuser(userid) as userid
                      ,ruuser(respid) as respid
                      ,'''||g_kf||'''
                      ,bis
                      ,sos_tracker
                      ,next_visa_branches
                      ,sos_change_time
                      ,odat
                      ,bdat
              from '||pkf('oper')||' op_kf
              where exists
                          (select null
                           from (select substr(ref,1,length(ref)-2) AS ref
                                 from bars.cp_arch cd
                                 where not exists (select null
                                                   from bars.oper op
                                                   where op.ref = cd.ref)
                                 )nex
                           where nex.ref = op_kf.ref
                           )';
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_oper LIMIT c_limit;
               EXIT WHEN vv_cur_oper.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_oper SAVE EXCEPTIONS
              INSERT INTO bars.oper
                                        VALUES vv_cur_oper(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_oper ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
           -- Clear collection for vv_cur_oper
           vv_cur_oper.delete;
        END;
   --
  bc.home();
   --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);

  end fill_oper_from_cp_arch;

  procedure fill_opldok_from_cp_arch
  is
    l_tab                   VARCHAR2(30) DEFAULT 'OPLDOK';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_opldok_from_cp_arch';
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_opldok_row IS TABLE OF opldok%ROWTYPE;

    vv_cur_opldok t_opldok_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_opldok IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OPLDOK%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).ref                    := vv_cur_opldok (v_indx).ref;
         v_cur_exceptions (i).kf                     := vv_cur_opldok (v_indx).kf;
         v_cur_exceptions (i).acc                    := vv_cur_opldok (v_indx).acc;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OPLDOK
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_opldok;

    BEGIN
      v_count          := 0;
      c_n              := 0;
      l_migration_start_time := sysdate;
      l_start_time := current_timestamp;

    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

          BEGIN
          OPEN l_cur FOR
                  'select
                       rukey(ref) as ref
                       ,tt
                       ,dk
                       ,rukey(acc) as acc
                       ,fdat
                       ,s
                       ,sq
                       ,txt
                       ,rukey(stmt) as stmt
                       ,sos
                       ,'''||g_kf||''' as kf
                       ,otm
                       --,null as id
                       ,to_number(rukey(id)) as id
                  from '||pkf('opldok')||' op_kf
              where exists
                          (select null
                           from (select substr(ref,1,length(ref)-2) AS ref
                                 from bars.cp_arch cd
                                 where not exists (select null
                                                   from bars.opldok op
                                                   where op.ref = cd.ref)
                                 )nex
                           where nex.ref = op_kf.ref
                           )';
    --
         LOOP
           FETCH l_cur BULK COLLECT INTO vv_cur_opldok LIMIT c_limit;
             EXIT WHEN vv_cur_opldok.COUNT = 0;

         BEGIN
          FORALL indx IN INDICES OF vv_cur_opldok SAVE EXCEPTIONS
            INSERT INTO bars.opldok
                                      VALUES vv_cur_opldok(indx);

          EXCEPTION
                 WHEN bulk_exceptions THEN
                    c_n := c_n + SQL%ROWCOUNT;
                    error_logging_opldok ();
         END;
          COMMIT;
            v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

         END LOOP;
         l_rowcount := l_cur%rowcount;
         CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
         -- Clear collection for vv_cur_opldok
        vv_cur_opldok.delete;
        END;
    --
    bc.home();

      --  trace('собираем статистику');

      --  mgr_utl.gather_table_stats (ownname => 'BARS', tabname => 'OPLDOK',  cascade=>true);

    mgr_utl.finalize();
    --
    trace('%s: finished', p);

  end fill_opldok_from_cp_arch;


  procedure fill_cp_deal_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'cp_deal_update';
    l_max_idupd   bars.cp_deal_update.idupd%type;
  begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --mgr_utl.sync_table_auto('cp_deal_update', false,
    --                        'acc,"rukey(acc)",accd,"rukey(accd)",accr,"rukey(accr)",accr2,"rukey(accr2)",accs,"rukey(accs)",accp,"rukey(accp)",accr3,"rukey(accr3)",acc,"rukey(acc)",accs5,"rukey(accs5)",accs6,"rukey(accs6)",accunrec,"rukey(accunrec)",accexpr,"rukey(accexpr)",accexpn,"rukey(accexpn)",ref_old,"rukey(ref_old)",ref_new,"rukey(ref_new)",initial_ref,"rukey(initial_ref)",ref,"rukey(ref)",doneby,"ruuser(doneby)",idupd,"rukey(idupd)"');
    mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,id
                         ,ryn
                         ,acc
                         ,accd
                         ,accp
                         ,accr
                         ,accs
                         ,ref
                         ,erat
                         ,accr2
                         ,erate
                         ,dazs
                         ,ref_old
                         ,ref_new
                         ,op
                         ,dat_ug
                         ,pf
                         ,active
                         ,initial_ref
                         ,dat_bay
                         ,accexpn
                         ,accexpr
                         ,accs5
                         ,accs6
                         ,accr3
                         ,accunrec
                         ,kf
                       )
                        SELECT 
                         rukey(idupd) as idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,ruuser(doneby) as doneby
                         ,id
                         ,ryn
                         ,rukey(acc) as acc
                         ,rukey(accd) as accd
                         ,rukey(accp) as accp
                         ,rukey(accr) as accr
                         ,rukey(accs) as accs
                         ,rukey(ref) as ref
                         ,erat
                         ,rukey(accr2) as accr2
                         ,erate
                         ,dazs
                         ,rukey(ref_old) as ref_old
                         ,rukey(ref_new) as ref_new
                         ,op
                         ,dat_ug
                         ,pf
                         ,active
                         ,rukey(initial_ref) as initial_ref
                         ,dat_bay
                         ,rukey(accexpn) as accexpn
                         ,rukey(accexpr) as accexpr
                         ,rukey(accs5) as accs5
                         ,rukey(accs6) as accs6
                         ,rukey(accr3) as accr3
                         ,rukey(accunrec) as accunrec
                         , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);    --
    bc.home();
    --    
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cp_deal_update;
    --
    mgr_utl.reset_sequence('s_cpdeal_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
  end fill_cp_deal_update;

  procedure fill_pawn_acc
     is
     begin
      mgr_utl.sync_table_auto('pawn_acc', false,'acc,"rukey(acc)",ndz,"rukey(ndz)",IDZ,"ruuser(IDZ)"');
  end fill_pawn_acc;

  procedure fill_cp_arch
     is
     begin
      init();
      mgr_utl.sync_table(p_table => 'CP_ARCH',
                         p_stmt => 'insert into cp_arch (ref, id, dat_ug, dat_opl, dat_roz, acc, sumb, n, d, p, r, s, z, str_ref, op,
                                                         stiket, sn, ref_repo, vd, vp, ref_main, t, nom, tq, dat_sn, sn_1, dat_sn_1, kf)
                                    select  rukey(ref) ref, id, dat_ug, dat_opl, dat_roz, rukey(acc) acc, sumb, n,d,p,r,s,z,
                                            rukey(replace(str_ref,'','',substr(rukey(1),2,2)||'','')),
                                            op,to_lob(stiket) as stiket,sn, rukey(ref_repo) ref_repo,
                                            vd,vp, rukey(ref_main) ref_main, t,nom,tq,dat_sn,sn_1,dat_sn_1, '||g_kf||'
                                    from '||PKF('CP_ARCH'),
                         p_delete => false);

  end fill_cp_arch;

  procedure fill_cp_forw
     is
     begin
       bars_policy_adm.disable_policies('CP_FORW');
       mgr_utl.sync_table_auto('CP_FORW', false,'ref,"rukey(ref)",stmt,"rukey(stmt)",acc,"rukey(acc)"');
       bars_policy_adm.enable_policies('CP_FORW');
  end fill_cp_forw;

  procedure fill_cp_accounts
     is
     begin
       bars_policy_adm.disable_policies('CP_ACCOUNTS');
       mgr_utl.sync_table_auto('CP_ACCOUNTS', false,'CP_ACC,"rukey(CP_ACC)",CP_REF,"rukey(CP_REF)"');
       bars_policy_adm.enable_policies('CP_ACCOUNTS');
  end fill_cp_accounts;

  procedure fill_cp_payments
     is
     begin
       mgr_utl.sync_table_auto('CP_PAYMENTS', false,'OP_REF,"rukey(OP_REF)",CP_REF,"rukey(CP_REF)"');
  end fill_cp_payments;

  procedure fill_cp_zal
    is
    begin
       bars_policy_adm.disable_policies('CP_ZAL');
      mgr_utl.sync_table_auto('CP_ZAL', false,'ref,"rukey(ref)"');
      bars_policy_adm.enable_policies('CP_ZAL');
  end fill_cp_zal;

  procedure fill_cp_many
    is
    begin
       mgr_utl.sync_table_auto('CP_MANY',false,'ref,"rukey(ref)"');
  end fill_cp_many;

  procedure fill_cp_many_dat
    is
    begin
      mgr_utl.sync_table_auto('CP_MANY_DAT', false,'REF1,"rukey(REF1)",REF2,"rukey(REF2)"');
  end fill_cp_many_dat;


  procedure fill_cp_many_upd
    is
    begin
      mgr_utl.sync_table_auto('CP_MANY_UPD', false,'u_id,"ruuser(u_id)",REF,"rukey(REF)"');
  end fill_cp_many_upd;

  procedure fill_cp_many_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'CP_MANY_UPDATE';
    l_max_idupd  cp_many_update.idupd%type;
    begin
     --
     init();
     --
     --mgr_utl.sync_table_auto('CP_MANY_UPDATE', false,'idupd,"rukey(idupd)",doneby,"ruuser(doneby)",REF,"rukey(REF)"');
     --
     --      
     l_max_idupd := get_max_idupd(l_tab);
     --
     mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,ref
                         ,fdat
                         ,ss1
                         ,sdp
                         ,sn2
                         ,kf
                       )
                        SELECT 
                         rukey(idupd) as idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,ruuser(doneby) as doneby
                         ,rukey(REF) as ref
                         ,fdat
                         ,ss1
                         ,sdp
                         ,sn2
                         , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
     bc.home();
     --
     select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cp_many_update;
     --
     mgr_utl.reset_sequence('s_cp_many_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
  end fill_cp_many_update;

  procedure fill_otcn_f42_cp
    is
    begin
      mgr_utl.sync_table_auto('OTCN_F42_CP', false,'acc,"rukey(acc)",rnk,"rukey(rnk)"');
  end fill_otcn_f42_cp;

  procedure fill_specparam_cp_ob
    is
    begin
      bars_policy_adm.disable_policies('SPECPARAM_CP_OB');
      mgr_utl.sync_table_auto('SPECPARAM_CP_OB', false,'acc,"rukey(acc)"');
      bars_policy_adm.enable_policies('SPECPARAM_CP_OB');
  end fill_specparam_cp_ob;

  procedure fill_cp_ticket
    is
    begin
      mgr_utl.sync_table_auto('CP_TICKET', false,'ref,"rukey(ref)"');
  end fill_cp_ticket;

  procedure fill_cp_ref_acc
    is
    begin
      mgr_utl.sync_table_auto('CP_REF_ACC', false,'REF,"rukey(REF)",ACC,"rukey(ACC)"');
  end fill_cp_ref_acc;

  procedure fill_cp_rates_sb
    is
    begin
      mgr_utl.sync_table_auto('CP_RATES_SB', false,'REF,"rukey(REF)"');
  end fill_cp_rates_sb;

  procedure fill_cp_emiw
    is
    begin
      mgr_utl.sync_table_auto('CP_EMIW', false,'RNK,"rukey(RNK)"');
  end fill_cp_emiw;

  procedure fill_accountsp
    is
    begin
       init();
       mgr_utl.sync_table(p_table => 'ACCOUNTSP',
                          p_stmt => 'insert into ACCOUNTSP(acc, dat1, dat2, parid, val, kf)
                                    select rukey(acc) as acc, dat1, dat2, parid, val, '''||g_kf||''' as kf
                                    from '||pkf('ACCOUNTSP'),
                          p_delete => false);
  end fill_accountsp;

  procedure fill_mbk_cp
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'mbk_cp',
                              p_delete => false,
                              p_column_replace => 'nd,"rukey(nd)",acc,"rukey(acc)",ref,"rukey(ref)"');
  end fill_mbk_cp;

  procedure fill_cp_kod_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_max_idupd  cp_kod_update.idupd%type;
    l_tab        VARCHAR2(30 CHAR) DEFAULT 'CP_KOD_UPDATE';
    begin
     mgr_utl.mantain_error_table('CP_KOD_UPDATE');
     init();
     --      
     l_max_idupd := get_max_idupd(l_tab);
     --
     mgr_utl.sync_table(l_tab,
     'insert into '||l_tab||' (idupd, chgaction, effectdate, chgdate, doneby, id, emi, dox, cp_id, kv, name, country, datp,
                                 ir, tip, dat_em, amort, dcp, cena, basey, cena_kup, ky, dok, dnk, rnk, period_kup, idt, dat_rr,
                                 pr1_kup, pr_amr, fin23, kat23, k23, vncrr, pr_akt, metr, gs, cena_kup0, cena_start, quot_sign,
                                 datzr, datvk, io, riven, in_br, expiry, zal_cp, pawn, hierarchy_id, kf)
      select rukey(idupd) as idupd, chgaction, effectdate, chgdate, ruuser(doneby) as doneby, id, emi, dox, cp_id, kv, name, country, datp,
             ir, tip, dat_em, amort, dcp, cena, basey, cena_kup, ky, dok, dnk, rukey(rnk) as rnk, period_kup, idt, dat_rr,
             pr1_kup, pr_amr, fin23, kat23, k23, vncrr, pr_akt, metr, gs, cena_kup0, cena_start, quot_sign,
             datzr, datvk, io, riven, in_br, expiry, zal_cp, pawn, hierarchy_id, '''||g_kf||''' as kf
      from ' ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd||' log errors reject limit unlimited', false);
     --
     bc.home();
     --
     select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cp_kod_update;
     --
     mgr_utl.reset_sequence('s_cp_kod_update', l_max_idupd);
     --
     trace('%s', get_errinfo('ERR$_'||l_tab));
     --
  end fill_cp_kod_update;


  procedure fill_sw_journal
    is
    l_max_swref  NUMBER;
    begin
      mgr_utl.sync_table_auto(p_table => 'sw_journal',
                              p_delete => false,
                              p_column_replace => 'swref,"rukey(swref)"');
          begin
            bc.home();
            select trunc(nvl(max(swref / 100), 0)) + 1
            into l_max_swref
            from bars.sw_journal;
            bc.go(g_kf);
            mgr_utl.reset_sequence('s_sw_journal', l_max_swref);
          exception when others then
            rollback;
            mgr_utl.save_error();
          end;
  end fill_sw_journal;

  procedure fill_fx_deal
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('FX_DEAL', false,'rnk,"rukey(rnk)",ref,"rukey(ref)",ref1,"rukey(ref1)",refa,"rukey(refa)",refb,"rukey(refb)",refb2,"rukey(refb2)",refa_stopd,"rukey(refa_stopd)",refb_stopd,"rukey(refb_stopd)",refb2_stopd,"rukey(refb2_stopd)",acc9a,"rukey(acc9a)",acc9b,"rukey(acc9b)",swi_ref,"rukey(swi_ref)",swo_ref,"rukey(swo_ref)"');
  end fill_fx_deal;

  procedure fill_fx_deal_acc
    is
    l_max_id FX_DEAL_ACC.ID%type;
    begin
      bpa.disable_policies('FX_DEAL_ACC');
      mgr_utl.sync_table_auto(p_table => 'fx_deal_acc',
                              p_delete => false,
                              p_column_replace => 'rnk,"rukey(rnk)",acc9,"rukey(acc9)"');
      bpa.enable_policies('FX_DEAL_ACC');
         begin
            bc.home();
            select trunc(nvl(max(id ), 0)) + 1
            into l_max_id
            from bars.FX_DEAL_ACC;
            bc.go(g_kf);
            mgr_utl.reset_sequence('s_fxdealacc', l_max_id);
          exception when others then
            rollback;
            mgr_utl.save_error();
          end;
      
  end fill_fx_deal_acc;

  procedure fill_mb_plan
    is
    begin
     MGR_UTL.SYNC_TABLE_AUTO('MB_PLAN', false,'ND_ID,"rukey(ND_ID)"');
  end fill_mb_plan;

  procedure fill_acc_over
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'acc_over',
                              p_delete => false,
                              p_column_replace => 'nd,"rukey(nd)",userid,"ruuser(userid)",acc_3739,"rukey(acc_3739)",acc_3600,"rukey(acc_3600)"');
  end fill_acc_over;

  procedure fill_acc_over_arch
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'acc_over_archive',
                              p_delete => false,
                              p_column_replace => 'nd,"rukey(nd)",userid,"ruuser(userid)",acc_9129,"rukey(acc_9129)",acc_8000,"rukey(acc_8000)",acc_2067,"rukey(acc_2067)",acc_2069,"rukey(acc_2069)",acc_2096,"rukey(acc_2096)"');
  end fill_acc_over_arch;

  procedure fill_acc_over_par
    is
    begin
      mgr_utl.sync_table(p_table => 'acc_over_par',
                         p_stmt  => 'insert into acc_over_par(par, val, comm, kf)
                                     select par, val, comm, '||g_kf||' from '||pkf('acc_over_par')||' where kf='||g_kf,
                         p_delete => true);
  end fill_acc_over_par;

  procedure fill_acc_over_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab         VARCHAR2(30) DEFAULT 'ACC_OVER_UPDATE';
    l_max_idupd   bars.ACC_OVER_UPDATE.idupd%type;

    begin
    init();
    --bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table('ACC_OVER_UPDATE',
                        'INSERT INTO ACC_OVER_UPDATE
                        SELECT rukey(idupd) as idupd, chgaction, effectdate, chgdate, ruuser(doneby) as doneby, rukey(acc)as acc, rukey(acco) as acco, tipo, flag, rukey(nd) as nd,
                               day, sos, datd, sd, ndoc, vidd, datd2, krl, useostf, uselim, rukey(acc_9129) as acc_9129, rukey(acc_8000) as acc_8000,
                               obs, txt, userid, deleted, pr_2600a, pr_komis, pr_9129, pr_2069, rukey(acc_2067) as acc_2067, rukey(acc_2069) as acc_2069,
                               rukey(acc_2096) as acc_2096, '''||g_kf||''' as kf, rukey(acc_3739) as acc_3739, kat23, fin23, obs23, k23, fin, rukey(acc_3600) as acc_3600, s_3600, flag_3600,
                               global_bdate  
                        FROM '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                        false);
    --
    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.acc_over_update;
    --
    mgr_utl.reset_sequence('s_acc_over_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
    --bpa.enable_policies(l_tab);
    --
  end fill_acc_over_update;

  procedure fill_acc_over_deal
     is
     begin
       mgr_utl.sync_table_auto(p_table => 'acc_over_deal',
                               p_delete => false,
                               p_column_replace => 'acc,"rukey(acc)",acco,"ruuser(acco)"');
  end fill_acc_over_deal;

  procedure fill_fx_deal_ref
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('FX_DEAL_REF', false,'ref,"rukey(ref)"');
  end fill_fx_deal_ref;

  procedure fill_fx_in_mt
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('FX_IN_MT', false,'acc,"rukey(acc)"');
  end fill_fx_in_mt;

  procedure fill_forex_a
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('FOREX_A', false,'RNK,"rukey(RNK)",REFA,"rukey(REFA)",REFB,"rukey(REFB)",ACCA,"rukey(ACCA)",ACCB,"rukey(ACCB)"');
  end fill_forex_a;

  procedure fill_cc_trans_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'CC_TRANS_UPDATE';
    l_max_idupd   bars.cc_trans_update.idupd%type;
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
      --MGR_UTL.SYNC_TABLE_AUTO('cc_trans_update', false,'npp,"rukey(npp)",acc,"rukey(acc)",ref,"rukey(ref)",refp,"rukey(refp)",doneby,"ruuser(doneby)",idupd,"rukey(idupd)"');
    mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,npp
                         ,ref
                         ,acc
                         ,fdat
                         ,sv
                         ,sz
                         ,d_plan
                         ,d_fakt
                         ,dapp
                         ,refp
                         ,comm
                         ,id0
                         ,kf

                       )
                        SELECT 
                          rukey(idupd) as idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,ruuser(doneby) as doneby
                         ,rukey(npp) as npp
                         ,rukey(ref) as ref
                         ,rukey(acc) as acc
                         ,fdat
                         ,sv
                         ,sz
                         ,d_plan
                         ,d_fakt
                         ,dapp
                         ,rukey(refp) as refp
                         ,comm
                         ,id0
                        , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);     
    bc.home();
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cc_trans_update;
    --
    mgr_utl.reset_sequence('s_cctrans_update', l_max_idupd);
    
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.p_constraints_enable('CC_TRANS_UPDATE');
    --
  end fill_cc_trans_update;

  procedure fill_cc_trans
     is
     max_npp  bars.cc_trans.npp%type;
     begin
       
       
       select nvl(greatest(count(*), max(npp)), 0)+ 1 into max_npp from cc_trans;  
       --
       mgr_utl.reset_sequence('s_cc_trans', max_npp);
       
       MGR_UTL.SYNC_TABLE_AUTO('cc_trans', false,'npp,"s_cc_trans.nextval",acc,"rukey(acc)",ref,"rukey(ref)",refp,"rukey(refp)"');
  end fill_cc_trans;


  procedure fill_cc_trans_ref
     is
     begin
       MGR_UTL.SYNC_TABLE_AUTO('cc_trans_ref', false,'ref,"rukey(ref)"');
  end fill_cc_trans_ref;

  procedure fill_cc_tag
     is
     begin
       init();
       mgr_utl.sync_table(p_table => 'cc_tag',
                          p_stmt => 'insert into cc_tag(tag, name, tagtype, table_name, type, nsisqlwhere, edit_in_form, not_to_edit, code)
                                    select tag, name, tagtype, table_name, type, nsisqlwhere, edit_in_form, not_to_edit, code from '||pkf('cc_tag')||'
                                    where tag not in(select tag from bars.cc_tag)',
                          p_delete => false);
  end fill_cc_tag;

  procedure fill_cc_swtrace
   is
     begin
       MGR_UTL.SYNC_TABLE_AUTO('cc_swtrace', false,'rnk,"rukey(rnk)"');
  end fill_cc_swtrace;

   procedure fill_cc_svk
     is
     begin
       init();
       mgr_utl.sync_table(p_table => 'cc_svk',
                          p_stmt  => 'insert into cc_svk(id,
                                                         sfile,
                                                         name,
                                                         kom1,
                                                         insu_paw,
                                                         insu_cck,
                                                         insu_tit,
                                                         sum_note,
                                                         sum_rees,
                                                         prc_mito,
                                                         sum_bti,
                                                         komrk,
                                                         prc_pf,
                                                         insu_cv)
                                     select id,
                                            sfile,
                                            name,
                                            kom1,
                                            insu_paw,
                                            insu_cck,
                                            insu_tit,
                                            sum_note,
                                            sum_rees,
                                            prc_mito,
                                            sum_bti,
                                            komrk,
                                            prc_pf,
                                            insu_cv
                                     from '||pkf('CC_SVK')||'
                                     where sfile not in(select sfile from bars.cc_svk)',
                            p_delete => false);
  end fill_cc_svk;

  procedure fill_cc_sparam
     is
     begin
       MGR_UTL.SYNC_TABLE_AUTO('cc_sparam', false,'acc,"rukey(acc)"');
  end fill_cc_sparam;

  procedure fill_cc_source
     is
     begin
       init();
       mgr_utl.sync_table(p_table => 'cc_source',
                          p_stmt  => 'insert into cc_source(sour, name, s200, br, n_mon, ir_max)
                                     select sour, name, s200, br, n_mon, ir_max
                                     from '||pkf('CC_SOURCE')||'
                                     where sour not in(select sour from bars.cc_source)',
                          p_delete => false);
  end fill_cc_source;

  procedure fill_cc_sob_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
     is
     l_tab         VARCHAR2(30) DEFAULT 'CC_SOB_UPDATE';
     l_max_idupd   bars.CC_SOB_UPDATE.idupd%type;
     begin
     --      
     l_max_idupd := get_max_idupd(l_tab);
     --
       --MGR_UTL.SYNC_TABLE_AUTO('cc_sob_update', false,'nd,"rukey(nd)",isp,"ruuser(isp)",id,"rukey(id)",doneby,"ruuser(doneby)",idupd,"rukey(idupd)"');
     mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( nd
                        ,fdat
                        ,id
                        ,isp
                        ,txt
                        ,otm
                        ,freq
                        ,psys
                        ,chgdate
                        ,chgaction
                        ,doneby
                        ,idupd
                        ,kf
                        ,fact_date

                       )
                        SELECT 
                          rukey(nd) as nd
                        ,fdat
                        ,rukey(id) as id
                        ,ruuser(isp) as isp
                        ,txt
                        ,otm
                        ,freq
                        ,psys
                        ,chgdate
                        ,chgaction
                        ,ruuser(doneby) as doneby
                        ,rukey(idupd) as idupd
                        , '''||g_kf||''' as kf 
                        ,fact_date
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);     --
     bc.home();
     --
     select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cc_sob_update;

     mgr_utl.reset_sequence('s_cc_sob_update', l_max_idupd);
     --
     mgr_utl.enable_table_triggers(l_tab);
     mgr_utl.enable_foreign_keys(l_tab);
     mgr_utl.p_constraints_enable(l_tab);
  end fill_cc_sob_update;

  procedure fill_cc_sob
     is
     begin
       MGR_UTL.SYNC_TABLE_AUTO('cc_sob', false,'nd,"rukey(nd)",isp,"ruuser(isp)"');
  end fill_cc_sob;

  procedure fill_cc_sec
     is
     begin
       init();
       mgr_utl.sync_table(p_table => 'cc_sec',
                          p_stmt  => 'insert into cc_sec(okpo, notesec)
                                     select okpo, notesec
                                     from '||pkf('cc_sec')||'
                                     where okpo not in(select okpo from bars.cc_sec)',
                          p_delete => false);
  end fill_cc_sec;

  procedure fill_cc_refv
     is
     begin
       MGR_UTL.SYNC_TABLE_AUTO('cc_refv', false,'nd,"rukey(nd)",ref,"rukey(ref)"');
  end fill_cc_refv;

  procedure fill_cc_raz_komis_tarif
     is
     begin
       mgr_utl.sync_table_auto(p_table => 'cc_raz_komis_tarif', p_delete =>false);
  end fill_cc_raz_komis_tarif;

  procedure fill_cc_prol
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('cc_prol', false,'nd,"rukey(nd)",acc,"rukey(acc)"');
  end fill_cc_prol;

  procedure fill_cc_peny_start
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CC_PENY_START', false,'nd,"rukey(nd)",acc,"rukey(acc)",acc_sn8,"rukey(acc_sn8)"');
  end fill_cc_peny_start;

  procedure fill_cc_overdue_dates
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CC_OVERDUE_DATES', false,'nd,"rukey(nd)"');
  end fill_cc_overdue_dates;

  procedure fill_cc_many
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('cc_many', false,'nd,"rukey(nd)"');
  end fill_cc_many;

  procedure fill_cc_lim_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'CC_LIM_UPDATE';
    l_max_idupd   bars.CC_LIM_UPDATE.idupd%type;
    begin
      --
      init();
      --
      bpa.disable_policies('CC_LIM_UPDATE');
      --      
      l_max_idupd := get_max_idupd(l_tab);
      --
      mgr_utl.sync_table(p_table => l_tab,
                         p_stmt  => 'insert into '||l_tab||'(idupd, chgaction, effectdate, chgdate, doneby, nd, fdat, lim2, acc, not_9129, sumg, sumo, otm, kf, sumk, not_sn)
                                     select rukey(idupd) as idupd, chgaction, effectdate, chgdate, ruuser(doneby) as doneby,
                                            rukey(nd) as nd, fdat, lim2, rukey(acc) as acc, not_9129, sumg, sumo, otm, '''||g_kf||''' as kf, sumk, not_sn
                                     from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         p_delete => false);
      --
      bc.home();
      --
      select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cc_lim_update;
      --
      mgr_utl.reset_sequence('s_cclim_update', l_max_idupd);
      --
      bpa.enable_policies('CC_LIM_UPDATE');
      --
  end fill_cc_lim_update;

  procedure fill_cc_lim_arc
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CC_LIM_ARC', false,'nd,"rukey(nd)",acc,"rukey(acc)"');
  end fill_cc_lim_arc;

  procedure fill_cc_lim
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CC_LIM', false,'nd,"rukey(nd)",acc,"rukey(acc)"');
  end fill_cc_lim;

  procedure fill_cc_docs
    is
    l_tab         VARCHAR2(30) DEFAULT 'CC_DOCS';
    l_max_nd   bars.CC_DOCS.nd%type;
    begin
      ----execute immediate 'ALTER SESSION FORCE parallel DML parallel 8';
      ----execute immediate 'ALTER SESSION FORCE parallel QUERY parallel 8';
      
     --
     select trunc(nvl(max(nd / 100), 0)) + 1 
       into l_max_nd
       from bars.CC_DOCS
      where kf = G_KF;  
     --
     mgr_utl.sync_table(p_table => l_tab,
                         p_stmt => 'insert /*+ APPEND */ into '||l_tab||'(id, nd, adds, version, state, text, comm, doneby)
                                    select id, rukey(nd), adds, version, state, to_clob(to_nclob(text)), comm, ruuser(doneby)
                                      from '||PKF(l_tab)||' where nd >= '||l_max_nd,
                       p_delete => false);
       ----execute immediate 'ALTER SESSION DISABLE parallel DML';
       ----execute immediate 'ALTER SESSION DISABLE parallel QUERY';
  end fill_cc_docs;
  
  procedure fill_cc_deal_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'CC_DEAL_UPDATE';
    l_max_idupd   bars.CC_DEAL_UPDATE.idupd%type;
    begin
     --
     init();
     --
     bpa.disable_policies(l_tab);
     --
     --      
     l_max_idupd := get_max_idupd(l_tab);
     --
     mgr_utl.sync_table(l_tab,
                         'INSERT INTO '||l_tab||' (idupd, chgaction, effectdate, chgdate, doneby, nd, sos, cc_id, sdate, wdate, rnk, vidd, limit, kprolog, user_id,
                                                     obs, branch, kf, ir, prod, sdog, skarb_id, fin, ndi, fin23, obs23, kat23, k23, kol_sp, s250, grp)
                               SELECT rukey(idupd) as idupd, chgaction, effectdate, chgdate, ruuser(doneby) as doneby, rukey(nd) as nd, sos, cc_id, sdate, wdate, rukey(rnk) as rnk, vidd, limit, kprolog, rukey(user_id) as user_id,
                                      obs, branch, kf, ir, prod, sdog, skarb_id, fin, rukey(ndi) as ndi, fin23, obs23, kat23, k23, kol_sp, s250, grp
                               FROM ' ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd, false);
     --
     bc.home();
     --
     select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cc_deal_update;
     --
     mgr_utl.reset_sequence('s_ccdeal_update', l_max_idupd);
     --
     bpa.enable_policies('CC_DEAL_UPDATE');
     --
  end fill_cc_deal_update;

  procedure fill_cc_add_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
     is
     l_tab         VARCHAR2(30) DEFAULT 'CC_ADD_UPDATE';
     l_max_idupd   bars.CC_ADD_UPDATE.idupd%type;
     begin
        bpa.disable_policies(l_tab);
        --MGR_UTL.SYNC_TABLE_AUTO('CC_ADD_UPDATE', false,'nd,"rukey(nd)",doneby,"ruuser(doneby)",idupd,"rukey(idupd)",accs,"rukey(accs)",accp,"rukey(accp)"');
        --      
        l_max_idupd := get_max_idupd(l_tab);
        --
        mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,nd
                         ,adds
                         ,aim
                         ,s
                         ,kv
                         ,bdate
                         ,wdate
                         ,accs
                         ,accp
                         ,sour
                         ,acckred
                         ,mfokred
                         ,freq
                         ,pdate
                         ,refv
                         ,refp
                         ,accperc
                         ,mfoperc
                         ,swi_bic
                         ,swi_acc
                         ,swi_ref
                         ,swo_bic
                         ,swo_acc
                         ,swo_ref
                         ,int_amount
                         ,alt_partyb
                         ,interm_b
                         ,int_partya
                         ,int_partyb
                         ,int_interma
                         ,int_intermb
                         ,ssuda
                         ,kf
                         ,okpokred
                         ,namkred
                         ,naznkred
                         ,nls_1819
                         ,field_58d
                       )
                        SELECT 
                         rukey(idupd) as idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,ruuser(doneby) as doneby
                         ,rukey(nd) as nd
                         ,adds
                         ,aim
                         ,s
                         ,kv
                         ,bdate
                         ,wdate
                         ,rukey(accs) as accs
                         ,rukey(accp) as accp
                         ,sour
                         ,acckred
                         ,mfokred
                         ,freq
                         ,pdate
                         ,refv
                         ,refp
                         ,accperc
                         ,mfoperc
                         ,swi_bic
                         ,swi_acc
                         ,swi_ref
                         ,swo_bic
                         ,swo_acc
                         ,swo_ref
                         ,int_amount
                         ,alt_partyb
                         ,interm_b
                         ,int_partya
                         ,int_partyb
                         ,int_interma
                         ,int_intermb
                         ,ssuda
                         , '''||g_kf||''' as kf 
                         ,okpokred
                         ,namkred
                         ,naznkred
                         ,nls_1819
                         ,field_58d
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
        bc.home();
        --
        select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cc_add_update;
        --
        mgr_utl.reset_sequence('s_cc_add_update', l_max_idupd);
        --
        mgr_utl.enable_table_triggers(l_tab);
        mgr_utl.enable_foreign_keys(l_tab);
        mgr_utl.p_constraints_enable(l_tab);
        bpa.enable_policies(l_tab);
  end fill_cc_add_update;

  procedure fill_cc_accp
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'CC_ACCP';
    begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('CC_ACCP',
                         'insert into  BARS.CC_ACCP(acc, accs, nd, pr_12, idz, kf, mpawn, pawn, rnk)
                         select rukey(acc) as acc, rukey(accs) as accs, rukey(nd) as nd, pr_12,
                                ruuser(idz) as idz, '''||g_kf||''' as kf, mpawn, pawn, rukey(rnk) as rnk
                         from ' ||pkf('CC_ACCP')||' log errors reject limit unlimited',
                         false);
  --
  trace('%s', get_errinfo('ERR$_'||l_tab));
  --
  end fill_cc_accp;

  procedure fill_cc_accp_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    p                        constant varchar2(62) := G_PKG||'.fill_cc_accp_update';
    l_tab                    VARCHAR2(50) DEFAULT 'CC_ACCP_UPDATE';
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 50000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_max_sqnc               cc_accp_update.idupd%TYPE;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);

    /* "Exceptions encountered in FORALL" exception... */
    bulk_exceptions   EXCEPTION;
    PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_cur_cc_accp_update IS TABLE OF cc_accp_update%ROWTYPE;

    vv_cur_cc_accp_update t_cur_cc_accp_update;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging_cc_accp_update IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_CC_ACCP_UPDATE%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).rnk                    := vv_cur_cc_accp_update (v_indx).rnk;
         v_cur_exceptions (i).kf                     := vv_cur_cc_accp_update (v_indx).kf;
         v_cur_exceptions (i).effectdate             := vv_cur_cc_accp_update (v_indx).effectdate;
      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_CC_ACCP_UPDATE
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging_cc_accp_update;


    begin
      --
      trace('%s: entry point', p);
      --
      mgr_utl.before_fill(l_tab);
      --
      mgr_utl.mantain_error_table(l_tab);

         --execute immediate 'ALTER INDEX xai_ccaccp_updateeffdat UNUSABLE';
         --execute immediate 'ALTER INDEX xai_ccaccp_updatepk UNUSABLE';

          BEGIN
          --      
          l_max_sqnc := get_max_idupd(l_tab);
          --
               OPEN l_cur FOR
                  'select
                      rukey(idupd) as idupd
                     ,chgaction
                     ,effectdate
                     ,chgdate
                     ,ruuser(doneby) as doneby
                     ,rukey(acc) as acc
                     ,rukey(accs) as accs
                     ,rukey(nd) as nd
                     ,pr_12
                     ,idz
                     ,'''||g_kf||''' as kf
                     ,null as mpawn
                     --,mpawn
                     ,null as pawn
                     --,pawn
                     ,null as rnk
                     --,rukey(rnk) as rnk
                   from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_sqnc;
                      --
               LOOP
                 FETCH l_cur BULK COLLECT INTO vv_cur_cc_accp_update LIMIT c_limit;
                   EXIT WHEN vv_cur_cc_accp_update.COUNT = 0;

               BEGIN
                FORALL indx IN INDICES OF vv_cur_cc_accp_update SAVE EXCEPTIONS
                  INSERT INTO bars.cc_accp_update
                                            VALUES vv_cur_cc_accp_update(indx);

                EXCEPTION
                       WHEN bulk_exceptions THEN
                          c_n := c_n + SQL%ROWCOUNT;
                          error_logging_cc_accp_update ();
               END;
                COMMIT;
                  v_count := v_count + c_limit;
                dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
                dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

               END LOOP;
               l_rowcount := l_cur%rowcount;
               CLOSE l_cur;
               l_end_time := current_timestamp;
               l_time_duration:= (l_end_time - l_start_time);
               mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
               -- Clear collection for vv_cur_cc_accp_update
              vv_cur_cc_accp_update.delete;
         END;
    --
   --
   bc.home();
   --
   select trunc(nvl(max(idupd / 100), 0)) + 1  into l_max_sqnc  from bars.cc_accp_update;

   mgr_utl.reset_sequence('S_CCACCP_UPDATE', l_max_sqnc);
   --
    --
    --execute immediate 'ALTER INDEX xai_ccaccp_updateeffdat REBUILD';
    --execute immediate 'ALTER INDEX xai_ccaccp_updatepk REBUILD';

   mgr_utl.finalize();
   --
   trace('%s: finished', p);

  end fill_cc_accp_update;

  procedure fill_cc_989917_ref
     is
     begin
       init();
       mgr_utl.sync_table(p_table => 'CC_989917_REF',
                          p_stmt => 'insert into cc_989917_ref(ref1, ref2, acc, branch, kf)
                                     select rukey(ref1) as ref1, rukey(ref2) as ref2, rukey(acc) as acc, branch, kf
                                     from '||pkf('cc_989917_ref'),
                          p_delete => false);
  end fill_cc_989917_ref;

  procedure fill_cck_sum_pog
     is
     begin
       MGR_UTL.SYNC_TABLE_AUTO('CCK_SUM_POG', false,'USER_ID,"ruuser(USER_ID)"');
  end fill_cck_sum_pog;

  procedure fill_cck_restr_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'CCK_RESTR_UPDATE';
    l_max_idupd   bars.CCK_RESTR_UPDATE.idupd%type;
    begin
      --      
      l_max_idupd := get_max_idupd(l_tab);
      --
      --MGR_UTL.SYNC_TABLE_AUTO('CCK_RESTR_UPDATE', false,'nd,"rukey(nd)",rnk,"rukey(rnk)",doneby,"ruuser(doneby)",idupd,"rukey(idupd)"');
      --Поля rnk,"rukey(rnk)" нету в таблице
      mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,restr_id
                         ,nd
                         ,fdat
                         ,vid_restr
                         ,txt
                         ,sumr
                         ,fdat_end
                         ,pr_no
                         ,s_restr
                         ,n_dodatok
                         ,qty_pay
                         ,kf

                       )
                        SELECT 
                         rukey(idupd) as idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,ruuser(doneby) as doneby
                         ,restr_id
                         ,rukey(nd) as nd
                         ,fdat
                         ,vid_restr
                         ,txt
                         ,sumr
                         ,fdat_end
                         ,pr_no
                         ,s_restr
                         ,n_dodatok
                         ,qty_pay
                         , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);      
      bc.home();
      --
      select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cck_restr_update;
      --
      mgr_utl.reset_sequence('s_cck_restr_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
  end fill_cck_restr_update;

  procedure fill_cck_restr_acc
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CCK_RESTR_ACC', false,'ACC,"rukey(ACC)"');
  end fill_cck_restr_acc;

  procedure fill_cck_restr
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CCK_RESTR', false,'nd,"rukey(nd)",rnk,"rukey(rnK)",restr_id,"rukey(restr_id)"');
  end fill_cck_restr;

  procedure fill_cck_isp_nls
    is
    begin
     init();
       bpa.disable_policies('CCK_ISP_NLS');
       mgr_utl.sync_table(p_table => 'CCK_ISP_NLS',
                          p_stmt => 'insert into cck_isp_nls(id, isp, ord, kf, branch)
                                     select rukey(id) as id, isp, ord, kf, branch
                                     from '||pkf('cck_isp_nls'),
                          p_delete => false);

      bpa.enable_policies('CCK_ISP_NLS');
  end fill_cck_isp_nls;

   procedure fill_cc_kol_sp
     is
     begin
       mgr_utl.sync_table_auto(p_table => 'cc_kol_sp', p_delete => false, p_column_replace => 'nd,"rukey(nd)",rnk,"rukey(rnk)"');
       end fill_cc_kol_sp;

  procedure fill_cc_grt_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'CC_GRT_UPDATE';
    l_max_idupd   bars.cc_grt_update.idupd%type;
    begin
      bpa.disable_policies('cc_grt_update');
      --
      --mgr_utl.sync_table_auto(p_table => 'cc_grt_update', p_delete => false, p_column_replace => 'nd,"rukey(nd)",doneby,"ruuser(doneby)",idupd,"rukey(idupd)"');
      --      
      l_max_idupd := get_max_idupd(l_tab);
      --
      mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd, 
                         chgaction, 
                         effectdate, 
                         chgdate, 
                         doneby, 
                         nd, 
                         grt_deal_id, 
                         kf
                       )
                        SELECT 
                         rukey(idupd) as idupd, 
                         chgaction, 
                         effectdate, 
                         chgdate, 
                         ruuser(doneby) as doneby, 
                         rukey(nd) as nd, 
                         grt_deal_id 
                        , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);      
      bc.home();
      --
      select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.cc_grt_update;
      --
      mgr_utl.reset_sequence('s_ccgrt_update', l_max_idupd);
      --
      mgr_utl.enable_table_triggers(l_tab);
      mgr_utl.enable_foreign_keys(l_tab);
      mgr_utl.p_constraints_enable(l_tab);
      bpa.enable_policies(l_tab);
      --
  end fill_cc_grt_update;

  procedure fill_cc_grt
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'cc_grt', p_delete => false, p_column_replace => 'nd,"rukey(nd)"');
  end fill_cc_grt;

  procedure fill_inv_cck_fl
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'inv_cck_fl', p_delete => false, p_column_replace => 'acc,"rukey(acc)",rnk,"rukey(rnk)",acc2208,"rukey(acc2208)"');
  end fill_inv_cck_fl;

  procedure fill_inv_cck_fl_23
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'inv_cck_fl_23', p_delete => false, p_column_replace => 'acc,"rukey(acc)",rnk,"rukey(rnk)",acc2208,"rukey(acc2208)",acc2209,"rukey(acc2209)",acc9129,"rukey(acc9129)"');
  end fill_inv_cck_fl_23;


  procedure fill_inv_cck_fl_bpkk
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'inv_cck_fl_bpkk', p_delete => false, p_column_replace => 'acc,"rukey(acc)",rnk,"rukey(rnk)"');
  end fill_inv_cck_fl_bpkk;

    procedure fill_inv_cck_fl_bpkk_23
    is
    begin
      mgr_utl.sync_table_auto(p_table => 'inv_cck_fl_bpkk_23', p_delete => false, p_column_replace => 'acc,"rukey(acc)",rnk,"rukey(rnk)"');
      end fill_inv_cck_fl_bpkk_23;


   procedure fill_acc_tarif_arc
      is
        p                       constant varchar2(62) := G_PKG||'.fill_acc_tarif_arc';
        l_clear_flag            boolean default true;
        l_last_id               integer;
        l_tab                    varchar2(30) default 'ACC_TARIF_ARC';


     begin
      trace('%s: entry point', p);

      bars_policy_adm.disable_policies(l_tab);
      --
      bc.go(g_kf);
      --
      mgr_utl.before_fill(l_tab);

       begin
        if (l_clear_flag) then
              execute_statement(
                  'delete acc_tarif_arc a
                   where a.kf = ''' || g_kf || '''',
                  'Очистка значень з acc_tarif_arc для МФО: '||' таблиця '||l_tab, null, 'N');
        end if;

          execute_statement(
              'insert into acc_tarif_arc (acc, kod, tar, pr, smin, smax, fdat, user_id, vid, bdate, edate, idupd, kf, ost_avg, ndok_rko, kv_smin, kv_smax, global_bdate, effectdate)
               select getnewacc(''' || g_kf || ''',acc), kod, tar, pr, smin, smax, fdat, getnewuserid(''' || g_kf || ''',user_id),
                                vid, bdate, edate, rukey(idupd), ''' || g_kf || ''', ost_avg, ndok_rko, kv_smin, kv_smax, global_bdate, effectdate
               from ' || pkf('acc_tarif_arc')||' log errors reject limit unlimited',
               'Завантаження архіву тарифів'||' таблиця '||l_tab);
       end;
        --
    exception when others then
        rollback;
        mgr_utl.save_error();
    --
    bc.home();
    --
    select trunc(nvl(max(t.idupd / 100), 0)) + 1 into l_last_id from acc_tarif_arc t;
    --
    mgr_utl.reset_sequence('s_acc_tarif_arc', l_last_id);
    --
    mgr_utl.finalize();
    --
    bars_policy_adm.enable_policies(l_tab);
    --
    trace('%s: finished', p);
    --
  end fill_acc_tarif_arc;

  procedure fill_sh_tarif
    is
    l_tab     VARCHAR2(30) DEFAULT 'SH_TARIF';

    begin
    init();
       bpa.disable_policies(l_tab);
       mgr_utl.sync_table(p_table => 'SH_TARIF',
                          p_stmt => 'insert into SH_TARIF(ids, kod, tar, pr, smin, smax, kf, nbs_ob22)
                                     select ids, kod, tar, pr, smin, smax, kf, nbs_ob22
                                     from '||pkf('sh_tarif'),
                          p_delete => false);
       bpa.enable_policies(l_tab);

  end fill_sh_tarif;

  procedure fill_sh_tarif_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab         VARCHAR2(30) DEFAULT 'SH_TARIF_UPDATE';
    l_max_idupd   bars.SH_TARIF_UPDATE.idupd%type;

    begin
    --bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table(l_tab,
                        'INSERT INTO '||l_tab||'
                        SELECT rukey(idupd) as idupd, chgaction, chgdate, global_bdate, effectdate, ruuser(doneby) as doneby,
                               ids, kod, tar, pr, smin, smax, '''||g_kf||''' as kf, nbs_ob22
                        FROM '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                        false);
    --
    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.sh_tarif_update;
    --
    mgr_utl.reset_sequence('s_shtarif_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    --bpa.enable_policies(l_tab);
    --
  end fill_sh_tarif_update;

  procedure fill_tarif
      is
        p   constant varchar2(62) := G_PKG||'.fill_tarif';
        l_clear_flag boolean default true;
        l_tab         varchar2(30) default 'TARIF';

       begin
        trace('%s: entry point', p);
        --
        bc.go(g_kf);
        --
        mgr_utl.before_fill(l_tab);
        --
        bpa.disable_policies(l_tab);

       begin
         if (l_clear_flag) then
        execute_statement(
              'delete tarif a
               where a.kf = ''' || g_kf || '''',
              'Очистка значень з tarif для МФО: ' || g_kf ||' таблиця '||l_tab, null, 'N');
         end if;

          execute_statement(
              'insert into tarif (kod, kv, name, tar, pr, smin, smax, tip, nbs, ob22, pdv, razova, dat_begin, dat_end, kv_smin, kv_smax, kf)
               select kod, kv, name, tar, pr, smin, smax, tip, nbs, ob22, pdv, razova, dat_begin, dat_end, kv_smin, kv_smax, kf
               from ' || pkf('tarif') || '
               where kf = ''' || g_kf || '''',
               'Завантаження тарифів'||' таблиця '||l_tab);
      end;
            --
        exception when others then
            rollback;
            mgr_utl.save_error();

        bc.home();
        --
        mgr_utl.finalize();
        --
        bpa.enable_policies(l_tab);
        --
        trace('%s: finished', p);
    --
  end fill_tarif;

  procedure fill_tarif_scale
      is
        p   constant varchar2(62) := G_PKG||'.fill_tarif_scale';
        l_clear_flag boolean default true;
        l_tab         varchar2(30) default 'TARIF_SCALE';

       begin
        trace('%s: entry point', p);
        --
        bc.go(g_kf);
        --
        mgr_utl.before_fill(l_tab);

       begin
          if (l_clear_flag) then
        execute_statement(
              'delete tarif_scale a
               where kf = ''' || g_kf || '''',
              'Очистка значень з tarif_scale для МФО: ' || g_kf ||' таблиця '||l_tab, null, 'N');
         end if;

         execute_statement(
            'insert into tarif_scale (kod, sum_limit, sum_tarif, pr, smin, smax, kf)
             select kod, sum_limit, sum_tarif, pr, smin, smax, kf from ' || pkf('tarif_scale') ||
           ' where  kf = ''' || g_kf || '''',
            'Оновлення значень в tarif_scale для МФО: ' || g_kf||' таблиця '||l_tab);
        end;
            --
        exception when others then
            rollback;
            mgr_utl.save_error();

        bc.home();
        --
        mgr_utl.finalize();
        --
        trace('%s: finished', p);
    --
  end fill_tarif_scale;

    procedure fill_tarif_history
    is
    l_tab     VARCHAR2(30) DEFAULT 'TARIF_HISTORY';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_tarif_history;

  procedure fill_tarif_scheme_accbranch
    is
    l_tab     VARCHAR2(30) DEFAULT 'TARIF_SCHEME_ACCBRANCH';

    begin
    init();
       bpa.disable_policies(l_tab);
       mgr_utl.sync_table(p_table => 'TARIF_SCHEME_ACCBRANCH',
                          p_stmt => 'insert into TARIF_SCHEME_ACCBRANCH(id, branch, dat_begin, dat_end)
                                     select id, branch, dat_begin, dat_end
                                     from '||pkf('TARIF_SCHEME_ACCBRANCH')||' where (id, branch) not in (select id, branch from bars.tarif_scheme_accbranch)',
                          p_delete => false);
       bpa.enable_policies(l_tab);

  end fill_tarif_scheme_accbranch;

 -----------------------CIM---------------------------------------------
  procedure fill_cim_1pb_out_doc
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_1PB_OUT_DOC',false,'REF_CA,"rukey(REF_CA)"');
  end fill_cim_1pb_out_doc;

  procedure fill_cim_1pb_ru_doc
     is
     begin
       init();
       mgr_utl.sync_table(p_table => 'cim_1pb_ru_doc',
                          p_stmt => 'insert into cim_1pb_ru_doc(ref, ref_ca, kf, ref_ru, vdat, kv, s, nam_a, mfoa, mfob, nlsa,
                                                                nlsb, nazn_ru, kod_n_ca, kod_n_ru, changed, cl_type, cl_ipn, cl_name, md)
                                    select ref, ref_ca, kf, ref_ru, vdat, kv, s, nam_a, mfoa, mfob, nlsa,
                                           nlsb, nazn_ru, kod_n_ca, kod_n_ru, changed, cl_type, cl_ipn, cl_name, md
                                    from '||pkf('cim_1pb_ru_doc')||'
                                    where kf not in(select kf from bars.cim_1pb_ru_doc)',
                          p_delete => false);
  end fill_cim_1pb_ru_doc;

  procedure fill_cim_acts
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_ACTS',false,'ACT_ID,"rukey(ACT_ID)",RNK,"rukey(RNK)",BENEF_ID,"rukey(BENEF_ID)"');
  end fill_cim_acts;

  procedure fill_cim_act_bound
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_ACT_BOUND',false,'ACT_ID,"rukey(ACT_ID)",BOUND_ID,"rukey(BOUND_ID)",CONTR_ID,"rukey(CONTR_ID)",UID_DEL_BOUND,"ruuser(UID_DEL_BOUND)",UID_DEL_JOURNAL,"ruuser(UID_DEL_JOURNAL)"');
  end fill_cim_act_bound;

  procedure fill_cim_ape_link
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_APE_LINK',false,'PAYMENT_ID,"rukey(PAYMENT_ID)",FANTOM_ID,"rukey(FANTOM_ID)",APE_ID,"rukey(APE_ID)",DELETE_UID,"ruuser(DELETE_UID)"');
  end fill_cim_ape_link;

  procedure fill_cim_beneficiaries
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_BENEFICIARIES',false,'BENEF_ID,"rukey(BENEF_ID)"');
  end fill_cim_beneficiaries;

  procedure fill_cim_borg_message
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_BORG_MESSAGE',false,'ID,"rukey(ID)",RNK,"rukey(RNK)",DELETE_UID,"ruuser(DELETE_UID)",BOUND_ID,"rukey(BOUND_ID)"');
  end fill_cim_borg_message;

  procedure fill_cim_bound_data
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_BOUND_DATA',false,'BENEF_ID,"rukey(BENEF_ID)",RNK,"rukey(RNK)",BOUND_ID,"rukey(BOUND_ID)"');
  end fill_cim_bound_data;

  procedure fill_cim_conclusion
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CONCLUSION',false,'ID,"rukey(ID)",CONTR_ID,"rukey(CONTR_ID)",DELETE_UID,"ruuser(DELETE_UID)",CREATE_UID,"ruuser(CREATE_UID)"');
  end fill_cim_conclusion;

  procedure fill_cim_conclusion_link
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CONCLUSION_LINK',false,'CNC_ID,"rukey(CNC_ID)",PAYMENT_ID,"rukey(PAYMENT_ID)",FANTOM_ID,"rukey(FANTOM_ID)",VMD_ID,"rukey(VMD_ID)",ACT_ID,"rukey(ACT_ID)",DELETE_UID,"ruuser(DELETE_UID)",CREATE_UID,"ruuser(CREATE_UID)"');
  end fill_cim_conclusion_link;

  procedure fill_cim_contracts
     is
     begin
       init();

       case when g_kf = g_glb_mfo then
            begin
            mgr_utl.sync_table_auto('CIM_CONTRACTS',false,'CONTR_ID,"rukey(CONTR_ID)",RNK,"rukey(RNK)",BENEF_ID,"rukey(BENEF_ID)",OWNER_UID,"ruuser(OWNER_UID)"');

            exception
               when others then
                    rollback;
                      mgr_utl.save_error();
            end;
       else
            begin
            mgr_utl.sync_table(p_table => 'cim_contracts',
                               p_stmt  => 'insert into cim_contracts(contr_id, contr_type, rnk, okpo, num, open_date, close_date, s, kv, benef_id,
                                                            status_id, branch, comments, subnum, owner_uid, bic, b010, service_branch, kf)
                                           select rukey(CONTR_ID) as contr_id, contr_type, rukey(RNK) as rnk, okpo, num, open_date, close_date, s, kv, rukey(BENEF_ID) as benef_id,
                                                  status_id, branch, comments, subnum, ruuser(OWNER_UID) as owner_uid, bic, b010, service_branch, '''||g_kf||''' as kf
                                           from '||pkf('cim_contracts')||'
                                           where CONTR_ID > 0',
                       p_delete => false);
            exception
              when others then
                   rollback;
                     mgr_utl.save_error();
            end;
             --
       end case;

  end fill_cim_contracts;

  procedure fill_cim_contracts_ape
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CONTRACTS_APE',false,'APE_ID,"rukey(APE_ID)",CONTR_ID,"rukey(CONTR_ID)",DELETE_UID,"ruuser(DELETE_UID)"');
  end fill_cim_contracts_ape;

  procedure fill_cim_contracts_credit
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CONTRACTS_CREDIT',false,'CONTR_ID,"rukey(CONTR_ID)"');
  end fill_cim_contracts_credit;

  procedure fill_cim_contracts_trade
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CONTRACTS_TRADE',false,'CONTR_ID,"rukey(CONTR_ID)"');
  end fill_cim_contracts_trade;

  procedure fill_cim_credgraph_payment
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CREDGRAPH_PAYMENT',false,'CONTR_ID,"rukey(CONTR_ID)"');
  end fill_cim_credgraph_payment;

  procedure fill_cim_credgraph_period
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CREDGRAPH_PERIOD',false,'CONTR_ID,"rukey(CONTR_ID)"');
  end fill_cim_credgraph_period;

  procedure fill_cim_customer_upd
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_CUSTOMER_UPD',false,'RNK,"rukey(RNK)"');
  end fill_cim_customer_upd;

  procedure fill_cim_fantoms_bound
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_FANTOMS_BOUND',false,'BOUND_ID,"rukey(BOUND_ID)",FANTOM_ID,"rukey(FANTOM_ID)",CONTR_ID,"rukey(CONTR_ID)",UID_DEL_BOUND,"ruuser(UID_DEL_BOUND)",UID_DEL_JOURNAL,"ruuser(UID_DEL_JOURNAL)"');
  end fill_cim_fantoms_bound;

  procedure fill_cim_fantom_payments
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_FANTOM_PAYMENTS',false,'FANTOM_ID,"rukey(FANTOM_ID)",RNK,"rukey(RNK)",BENEF_ID,"rukey(BENEF_ID)"');
  end fill_cim_fantom_payments;

  procedure fill_cim_license
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_LICENSE',false,'LICENSE_ID,"rukey(LICENSE_ID)",DELETE_UID,"ruuser(DELETE_UID)"');
  end fill_cim_license;

  procedure fill_cim_license_link
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_LICENSE_LINK',false,'PAYMENT_ID,"rukey(PAYMENT_ID)",FANTOM_ID,"rukey(FANTOM_ID)",LICENSE_ID,"rukey(LICENSE_ID)",DELETE_UID,"ruuser(DELETE_UID)",CREATE_UID,"ruuser(CREATE_UID)"');
  end fill_cim_license_link;

  procedure fill_cim_link
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_LINK',false,'PAYMENT_ID,"rukey(PAYMENT_ID)",FANTOM_ID,"rukey(FANTOM_ID)",VMD_ID,"rukey(VMD_ID)",ACT_ID,"rukey(ACT_ID)",UID_DEL_JOURNAL,"ruuser(UID_DEL_JOURNAL)",ID,"rukey(ID)"');
  end fill_cim_link;

  procedure fill_cim_params
     is
     l_tab  varchar2(30) default 'CIM_PARAMS';
     begin
       init();
       mgr_utl.sync_table(p_table => 'cim_params',
                           p_stmt => 'insert into cim_params(par_name, par_value, par_comment, global, kf)
                                     select par_name, par_value, par_comment, global, '''||g_kf||''' as kf
                                     from '||pkf('cim_params')||'
                                     where par_name <> ''SERVICE_URL''
                                     ',
                           p_delete => false);
  end fill_cim_params;

  procedure fill_cim_payments_bound
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_PAYMENTS_BOUND',false,'BOUND_ID,"rukey(BOUND_ID)",REF,"rukey(REF)",CONTR_ID,"rukey(CONTR_ID)",UID_DEL_BOUND,"ruuser(UID_DEL_BOUND)",UID_DEL_JOURNAL,"ruuser(UID_DEL_JOURNAL)"');
  end fill_cim_payments_bound;

  procedure fill_cim_unheld_que
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_UNHELD_QUE',false,'BOUND_ID,"rukey(BOUND_ID)",REF,"rukey(REF)",CONTR_ID,"rukey(CONTR_ID)"');
  end fill_cim_unheld_que;

  procedure fill_cim_vmd_bound
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_VMD_BOUND',false,'BOUND_ID,"rukey(BOUND_ID)",VMD_ID,"rukey(VMD_ID)",CONTR_ID,"rukey(CONTR_ID)",UID_DEL_BOUND,"ruuser(UID_DEL_BOUND)",UID_DEL_JOURNAL,"ruuser(UID_DEL_JOURNAL)"');
  end fill_cim_vmd_bound;

  procedure fill_cim_vmd_bound_data
    is
    begin
      MGR_UTL.SYNC_TABLE_AUTO('CIM_VMD_BOUND_DATA',false,'BOUND_ID,"rukey(BOUND_ID)",RNK,"rukey(RNK)",BENEF_ID,"rukey(BENEF_ID)"');
  end fill_cim_vmd_bound_data;

  procedure fill_customs_decl
    is
    begin
      MGR_UTL.SYNC_TABLE('CUSTOMS_DECL','
      insert into CUSTOMS_DECL
                                     select fn, 
                                            dat, 
                                            n, 
                                            len, 
                                            cdat, 
                                            isnull, 
                                            ndat, 
                                            mdat, 
                                            ctype, 
                                            cnum_cst, 
                                            cnum_year, 
                                            cnum_num, 
                                            mvm_feat, 
                                            s_okpo, 
                                            s_name, 
                                            s_adres, 
                                            s_type, 
                                            s_taxid, 
                                            r_okpo, 
                                            r_name, 
                                            r_adres, 
                                            r_type, 
                                            r_taxid, 
                                            f_okpo, 
                                            f_name, 
                                            f_adres, 
                                            f_type, 
                                            f_taxid, 
                                            f_country, 
                                            uah_nls, 
                                            uah_mfo, 
                                            ccy_nls, 
                                            ccy_mfo, 
                                            kv, 
                                            kurs, 
                                            s, 
                                            allow_dat, 
                                            cmode_code, 
                                            reserv, 
                                            doc, 
                                            sdate, 
                                            fdate, 
                                            sign_key, 
                                            sign, 
                                            character, 
                                            reserve2, 
                                            fl_eik, 
                                            idt, 
                                            datj, 
                                            '''||g_kf||''' as kf, 
                                            rukey(CIM_ID) as CIM_ID, 
                                            cim_branch, 
                                            cim_date, 
                                            cim_boundsum, 
                                            cim_original
                                     from '||pkf('CUSTOMS_DECL')||' log errors reject limit unlimited
       ',false);
  end fill_customs_decl;

  procedure  cim_reset_sqnc
    is
      l_max_act_id         number;
      l_max_bound_id       number;
      l_max_benef_id       number;
      l_max_id             number;
      l_max_cnc_id         number;
      l_max_contr_id       number;
      l_max_ape_id         number;
      l_max_fbound_id      number;
      l_max_fantom_id      number;
      l_max_license_id     number;
      l_max_link_id        number;
      l_max_pbound_id      number;
      l_max_vbound_id      number;
      l_max_cim_id         number;

  begin
  --
  bc.home;
  --
  select trunc(nvl(max(act_id / 100), 0)) + 1
    into l_max_act_id
    from cim_acts;

  select trunc(nvl(max(bound_id / 100), 0)) + 1
    into l_max_bound_id
    from cim_act_bound;

  select trunc(nvl(max(benef_id / 100), 0)) + 1
    into l_max_benef_id
    from cim_beneficiaries;

  select trunc(nvl(max(id / 100), 0)) + 1
    into l_max_id
    from cim_borg_message;

  select trunc(nvl(max(id / 100), 0)) + 1
    into l_max_cnc_id
    from cim_conclusion;

  select trunc(nvl(max(contr_id / 100), 0)) + 1
    into l_max_contr_id
    from cim_contracts;

  select trunc(nvl(max(ape_id / 100), 0)) + 1
    into l_max_ape_id
    from cim_contracts_ape;

  select trunc(nvl(max(bound_id / 100), 0)) + 1
    into l_max_fbound_id
    from cim_fantoms_bound;

  select trunc(nvl(max(fantom_id / 100), 0)) + 1
    into l_max_fantom_id
    from cim_fantom_payments;

  select trunc(nvl(max(license_id / 100), 0)) + 1
    into l_max_license_id
    from cim_license;

  select trunc(nvl(max(id / 100), 0)) + 1
    into l_max_link_id
    from cim_link;

  select trunc(nvl(max(bound_id / 100), 0)) + 1
    into l_max_pbound_id
    from cim_payments_bound;

  select trunc(nvl(max(bound_id / 100), 0)) + 1
    into l_max_vbound_id
    from cim_vmd_bound;

  select trunc(nvl(max(cim_id / 100), 0)) + 1
    into l_max_cim_id
    from customs_decl;
  --
  bc.go(g_kf);
  --
      mgr_utl.reset_sequence('S_CIM_ACTS'              ,l_max_act_id);
      mgr_utl.reset_sequence('S_CIM_ACT_BOUND'         ,l_max_bound_id);
      mgr_utl.reset_sequence('S_CIM_BENEFICIARIES'     ,l_max_benef_id);
      mgr_utl.reset_sequence('S_CIM_BORG_MESSAGE'      ,l_max_id);
      mgr_utl.reset_sequence('S_CIM_CONCLUSION'        ,l_max_cnc_id);
      mgr_utl.reset_sequence('S_CIM_CONTRACTS'         ,l_max_contr_id);
      mgr_utl.reset_sequence('S_CIM_CONTRACTS_APE'     ,l_max_ape_id);
      mgr_utl.reset_sequence('S_CIM_FANTOMS_BOUND'     ,l_max_fbound_id);
      mgr_utl.reset_sequence('S_CIM_FANTOM_PAYMENTS'   ,l_max_fantom_id);
      mgr_utl.reset_sequence('S_CIM_LICENSE'           ,l_max_license_id);
      mgr_utl.reset_sequence('S_CIM_LINK'              ,l_max_link_id);
      mgr_utl.reset_sequence('S_CIM_PAYMENTS_BOUND'    ,l_max_pbound_id);
      mgr_utl.reset_sequence('S_CIM_VMD_BOUND'         ,l_max_vbound_id);
      mgr_utl.reset_sequence('S_CIM_VMD_ID'            ,l_max_cim_id);
  --
  end cim_reset_sqnc;

---------------------------------------------------------------------------------
  procedure fill_v_rez_bpk
    is
    begin
       init();
       mgr_utl.sync_table(p_table => 'V_REZ_BPK',
                          p_stmt => 'insert into V_REZ_BPK(fdat, tobo, bpk, rnk, nd, kv, nbs, acc, nls, fin, obs, kat, k, bv, bvq, pv, pvq, rez, rezq, zal, zalq, dat_s, kf, branch)
                                    select fdat, tobo, bpk, rukey(rnk) as rnk, rukey(nd) as nd, kv, nbs, rukey(acc) as acc, nls, fin, obs, kat, k, bv, bvq, pv, pvq, rez, rezq, zal, zalq, dat_s, '''||g_kf||''' as kf, tobo as branch
                                    from '||pkf('V_REZ_BPK'),
                          p_delete => false);
  end fill_v_rez_bpk;

  procedure fill_e_deal$base
    is
  l_tab                   VARCHAR2(30 CHAR) DEFAULT 'E_DEAL$BASE';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('E_DEAL$BASE',
                         'insert into  BARS.E_DEAL$BASE(nd, rnk, sos, cc_id, sdate, wdate, user_id, sa, kf, acc26, acc36, accd, accp, ndi)
                         select rukey(nd) as nd, rukey(rnk) as rnk, sos, cc_id, sdate, wdate, ruuser(user_id) as user_id, sa, '''||g_kf||''' as kf,
                                rukey(acc26) as acc26, rukey(acc36) as acc36, rukey(accd) as accd, rukey(accp) as accp, rukey(ndi) as ndi
                         from ' ||pkf('E_DEAL$BASE')||' log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_e_deal$base;

  procedure fill_otc_arc_cc_lim
    is
  l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTC_ARC_CC_LIM';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('OTC_ARC_CC_LIM',
                         'insert into  BARS.OTC_ARC_CC_LIM(dat_otc, nd, fdat, lim2, acc, sumg, sumo, kf)
                         select dat_otc, rukey(nd) as nd, fdat, lim2, rukey(acc) as acc, sumg, sumo, '''||g_kf||''' as kf
                         from ' ||pkf('OTC_ARC_CC_LIM')||' where dat_otc >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
     --
     trace('%s', get_errinfo('ERR$_'||l_tab));
     --
  end fill_otc_arc_cc_lim;

  procedure fill_otc_c5_proc
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTC_C5_PROC';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('OTC_C5_PROC',
                         'insert into  BARS.OTC_C5_PROC(datf, rnk, nd, acc, nls, kv, kodp, znap, kf)
                         select datf, rukey(rnk) as rnk, rukey(nd) as nd, rukey(acc) as acc, nls, kv, kodp, znap, '''||g_kf||''' as kf
                         from ' ||pkf('OTC_C5_PROC')||' where datf >= add_months(trunc(sysdate, ''MM''), - 1)
                         log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_otc_c5_proc;

  procedure fill_otc_c5_proc_dt(p_date date default null, p_date_end date default null)
    is
    l_tab                   VARCHAR2(30) DEFAULT 'otc_c5_proc';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_date                  DATE;
    l_date_end              DATE;


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_otc_c5_proc_row IS TABLE OF otc_c5_proc%ROWTYPE;
    v_curs t_otc_c5_proc_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_otc_c5_proc%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).datf                   := v_curs (v_indx).datf;
         v_cur_exceptions (i).acc                    := v_curs (v_indx).acc;
         v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
         v_cur_exceptions (i).nd                     := v_curs (v_indx).nd;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_otc_c5_proc
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
        l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
        --
         OPEN l_cur FOR
          'select datf, rukey(rnk) as rnk, rukey(nd) as nd, rukey(acc) as acc, nls, kv, kodp, znap, '''||g_kf||''' as kf
           from '||pkf('otc_c5_proc')||' where datf between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'') - 1/86400';
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.otc_c5_proc
                                   VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_otc_c5_proc_dt;

  procedure fill_otc_f4a_history_acc
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTC_F4A_HISTORY_ACC';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('OTC_F4A_HISTORY_ACC',
                         'insert into  BARS.OTC_F4A_HISTORY_ACC(datf, acc, isp, nbs, sgn, nls, kv, nms, daos, dazs, ost, ostq, dosq, kosq, nd, nkd, sdate, wdate, sos,
                                                                rnk, prinsider, staff, tobo, s080, r011, cc, tip, cc_id, s280, s290, kf)
                         select datf, rukey(acc) as acc, ruuser(isp) as isp, nbs, sgn, nls, kv, nms, daos, dazs, ost, ostq, dosq, kosq, rukey(nd) as nd, nkd, sdate, wdate, sos,
                                rukey(rnk) as rnk, prinsider, ruuser(staff) as staff, tobo, s080, r011, cc, tip, cc_id, s280, s290, '''||g_kf||''' as kf
                         from ' ||pkf('OTC_F4A_HISTORY_ACC')||' where datf >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_otc_f4a_history_acc;

  procedure fill_otc_ff6_history_acc
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTC_FF6_HISTORY_ACC';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('OTC_FF6_HISTORY_ACC',
                         'insert into  BARS.OTC_FF6_HISTORY_ACC(datf, acc, accc, nbs, sgn, nls, kv, kv_dog, nms, daos, dazs, ost,
                                                                ostq, dosq, kosq, nd, nkd, sdate, wdate, sos, rnk, staff, tobo,
                                                                s260, k110, k111, s031, s032, cc, tip, ostq_kd, r_dos, cc_id, s280, s290, kf)
                         select datf, rukey(acc) as acc, rukey(accc) as accc, nbs, sgn, nls, kv, kv_dog, nms, daos, dazs, ost,
                                ostq, dosq, kosq, rukey(nd) as nd, nkd, sdate, wdate, sos, rukey(rnk) as rnk, ruuser(staff) as staff, tobo,
                                s260, k110, k111, s031, s032, cc, tip, ostq_kd, r_dos, cc_id, s280, s290, '''||g_kf||''' as kf
                         from ' ||pkf('OTC_FF6_HISTORY_ACC')||' where datf >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_otc_ff6_history_acc;

  procedure fill_otc_ff7_history_acc
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTC_FF7_HISTORY_ACC';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('OTC_FF7_HISTORY_ACC',
                         'insert into  BARS.OTC_FF7_HISTORY_ACC(datf, acc, accc, nbs, sgn, nls, kv, kv_dog, nms, daos, dazs,
                                                                ost, ostq, dosq, kosq, nd, nkd, sdate, wdate, sos, rnk, staff,
                                                                tobo, s260, k110, k111, s031, s032, cc, tip, ostq_kd, r_dos, cc_id, tpa, s080, kf)
                         select datf, rukey(acc) as acc, rukey(accc) as accc, nbs, sgn, nls, kv, kv_dog, nms, daos, dazs,
                                ost, ostq, dosq, kosq, rukey(nd) as nd, nkd, sdate, wdate, sos, rukey(rnk) as rnk, ruuser(staff) as staff,
                                tobo, s260, k110, k111, s031, s032, cc, tip, ostq_kd, r_dos, cc_id, tpa, s080, '''||g_kf||''' as kf
                         from ' ||pkf('OTC_FF7_HISTORY_ACC')||' where datf >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_otc_ff7_history_acc;

  procedure fill_otcn_f13_zbsk
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTCN_F13_ZBSK';
    l_stmt_exist            number:= 0;
 begin
      mgr_utl.mantain_error_table(l_tab);
      init();

        execute immediate '
        select count(*) from all_tab_cols t
         where t.OWNER = ''KF'||G_KF||'''
           and t.TABLE_NAME = ''OTCN_F13_ZBSK''
           and t.column_name = ''STMT'''
          into l_stmt_exist;
        --
         if l_stmt_exist > 0 then
         
              mgr_utl.sync_table('OTCN_F13_ZBSK',
                                 'insert into  BARS.OTCN_F13_ZBSK(ref, tt, fdat, accd, nlsd, kv, acck, nlsk, s, sq, nazn, isp, sk_zb, recid, ko, tobo, kf, stmt)
                                 select rukey(ref) as ref, tt, fdat, rukey(accd) as accd, nlsd, kv, rukey(acck) as acck, nlsk, s, sq, nazn,
                                        ruuser(isp) as isp, sk_zb, rukey(recid) as recid, ko, tobo, '''||g_kf||''' as kf, stmt
                                 from ' ||pkf('OTCN_F13_ZBSK')||' where fdat >= add_months(trunc(sysdate, ''MM''), - 1) log errors reject limit unlimited',
                                 false);
                            --
         else

              mgr_utl.sync_table('OTCN_F13_ZBSK',
                                 'insert into  BARS.OTCN_F13_ZBSK(ref, tt, fdat, accd, nlsd, kv, acck, nlsk, s, sq, nazn, isp, sk_zb, recid, ko, tobo, kf, stmt)
                                 select rukey(ref) as ref, tt, fdat, rukey(accd) as accd, nlsd, kv, rukey(acck) as acck, nlsk, s, sq, nazn,
                                        ruuser(isp) as isp, sk_zb, rukey(recid) as recid, ko, tobo, '''||g_kf||''' as kf, null as stmt
                                 from ' ||pkf('OTCN_F13_ZBSK')||' where fdat >= add_months(trunc(sysdate, ''MM''), - 1) log errors reject limit unlimited',
                                 false);
                    --
         end if;
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_otcn_f13_zbsk;

  procedure fill_otcn_f13_zbsk_dt(p_date date default null, p_date_end date default null, p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab                   VARCHAR2(30) DEFAULT 'OTCN_F13_ZBSK';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_date                  DATE;
    l_date_end              DATE;
    l_stmt_exist            number:= 0;


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_OTCN_F13_ZBSK_row IS TABLE OF OTCN_F13_ZBSK%ROWTYPE;
    v_curs t_OTCN_F13_ZBSK_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OTCN_F13_ZBSK%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
         v_cur_exceptions (i).ref                    := v_curs (v_indx).ref;
         v_cur_exceptions (i).accd                   := v_curs (v_indx).accd;
         v_cur_exceptions (i).isp                    := v_curs (v_indx).isp;
         v_cur_exceptions (i).recid                  := v_curs (v_indx).recid;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OTCN_F13_ZBSK
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
        l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
        
      /*  execute immediate '
        select count(*) from all_tab_cols'||p_dblink||' t
         where t.OWNER = ''BARS''
           and t.TABLE_NAME = ''OTCN_F13_ZBSK''
           and t.column_name = ''STMT'''
          into l_stmt_exist;*/
        execute immediate '
        select count(*) from all_tab_cols t
         where t.OWNER = ''KF'||G_KF||'''
           and t.TABLE_NAME = ''OTCN_F13_ZBSK''
           and t.column_name = ''STMT'''
          into l_stmt_exist;
        --
         if l_stmt_exist > 0 then
         
               OPEN l_cur FOR
                'select rukey(ref) as ref, tt, fdat, rukey(accd) as accd, nlsd, kv, rukey(acck) as acck, nlsk, s, sq, nazn,
                        ruuser(isp) as isp, sk_zb, rukey(recid) as recid, ko, tobo, '''||g_kf||''' as kf, stmt
                 from '||pkf(l_tab, p_schema, p_dblink)||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'') - 1/86400';
                    --
         else
               OPEN l_cur FOR
                'select rukey(ref) as ref, tt, fdat, rukey(accd) as accd, nlsd, kv, rukey(acck) as acck, nlsk, s, sq, nazn,
                        ruuser(isp) as isp, sk_zb, rukey(recid) as recid, ko, tobo, '''||g_kf||''' as kf, null as stmt
                 from '||pkf(l_tab, p_schema, p_dblink)||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'') - 1/86400';
                    --
         end if;
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.OTCN_F13_ZBSK
                                   VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_otcn_f13_zbsk_dt;

  procedure fill_otcn_fe8_history
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTCN_FE8_HISTORY';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('OTCN_FE8_HISTORY',
                         'insert into  BARS.OTCN_FE8_HISTORY(datf, acc, ostf, nd, p090, p110, p111, p112, p130, rnk, kf)
                         select datf, rukey(acc) as acc, ostf, rukey(nd) as nd, p090, p110, p111, p112, p130, rukey(rnk) as rnk, '''||g_kf||''' as kf
                         from ' ||pkf('OTCN_FE8_HISTORY')||' where datf >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_otcn_fe8_history;

  procedure fill_tmp_nbu
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'TMP_NBU';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('TMP_NBU',
                         'insert into  BARS.TMP_NBU(kodp, datf, kodf, znap, nbuc, kf, err_msg, fl_mod)
                         select kodp, datf, kodf, znap, nbuc, '''||g_kf||''' as kf, err_msg, fl_mod
                         from ' ||pkf('TMP_NBU')||' where datf >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_tmp_nbu;

  procedure fill_tmp_irep
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'TMP_IREP';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('TMP_IREP',
                         'insert into  BARS.TMP_IREP(kodp, datf, kodf, znap, nbuc, kf, err_msg, fl_mod)
                         select kodp, datf, kodf, znap, nbuc, '''||g_kf||''' as kf, err_msg, fl_mod
                         from ' ||pkf('TMP_IREP')||' where datf >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_tmp_irep;

  procedure fill_rnbu_history
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'RNBU_HISTORY';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('RNBU_HISTORY',
                         'insert into  BARS.RNBU_HISTORY(recid, odate, nls, kv, codcagent, ints, s180, k081, k092,
                                                         dos, kos, mdate, k112, ost, mb, d020, isp, acc, tobo, kf)
                         select recid, odate, nls, kv, codcagent, ints, s180, k081, k092,
                                dos, kos, mdate, k112, ost, mb, d020, ruuser(isp) as isp, rukey(acc) as acc, tobo, '''||g_kf||''' as kf
                         from ' ||pkf('RNBU_HISTORY')||' where odate >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_rnbu_history;

  procedure fill_rnbu_in_inf_records
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'RNBU_IN_INF_RECORDS';
  begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('RNBU_IN_INF_RECORDS',
                         'insert into  BARS.RNBU_IN_INF_RECORDS(record_id, file_id, isresident, nbucode, parameter, value, kf)
                         select record_id, file_id, isresident, nbucode, parameter, value, '''||g_kf||''' as kf
                         from ' ||pkf('RNBU_IN_INF_RECORDS')||' log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_rnbu_in_inf_records;

  procedure fill_rnbu_trace_arch
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'RNBU_TRACE_ARCH';
    l_max_datf               bars.RNBU_TRACE_ARCH.datf%type;
  begin
   --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
    execute immediate 'select nvl(max(datf), to_date(''31.12.2015 23:59:59'', ''dd.mm.yyyy hh24:mi:ss'')) 
                         from RNBU_TRACE_ARCH
                        where kf = :G_KF'
       into l_max_datf
      using G_KF;
      init();
      
      mgr_utl.sync_table('RNBU_TRACE_ARCH',
                         'insert into  BARS.RNBU_TRACE_ARCH
                           (kf, 
                            datf, 
                            kodf, 
                            kodp, 
                            znap, 
                            nbuc, 
                            isp, 
                            rnk, 
                            acc, 
                            nls, 
                            kv, 
                            odate, 
                            ref, 
                            comm, 
                            nd, 
                            mdate, 
                            tobo
                            )
                         select
                            '''||g_kf||''' as kf, 
                            datf, 
                            kodf, 
                            kodp, 
                            znap, 
                            nbuc, 
                            ruuser(isp) as isp, 
                            rukey(rnk) as rnk, 
                            rukey(acc) as acc, 
                            nls, 
                            kv, 
                            odate, 
                            ref, 
                            comm, 
                            rukey(nd) as nd, 
                            mdate, 
                            tobo
               from '||pkf(l_tab)||' where datf > to_date('''||l_max_datf||''', ''dd.mm.yyyy'')',
                         false);
  end fill_rnbu_trace_arch;

  procedure fill_rnbu_trace_arch_frl(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab                    VARCHAR2(30) DEFAULT 'RNBU_TRACE_ARCH';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 200000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);
    l_max_datf               bars.Rnbu_Trace_Arch.datf%type;
    -- 

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

   TYPE t_cur_rnbu_trace_arch IS TABLE OF RNBU_TRACE_ARCH%ROWTYPE;

   vv_cur_rnbu_trace_arch t_cur_rnbu_trace_arch;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_rta IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_RNBU_TRACE_ARCH%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions      t_cur_exception;

      v_indx                PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */

         v_cur_exceptions (i).ora_err_number$           := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$             := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$              := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$            := 'I';
         v_cur_exceptions (i).odate                     := vv_cur_rnbu_trace_arch (v_indx).odate;
         v_cur_exceptions (i).kodp                      := vv_cur_rnbu_trace_arch (v_indx).kodp;
         v_cur_exceptions (i).znap                      := vv_cur_rnbu_trace_arch (v_indx).znap;
         v_cur_exceptions (i).nbuc                      := vv_cur_rnbu_trace_arch (v_indx).nbuc;
         v_cur_exceptions (i).isp                       := vv_cur_rnbu_trace_arch (v_indx).isp;
         v_cur_exceptions (i).rnk                       := vv_cur_rnbu_trace_arch (v_indx).rnk;
         v_cur_exceptions (i).acc                       := vv_cur_rnbu_trace_arch (v_indx).acc;
         v_cur_exceptions (i).ref                       := vv_cur_rnbu_trace_arch (v_indx).ref;
         v_cur_exceptions (i).comm                      := vv_cur_rnbu_trace_arch (v_indx).comm;
         v_cur_exceptions (i).nd                        := vv_cur_rnbu_trace_arch (v_indx).nd;
         v_cur_exceptions (i).mdate                     := vv_cur_rnbu_trace_arch (v_indx).mdate;
         v_cur_exceptions (i).tobo                      := vv_cur_rnbu_trace_arch (v_indx).tobo;

     END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_RNBU_TRACE_ARCH
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_rta;


  begin
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);

    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
    execute immediate 'select nvl(max(datf), to_date(''31.12.2015 23:59:59'', ''dd.mm.yyyy hh24:mi:ss'')) 
                         from RNBU_TRACE_ARCH
                        where kf = :G_KF'
       into l_max_datf
      using G_KF;

      BEGIN
        
      OPEN l_cur FOR
              'select
                    '''||g_kf||''' as kf, 
                    datf, 
                    kodf, 
                    kodp, 
                    znap, 
                    nbuc, 
                    ruuser(isp) as isp, 
                    rukey(rnk) as rnk, 
                    rukey(acc) as acc, 
                    nls, 
                    kv, 
                    odate, 
                    ref, 
                    comm, 
                    rukey(nd) as nd, 
                    mdate, 
                    tobo
               from '||pkf(l_tab, p_schema, p_dblink)||' where datf > to_date('''||l_max_datf||''', ''dd.mm.yyyy'')';
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_rnbu_trace_arch LIMIT c_limit;
               EXIT WHEN vv_cur_rnbu_trace_arch.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_rnbu_trace_arch SAVE EXCEPTIONS
              INSERT INTO bars.rnbu_trace_arch
                                        VALUES vv_cur_rnbu_trace_arch(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_rta ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
          -- Clear collection for vv_cur_rnbu_trace_arch
          --vv_cur_rnbu_trace_arch.delete;
        END;
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_rnbu_trace_arch_frl;

  procedure fill_rnbu_trace_int_arch_frl(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab                    VARCHAR2(30) DEFAULT 'RNBU_TRACE_INT_ARCH';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 200000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);
    l_max_datf               bars.Rnbu_Trace_int_Arch.datf%type;

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

   TYPE t_cur_rnbu_trace_int_arch IS TABLE OF RNBU_TRACE_INT_ARCH%ROWTYPE;

   vv_cur_rnbu_trace_int_arch t_cur_rnbu_trace_int_arch;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging_rtia IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_RNBU_TRACE_INT_ARCH%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions      t_cur_exception;

      v_indx                PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */

         v_cur_exceptions (i).ora_err_number$           := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$             := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$              := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$            := 'I';
         v_cur_exceptions (i).kodf                      := vv_cur_rnbu_trace_int_arch (v_indx).kodf;
         v_cur_exceptions (i).datf                      := vv_cur_rnbu_trace_int_arch (v_indx).datf;
         v_cur_exceptions (i).nls                       := vv_cur_rnbu_trace_int_arch (v_indx).nls;
         v_cur_exceptions (i).kv                        := vv_cur_rnbu_trace_int_arch (v_indx).kv;
         v_cur_exceptions (i).odate                     := vv_cur_rnbu_trace_int_arch (v_indx).odate;
         v_cur_exceptions (i).kodp                      := vv_cur_rnbu_trace_int_arch (v_indx).kodp;
         v_cur_exceptions (i).znap                      := vv_cur_rnbu_trace_int_arch (v_indx).znap;
         v_cur_exceptions (i).nbuc                      := vv_cur_rnbu_trace_int_arch (v_indx).nbuc;
         v_cur_exceptions (i).isp                       := vv_cur_rnbu_trace_int_arch (v_indx).isp;
         v_cur_exceptions (i).rnk                       := vv_cur_rnbu_trace_int_arch (v_indx).rnk;
         v_cur_exceptions (i).acc                       := vv_cur_rnbu_trace_int_arch (v_indx).acc;
         v_cur_exceptions (i).ref                       := vv_cur_rnbu_trace_int_arch (v_indx).ref;
         v_cur_exceptions (i).comm                      := vv_cur_rnbu_trace_int_arch (v_indx).comm;
         v_cur_exceptions (i).nd                        := vv_cur_rnbu_trace_int_arch (v_indx).nd;
         v_cur_exceptions (i).mdate                     := vv_cur_rnbu_trace_int_arch (v_indx).mdate;
         v_cur_exceptions (i).tobo                      := vv_cur_rnbu_trace_int_arch (v_indx).tobo;

     END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_RNBU_TRACE_INT_ARCH
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging_rtia;


  begin
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

      BEGIN
       --
      select nvl(max(datf), to_date('01.01.2016', 'dd.mm.yyyy')) 
        into l_max_datf
        from RNBU_TRACE_INT_ARCH
       where kf = G_KF;
       -- 
      OPEN l_cur FOR
              'select
                    '''||g_kf||''' as kf , 
                    datf, 
                    kodf, 
                    kodp, 
                    znap, 
                    nbuc, 
                    ruuser(isp) as isp, 
                    rukey(rnk) as rnk, 
                    rukey(acc) as acc, 
                    nls, 
                    kv, 
                    odate, 
                    ref, 
                    comm, 
                    rukey(nd) as nd, 
                    mdate, 
                    tobo
               from '||pkf(l_tab, p_schema, p_dblink)||' where datf > '''||l_max_datf||'''';
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_rnbu_trace_int_arch LIMIT c_limit;
               EXIT WHEN vv_cur_rnbu_trace_int_arch.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_rnbu_trace_int_arch SAVE EXCEPTIONS
              INSERT INTO bars.rnbu_trace_int_arch
                                        VALUES vv_cur_rnbu_trace_int_arch(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging_rtia ();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
          -- Clear collection for vv_cur_oper_visa
          vv_cur_rnbu_trace_int_arch.delete;
        END;
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_rnbu_trace_int_arch_frl;

  procedure fill_bpk_parameters_upd(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'BPK_PARAMETERS_UPDATE';
    l_max_idupd   bars.BPK_PARAMETERS_UPDATE.idupd%type;
    begin
    init();
     bars_policy_adm.disable_policies('BPK_PARAMETERS_UPDATE');
     --      
     l_max_idupd := get_max_idupd(l_tab);
     --
     mgr_utl.sync_table(l_tab,  'INSERT INTO '||l_tab||'
                               SELECT rukey(idupd) as idupd, chgaction, chgdate, global_bdate, effectdate,
                               ruuser(DONEBY) as doneby, rukey(ND) as nd, tag, value, '''||g_kf||''' as kf
                               FROM '
                               ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
     --
     bc.home;
     --
     select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.bpk_parameters_update;
     --
     mgr_utl.reset_sequence('s_bpk_parameters_update', l_max_idupd);
     --
     bars_policy_adm.enable_policies('BPK_PARAMETERS_UPDATE');

 end fill_bpk_parameters_upd;

  procedure fill_cm_client_que
    is
    l_max_id integer;
    begin
    --bars_policy_adm.disable_policies('CM_CLIENT_QUE');
     bc.home;
            select trunc(nvl(max(id / 100), 0)) + 1 into l_max_id from bars.CM_CLIENT_QUE;
     bc.go(g_kf);
            mgr_utl.reset_sequence('S_CMCLIENT', l_max_id);

     mgr_utl.sync_table_auto('CM_CLIENT_QUE',false,'ID,"rukey(ID)",RNK,"rukey(RNK)",ACC,"rukey(ACC)"');
     --bars_policy_adm.enable_policies('CM_CLIENT_QUE');

 end fill_cm_client_que;

 procedure fill_cm_client_que_arc
    is
    l_max_id number(30);
    begin
    --bars_policy_adm.disable_policies('CM_CLIENT_QUE');
     mgr_utl.sync_table_auto('CM_CLIENT_QUE_ARC',false,'IDUPD,"rukey(IDUPD)",ID,"rukey(ID)",RNK,"rukey(RNK)",ACC,"rukey(ACC)"');
     --bars_policy_adm.enable_policies('CM_CLIENT_QUE');
     --
     bc.home;
     select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_id from bars.CM_CLIENT_QUE_ARC;
     bc.go(g_kf);
     mgr_utl.reset_sequence('s_cmclient', l_max_id);
     --
  end fill_cm_client_que_arc;

  procedure fill_ow_files
    is
    l_max_id integer;
    begin
    bars_policy_adm.disable_policies('OW_FILES');
      mgr_utl.sync_table_auto('OW_FILES',false,'ID,"rukey(ID)"');
      bc.home;
      select trunc(nvl(max(id / 100), 0)) + 1 into l_max_id from bars.OW_FILES;
      mgr_utl.reset_sequence('s_owfiles', l_max_id);
    bars_policy_adm.enable_policies('OW_FILES');
  end fill_ow_files;

  procedure fill_ow_oic_atransfers_h_frl
   is
    l_tab                    VARCHAR2(30) DEFAULT 'OW_OIC_ATRANSFERS_HIST';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 100000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

   TYPE t_cur_ow_oic_atransfers_h IS TABLE OF OW_OIC_ATRANSFERS_HIST%ROWTYPE;

   vv_cur_ow_oic_atransfers_h t_cur_ow_oic_atransfers_h;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OW_OIC_ATRANSFERS_HIST%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions      t_cur_exception;

      v_indx                PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */

         v_cur_exceptions (i).ora_err_number$           := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$             := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$              := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$            := 'I';
         v_cur_exceptions (i).id                        := vv_cur_ow_oic_atransfers_h (v_indx).id;
         v_cur_exceptions (i).idn                       := vv_cur_ow_oic_atransfers_h (v_indx).idn;
         v_cur_exceptions (i).anl_synthcode             := vv_cur_ow_oic_atransfers_h (v_indx).anl_synthcode;
         v_cur_exceptions (i).anl_trndescr              := vv_cur_ow_oic_atransfers_h (v_indx).anl_trndescr;
         v_cur_exceptions (i).anl_analyticrefn          := vv_cur_ow_oic_atransfers_h (v_indx).anl_analyticrefn;
         v_cur_exceptions (i).credit_anlaccount         := vv_cur_ow_oic_atransfers_h (v_indx).credit_anlaccount;
         v_cur_exceptions (i).credit_amount             := vv_cur_ow_oic_atransfers_h (v_indx).credit_amount;
         v_cur_exceptions (i).credit_currency           := vv_cur_ow_oic_atransfers_h (v_indx).credit_currency;
         v_cur_exceptions (i).debit_anlaccount          := vv_cur_ow_oic_atransfers_h (v_indx).debit_anlaccount;
         v_cur_exceptions (i).debit_amount              := vv_cur_ow_oic_atransfers_h (v_indx).debit_amount;
         v_cur_exceptions (i).debit_currency            := vv_cur_ow_oic_atransfers_h (v_indx).debit_currency;
         v_cur_exceptions (i).anl_postingdate           := vv_cur_ow_oic_atransfers_h (v_indx).anl_postingdate;
         v_cur_exceptions (i).doc_drn                   := vv_cur_ow_oic_atransfers_h (v_indx).doc_drn;
         v_cur_exceptions (i).doc_localdate             := vv_cur_ow_oic_atransfers_h (v_indx).doc_localdate;
         v_cur_exceptions (i).doc_descr                 := vv_cur_ow_oic_atransfers_h (v_indx).doc_descr;
         v_cur_exceptions (i).doc_amount                := vv_cur_ow_oic_atransfers_h (v_indx).doc_amount;
         v_cur_exceptions (i).doc_currency              := vv_cur_ow_oic_atransfers_h (v_indx).doc_currency;
         v_cur_exceptions (i).ref                       := vv_cur_ow_oic_atransfers_h (v_indx).ref;
         v_cur_exceptions (i).doc_orn                   := vv_cur_ow_oic_atransfers_h (v_indx).doc_orn;

     END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OW_OIC_ATRANSFERS_HIST
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging;


  begin
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    bars_policy_adm.disable_policies(l_tab);

      BEGIN

      OPEN l_cur FOR
              'select
                    rukey(id) as id
                    ,idn
                    ,anl_synthcode
                    ,anl_trndescr
                    ,anl_analyticrefn
                    ,credit_anlaccount
                    ,credit_amount
                    ,credit_currency
                    ,debit_anlaccount
                    ,debit_amount
                    ,debit_currency
                    ,anl_postingdate
                    ,doc_drn
                    ,doc_localdate
                    ,doc_descr
                    ,doc_amount
                    ,doc_currency
                    ,rukey(ref) as ref
                    ,doc_orn
                    ,'''||g_kf||''' as kf
               from '||pkf('OW_OIC_ATRANSFERS_HIST')||' where doc_localdate >= to_date(''01.01.2016'', ''DD.MM.YYYY'') ';
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_ow_oic_atransfers_h LIMIT c_limit;
               EXIT WHEN vv_cur_ow_oic_atransfers_h.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_ow_oic_atransfers_h SAVE EXCEPTIONS
              INSERT INTO bars.OW_OIC_ATRANSFERS_HIST
                                        VALUES vv_cur_ow_oic_atransfers_h(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
          -- Clear collection for vv_cur_ow_oic_atransfers_h
          vv_cur_ow_oic_atransfers_h.delete;
        END;
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  bars_policy_adm.enable_policies(l_tab);
  --
  trace('%s: finished', p);
  --
  end fill_ow_oic_atransfers_h_frl;

  procedure fill_ow_oic_ref_frl(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab                    VARCHAR2(30) DEFAULT 'OW_OIC_REF';
    p                        CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                  PLS_INTEGER := 0;
    c_limit                  PLS_INTEGER := 100000;
    l_cur                    SYS_REFCURSOR;
    c_n                      PLS_INTEGER := 0;
    l_migration_start_time   DATE DEFAULT SYSDATE;
    l_start_time             timestamp default current_timestamp;
    l_end_time               timestamp default current_timestamp;
    l_rowcount               number default 0;
    l_time_duration          interval day(3) to second(3);
    l_max_ref                bars.OW_OIC_REF.ref%type;
    cursor c_max_ref is
              select trunc(nvl(max(ref / 100), 0)) + 1
                from OW_OIC_REF
               where kf = G_KF;

   /* "Exceptions encountered in FORALL" exception... */
   bulk_exceptions   EXCEPTION;
   PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

   TYPE t_cur_ow_oic_ref IS TABLE OF OW_OIC_REF%ROWTYPE;

   vv_cur_ow_oic_ref t_cur_ow_oic_ref;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
   PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_OW_OIC_REF%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions      t_cur_exception;

      v_indx                PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */

         v_cur_exceptions (i).ora_err_number$           := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$             := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$              := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$            := 'I';
         v_cur_exceptions (i).id                        := vv_cur_ow_oic_ref (v_indx).id;
         v_cur_exceptions (i).ref                       := vv_cur_ow_oic_ref (v_indx).ref;


     END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_OW_OIC_REF
              VALUES v_cur_exceptions (i);

      COMMIT;
   END error_logging;


  begin
    l_migration_start_time := sysdate;
    l_start_time := current_timestamp;
    --
    trace('%s: entry point', p);
    --
    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    bars_policy_adm.disable_policies(l_tab);
    -- 
    open c_max_ref;
    fetch c_max_ref  into l_max_ref;


      BEGIN

      OPEN l_cur FOR
              'select --+ use_hash (owr, owf)
                     rukey(owr.id) as id
                    ,rukey(owr.ref) as ref
                    ,'''||g_kf||''' as kf
               from '||mgr_utl.pkf('OW_OIC_REF', p_schema,  p_dblink)||' owr, '||mgr_utl.pkf('OW_FILES', p_schema,  p_dblink)||' owf
               where owr.id = owf.id
               and owf.file_date >= to_date(''01.01.2016'', ''DD.MM.YYYY'') 
               and owr.ref > '||l_max_ref;
                  --
           LOOP
             FETCH l_cur BULK COLLECT INTO vv_cur_ow_oic_ref LIMIT c_limit;
               EXIT WHEN vv_cur_ow_oic_ref.COUNT = 0;

           BEGIN
            FORALL indx IN INDICES OF vv_cur_ow_oic_ref SAVE EXCEPTIONS
              INSERT INTO bars.OW_OIC_REF
                                        VALUES vv_cur_ow_oic_ref(indx);

            EXCEPTION
                   WHEN bulk_exceptions THEN
                      c_n := c_n + SQL%ROWCOUNT;
                      error_logging();
           END;
            COMMIT;
              v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));

           END LOOP;
           l_rowcount := l_cur%rowcount;
           CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
          -- Clear collection for vv_cur_ow_oic_ref
          vv_cur_ow_oic_ref.delete;
        END;
  --
  bc.home();
  --
  mgr_utl.finalize();
  --
  bars_policy_adm.enable_policies(l_tab);
  --
  trace('%s: finished', p);
  --
  end fill_ow_oic_ref_frl;

  procedure fill_w4_acc_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab     VARCHAR2(30) DEFAULT 'W4_ACC_UPDATE';
    l_max_idupd   bars.W4_ACC_UPDATE.idupd%type;

    begin
    --
    bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);

    --mgr_utl.sync_table_auto('W4_ACC_UPDATE',false,'idupd,"rukey(idupd)",nd,"rukey(nd)",acc_pk,"rukey(acc_pk)",acc_ovr,"ruuser(acc_ovr)",acc_9129,"rukey(acc_9129)",acc_3570,"rukey(acc_3570)",acc_2208,"rukey(acc_2208)",acc_2627,"rukey(acc_2627)",acc_2207,"rukey(acc_2207)",acc_3579,"rukey(acc_3579)",acc_2209,"rukey(acc_2209)",acc_2625x,"rukey(acc_2625x)",acc_2627x,"rukey(acc_2627x)",acc_2625d,"rukey(acc_2625d)",acc_2628,"rukey(acc_2628)",acc_2203,"rukey(acc_2203)"');
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,nd
                         ,acc_pk
                         ,acc_ovr
                         ,acc_9129
                         ,acc_3570
                         ,acc_2208
                         ,acc_2627
                         ,acc_2207
                         ,acc_3579
                         ,acc_2209
                         ,card_code
                         ,acc_2625x
                         ,acc_2627x
                         ,acc_2625d
                         ,acc_2628
                         ,acc_2203
                         ,fin
                         ,fin23
                         ,obs23
                         ,kat23
                         ,k23
                         ,dat_begin
                         ,dat_end
                         ,dat_close
                         ,pass_date
                         ,pass_state
                         ,kol_sp
                         ,s250
                         ,grp
                         ,global_bdate
                         ,kf
                       )
                        SELECT 
                         rukey(idupd) as idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,rukey(nd) as nd
                         ,rukey(acc_pk) as acc_pk
                         ,ruuser(acc_ovr) as acc_ovr
                         ,rukey(acc_9129) as acc_9129
                         ,rukey(acc_3570) as acc_3570
                         ,rukey(acc_2208) as acc_2208
                         ,rukey(acc_2627) as acc_2627
                         ,rukey(acc_2207) as acc_2207
                         ,rukey(acc_3579) as acc_3579
                         ,rukey(acc_2209) as acc_2209
                         ,card_code
                         ,rukey(acc_2625x) as  acc_2625x
                         ,rukey(acc_2627x) as  acc_2627x
                         ,rukey(acc_2625d) as  acc_2625d
                         ,rukey(acc_2628 ) as  acc_2628 
                         ,rukey(acc_2203 ) as  acc_2203 
                         ,fin
                         ,fin23
                         ,obs23
                         ,kat23
                         ,k23
                         ,dat_begin
                         ,dat_end
                         ,dat_close
                         ,pass_date
                         ,pass_state
                         ,kol_sp
                         ,s250
                         ,grp
                         ,global_bdate
                         , '''||g_kf||''' as kf 
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);

    bc.home;
    --
    select trunc(nvl(max(idupd), 0)) + 1 into l_max_idupd from bars.W4_ACC_UPDATE;
    mgr_utl.reset_sequence('s_w4acc_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    bpa.enable_policies(l_tab);
    --
  end fill_w4_acc_update;

  procedure fill_bpk_acc_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'BPK_ACC_UPDATE';
    l_max_idupd   bars.BPK_ACC_UPDATE.idupd%type;

    begin
    init();
    bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table(l_tab,
                        'INSERT INTO '||l_tab||'
                        SELECT rukey(IDUPD) as idupd, chgaction, effectdate, chgdate, ruuser(DONEBY) as doneby, rukey(ACC_PK) as acc_pk, rukey(ACC_OVR) as acc_ovr, rukey(ACC_9129) as acc_9129, rukey(ACC_TOVR)as acc_tovr, '''||g_kf||''' as kf,
                               rukey(ACC_3570) as acc_3570, rukey(ACC_2208) as acc_2208, rukey(ND) as nd, product_id, rukey(ACC_2207) as acc_2207, rukey(ACC_3579) as acc_3579, acc_2209, rukey(ACC_W4) as acc_w4, fin, fin23,
                               obs23, kat23, k23, dat_end, kol_sp, s250, grp, global_bdate, dat_close
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.bpk_acc_update;
    --
    mgr_utl.reset_sequence('s_bpkacc_update', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    bpa.enable_policies(l_tab);
    --
  end fill_bpk_acc_update;

  procedure fill_bpk_credit_deal
    is
      begin
      mgr_utl.sync_table_auto('BPK_CREDIT_DEAL',true,'card_nd,"rukey(card_nd)",deal_nd,"rukey(deal_nd)",acc_9129,"rukey(acc_9129)",acc_ovr,"rukey(acc_ovr)",acc_2208,"rukey(acc_2208)",acc_2207,"rukey(acc_2207)",acc_2209,"rukey(acc_2209)",DEAL_RNK,"rukey(DEAL_RNK)"');
  end fill_bpk_credit_deal;

  procedure fill_bpk_credit_deal_var
    is
      begin
      mgr_utl.sync_table_auto('BPK_CREDIT_DEAL_VAR',true,'DEAL_ND,"rukey(DEAL_ND)",DEAL_RNK,"rukey(DEAL_RNK)"');
  end fill_bpk_credit_deal_var;

  procedure fill_ow_impfile
    is
    l_max_id  number;

    begin
    mgr_utl.sync_table_auto('OW_IMPFILE',false,'ID,"rukey(ID)"');

    bc.home;
    select trunc(nvl(max(id / 100), 0)) + 1 into l_max_id from bars.OW_IMPFILE;
    mgr_utl.reset_sequence('s_owimpfile', l_max_id);

  end fill_ow_impfile;

   procedure fill_ow_query_log
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_QUERY_LOG';
    l_max_id  number;

    begin
    bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);

      mgr_utl.sync_table_auto('OW_QUERY_LOG',false,'REQID,"rukey(REQID)",RNK,"rukey(RNK)",ND,"rukey(ND)"');

    bc.home;
    select trunc(nvl(max(reqid / 100), 0)) + 1 into l_max_id from bars.OW_QUERY_LOG;
    mgr_utl.reset_sequence('s_ow_query_log', l_max_id);

    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    bpa.enable_policies(l_tab);

  end fill_ow_query_log;

  procedure fill_sw_950_arch
    is
    l_tab   VARCHAR2(30) DEFAULT 'SW_950_ARCH';
    begin
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);

     mgr_utl.sync_table('SW_950_ARCH',  'INSERT INTO SW_950_ARCH
                               SELECT rukey(SWREF) as swref,rukey(NOSTRO_ACC) as nostro_acc,num,stmt_date,obal,cbal,add_info,done,stmt_bdate,kv, '''||g_kf||''' as kf
                               FROM '
                               ||pkf('SW_950_ARCH'), false);

    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);

  end fill_sw_950_arch;

  procedure fill_sw_msgfield
    is
    begin
    mgr_utl.sync_table('SW_MSGFIELD',  'INSERT INTO SW_MSGFIELD
                               SELECT rukey(SWREF) as swref, recnum, msgblk, msgtag, value, '''||g_kf||''' as kf
                               FROM '
                               ||pkf('SW_MSGFIELD'), false);
  end fill_sw_msgfield;

  procedure fill_rko_lst_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'RKO_LST_UPDATE';
    l_max_idupd   bars.RKO_LST_UPDATE.idupd%type;
    begin
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    --mgr_utl.sync_table_auto('RKO_LST_UPDATE',false,'IDUPD,"rukey(IDUPD)",DONEBY,"ruuser(DONEBY)",ND,"rukey(ND)",ACC,"rukey(ACC)",ACCD,"rukey(ACCD)",ACC1,"rukey(ACC1)",ACC2,"rukey(ACC2)"');
    mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( idupd
                         ,chgaction
                         ,chgdate
                         ,effectdate
                         ,global_bdate
                         ,doneby
                         ,kf
                         ,nd
                         ,acc
                         ,accd
                         ,acc1
                         ,acc2
                         ,dat0a
                         ,dat0b
                         ,s0
                         ,dat1a
                         ,dat1b
                         ,dat2a
                         ,dat2b
                         ,comm
                         ,koldok
                         ,sumdok
                         ,cc_id
                         ,sdate
                         ,sos

                       )
                        SELECT 
                         rukey(IDUPD) as idupd
                         ,chgaction
                         ,chgdate
                         ,effectdate
                         ,global_bdate
                         ,ruuser(DONEBY) as doneby
                         , '''||g_kf||''' as kf 
                         ,rukey(ND) as nd
                         ,rukey(ACC) as acc
                         ,rukey(ACCD) as accd
                         ,rukey(ACC1) as acc1
                         ,rukey(ACC2) as acc2
                         ,dat0a
                         ,dat0b
                         ,s0
                         ,dat1a
                         ,dat1b
                         ,dat2a
                         ,dat2b
                         ,comm
                         ,koldok
                         ,sumdok
                         ,cc_id
                         ,sdate
                         ,sos
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);
    --
    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.RKO_LST_UPDATE;
    --
    mgr_utl.reset_sequence('s_rko_lst_update', l_max_idupd);
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    mgr_utl.p_constraints_enable(l_tab);
    --
  end fill_rko_lst_update;

  procedure fill_rko_lst
    is
    begin
    mgr_utl.sync_table_auto('RKO_LST', false,'acc,"rukey(acc)",accd,"rukey(accd)",acc2,"rukey(acc2)",nd,"rukey(nd)"');
  end fill_rko_lst;

  procedure fill_rnkp_kod
    is
    begin
    mgr_utl.sync_table_auto('RNKP_KOD', false,'RNK,"rukey(RNK)"');
  end fill_rnkp_kod;

  procedure fill_nbs_profacc
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'NBS_PROFACC';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_nbs_profacc;

  procedure fill_ch_1
    is
      begin
      mgr_utl.sync_table_auto('CH_1', false,'ref1,"rukey(ref1)",ref2,"rukey(ref2)"');
  end fill_ch_1;

  procedure fill_cc_tag_codes
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CC_TAG_CODES';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cc_tag_codes;

  procedure fill_cc_pr_tr
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CC_PR_TR';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cc_pr_tr;

  procedure fill_cck_zal_code
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_ZAL_CODE';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_zal_code;

  procedure fill_cck_worker_bank_aim
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_WORKER_BANK_AIM';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_worker_bank_aim;

  procedure fill_cck_worker_bank
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_WORKER_BANK';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_worker_bank;

  procedure fill_cck_restr_vid
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_RESTR_VID';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_restr_vid;

  procedure fill_cck_rating
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_RATING';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_rating;

  procedure fill_cck_cusseg
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_CUSSEG';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_cusseg;

  procedure fill_cck_cprod
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_CPROD';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_cprod;

  procedure fill_cck_colbb
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'CCK_COLBB';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_cck_colbb;

  procedure fill_rko_3570
    is
      begin
      mgr_utl.sync_table_auto('RKO_3570',false,'ACC,"rukey(ACC)"');
  end fill_rko_3570;

  procedure fill_w4_acc
    is
    l_tab     VARCHAR2(30) DEFAULT 'W4_ACC';
    l_max_nd  number;
    begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('W4_ACC',false,'nd,"rukey(nd)",acc_pk,"rukey(acc_pk)",acc_ovr,"ruuser(acc_ovr)",acc_9129,"rukey(acc_9129)",acc_3570,"rukey(acc_3570)",acc_2208,"rukey(acc_2208)",acc_2627,"rukey(acc_2627)",acc_2207,"rukey(acc_2207)",acc_3579,"rukey(acc_3579)",acc_2209,"rukey(acc_2209)",acc_2625x,"rukey(acc_2625x)",acc_2627x,"rukey(acc_2627x)",acc_2625d,"rukey(acc_2625d)",acc_2628,"rukey(acc_2628)",acc_2203,"rukey(acc_2203)"');
      --
      bc.home();
      --
      select trunc(nvl(max(ND / 100), 0)) + 1 into l_max_nd
        from bars.W4_ACC;
      mgr_utl.reset_sequence('S_OBPCDEAL', l_max_nd);
      --
      bpa.enable_policies(l_tab);
  end fill_w4_acc;

  procedure fill_cp_refw
    is
      begin
      mgr_utl.sync_table_auto('CP_REFW',false,'ref,"rukey(ref)"');
  end fill_cp_refw;

  procedure fill_cp_accp
    is
      begin
      mgr_utl.sync_table_auto('CP_ACCP',false,'ACC,"rukey(ACC)"');
  end fill_cp_accp;


  procedure fill_cm_credits
    is
    l_tab     VARCHAR2(30) DEFAULT 'CM_CREDITS';
    l_max_id  NUMBER;
    begin
        begin
        bc.home();
        select trunc(nvl(max(id / 100), 0)) + 1 into l_max_id from bars.cf_log;
        bc.go(g_kf);
        mgr_utl.reset_sequence('S_CF_LOG', l_max_id);
        exception when others then
            rollback;
            mgr_utl.save_error();
        end;
    bpa.disable_policies(l_tab);
    mgr_utl.sync_table_auto('CM_CREDITS',false,'nd,"rukey(nd)"');
    bpa.enable_policies(l_tab);
  end fill_cm_credits;


  procedure fill_ins_accidents
    is
      begin
      mgr_utl.sync_table_auto('INS_ACCIDENTS',false,'ID,"rukey(ID)",DEAL_ID,"rukey(DEAL_ID)",STAFF_ID,"ruuser(STAFF_ID)"');
  end fill_ins_accidents;

  procedure fill_ins_add_agreements
    is
      begin
      mgr_utl.sync_table_auto('INS_ADD_AGREEMENTS',false,'ID,"rukey(ID)",DEAL_ID,"rukey(DEAL_ID)",STAFF_ID,"ruuser(STAFF_ID)"');
  end fill_ins_add_agreements;

  procedure fill_ins_attrs
    is
      begin
      mgr_utl.sync_table_auto('INS_ATTRS',false,'ID,"rukey(ID)"');
  end fill_ins_attrs;

  procedure fill_ins_deals
    is
    l_max_id  NUMBER;
      begin
      mgr_utl.sync_table_auto('INS_DEALS',false,'ID,"rukey(ID)",RNK,"rukey(RNK)",INS_RNK,"rukey(INS_RNK)",STAFF_ID,"ruuser(STAFF_ID)",ND,"rukey(ND)"');
          begin
            bc.home();
            select trunc(nvl(max(id / 100), 0)) + 1
            into l_max_id
            from bars.ins_deals;
            bc.go(g_kf);
            mgr_utl.reset_sequence('s_insdeals', l_max_id);
          exception when others then
            rollback;
            mgr_utl.save_error();
          end;
   end fill_ins_deals;

  procedure fill_ins_deal_sts_hist
    is
      begin
      mgr_utl.sync_table_auto('INS_DEAL_STS_HISTORY',false,'DEAL_ID,"rukey(DEAL_ID)",STAFF_ID,"ruuser(STAFF_ID)"');
  end fill_ins_deal_sts_hist;

  procedure fill_ins_partners
    is
      begin
      mgr_utl.mantain_error_table('INS_PARTNERS');  
      mgr_utl.sync_table('INS_PARTNERS','insert into INS_PARTNERS
                                            (id, 
                                            name, 
                                            rnk, 
                                            agr_no, 
                                            agr_sdate, 
                                            agr_edate, 
                                            tariff_id, 
                                            fee_id, 
                                            limit_id, 
                                            active, 
                                            custtype)
                                            select 
                                            rukey(id), 
                                            name, 
                                            rukey(rnk), 
                                            agr_no, 
                                            agr_sdate, 
                                            agr_edate, 
                                            tariff_id, 
                                            fee_id, 
                                            limit_id, 
                                            active, 
                                            custtype
                                             from '||pkf('INS_PARTNERS')||' log errors reject limit unlimited'
                                             , false);
                                            
  end fill_ins_partners;

  procedure fill_ins_partner_branch_rnk
    is
      begin
      mgr_utl.sync_table_auto('INS_PARTNER_BRANCH_RNK',false,'PARTNER_ID,"rukey(PARTNER_ID)",RNK,"rukey(RNK)"');
  end fill_ins_partner_branch_rnk;

  procedure fill_ins_partner_type_attrs
    is
      begin
      mgr_utl.sync_table_auto('INS_PARTNER_TYPE_ATTRS',false,'ID,"rukey(ID)",PARTNER_ID,"rukey(PARTNER_ID)"');
  end fill_ins_partner_type_attrs;

  procedure fill_ins_partner_type_br
    is
    begin
      init();
      mgr_utl.sync_table('INS_PARTNER_TYPE_BRANCHES',
                         'insert into  BARS.INS_PARTNER_TYPE_BRANCHES(id, branch, partner_id, type_id, tariff_id, fee_id, limit_id, apply_hier)
                         select rukey(ID) as id, '''||'/'||g_kf||'/'||''' as branch, rukey(PARTNER_ID) as partner_id, type_id, tariff_id, fee_id, limit_id, apply_hier
                         from ' ||pkf('INS_PARTNER_TYPE_BRANCHES'),
                         false);
  end fill_ins_partner_type_br;

  procedure fill_ins_partner_type_pr
    is
      begin
      mgr_utl.sync_table_auto('INS_PARTNER_TYPE_PRODUCTS',false,'ID,"rukey(ID)",PARTNER_ID,"rukey(PARTNER_ID)",PRODUCT_ID,"rukey(PRODUCT_ID)"');
  end fill_ins_partner_type_pr;

  procedure fill_ins_partner_type_scans
    is
      begin
      mgr_utl.sync_table_auto('INS_PARTNER_TYPE_SCANS',false,'ID,"rukey(ID)",PARTNER_ID,"rukey(PARTNER_ID)",SCAN_ID,"rukey(SCAN_ID)"');
  end fill_ins_partner_type_scans;

  procedure fill_ins_partner_type_tmplt
    is
      begin
      mgr_utl.sync_table_auto('INS_PARTNER_TYPE_TEMPLATES',false,'ID,"rukey(ID)",PARTNER_ID,"rukey(PARTNER_ID)",SCAN_ID,"rukey(SCAN_ID)"');
  end fill_ins_partner_type_tmplt;

  procedure fill_ins_payments_schedule
    is
      begin
      mgr_utl.sync_table_auto('INS_PAYMENTS_SCHEDULE',false,'DEAL_ID,"rukey(DEAL_ID)"');
  end fill_ins_payments_schedule;

  procedure fill_branch_country_rnk
    is
      begin
      mgr_utl.sync_table_auto('BRANCH_COUNTRY_RNK',false,'RNK,"rukey(RNK)"');
  end fill_branch_country_rnk;

  procedure fill_nbu23_rez_dt(p_date date default null, p_date_end date default null)
    is
    l_tab                   VARCHAR2(30) DEFAULT 'NBU23_REZ';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_date                  DATE;
    l_date_end              DATE;


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_nbu23_rez_row IS TABLE OF nbu23_rez%ROWTYPE;
    v_curs t_nbu23_rez_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_NBU23_REZ%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
         v_cur_exceptions (i).id                     := v_curs (v_indx).id;
         v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
         v_cur_exceptions (i).nbs                    := v_curs (v_indx).nbs;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_NBU23_REZ
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
        l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
        --
         OPEN l_cur FOR
          'select
                  fdat
                 ,'''||g_kf||''' as kf
                 ,rukey(id) as id
                 ,rukey(rnk) as rnk
                 ,nbs
                 ,kv
                 ,rukey(nd) as nd
                 ,cc_id
                 ,rukey(acc) as acc
                 ,nls
                 ,branch
                 ,fin
                 ,obs
                 ,kat
                 ,k
                 ,irr
                 ,zal
                 ,bv
                 ,pv
                 ,rez
                 ,rezq
                 ,dd
                 ,ddd
                 ,bvq
                 ,custtype
                 ,idr
                 ,wdate
                 ,okpo
                 ,nmk
                 ,rz
                 ,pawn
                 ,istval
                 ,r013
                 ,rezn
                 ,reznq
                 ,arjk
                 ,pvz
                 ,pvzq
                 ,zalq
                 ,zpr
                 ,zprq
                 ,pvq
                 ,ru
                 ,inn
                 ,nrc
                 ,sdate
                 ,ir
                 ,s031
                 ,k040
                 ,prod
                 ,k110
                 ,k070
                 ,k051
                 ,s260
                 ,r011
                 ,r012
                 ,s240
                 ,s180
                 ,s580
                 ,nls_rez
                 ,nls_rezn
                 ,s250
                 ,rukey(acc_rez) as acc_rez
                 ,fin_r
                 ,diskont
                 ,ruuser(isp) as isp
                 ,ob22
                 ,tip
                 ,spec
                 ,zal_bl
                 ,s280_290
                 ,zal_blq
                 ,rezd
                 ,rukey(acc_rezn) as acc_rezn
                 ,ob22_rez
                 ,ob22_rezn
                 ,ir0
                 ,irr0
                 ,nd_cp
                 ,sum_imp
                 ,sumq_imp
                 ,pv_zal
                 ,vkr
                 ,s_l
                 ,sq_l
                 ,zal_sv
                 ,zal_svq
                 ,grp
                 ,kol_sp
                 ,pvp
                 ,bv_30
                 ,bvq_30
                 ,rez_30
                 ,rezq_30
                 ,nls_rez_30
                 ,rukey(acc_rez_30) as acc_rez_30
                 ,bv_0
                 ,bvq_0
                 ,rez_0
                 ,rezq_0
                 ,nls_rez_0
                 ,rukey(acc_rez_0) as acc_rez_0
                 ,rez39
                 ,s250_23
                 ,kat39
                 ,rezq39
                 ,s250_39
                 ,rez23
                 ,rezq23
                 ,kat23
                 ,dat_mi
                 ,ob22_rez_30
                 ,ob22_rez_0
                 ,tipa
                 ,bvuq
                 ,bvu
                 ,ead
                 ,eadq
                 ,cr
                 ,crq
                 ,fin_351
                 ,kol_351
                 ,kpz
                 ,kl_351
                 ,lgd
                 ,ovkr
                 ,p_def
                 ,ovd
                 ,opd
                 ,zal_351
                 ,zalq_351
                 ,rc
                 ,rcq
                 ,ccf
                 ,tip_351
                 ,pd_0
                 ,fin_z
                 ,istval_351
                 ,rpb
                 ,s080
                 ,s080_z
                 ,ddd_6b
         from '||pkf('NBU23_REZ')||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
       FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.nbu23_rez 
                    (FDAT
                    ,KF
                    ,ID
                    ,RNK
                    ,NBS
                    ,KV
                    ,ND
                    ,CC_ID
                    ,ACC
                    ,NLS
                    ,BRANCH
                    ,FIN
                    ,OBS
                    ,KAT
                    ,K
                    ,IRR
                    ,ZAL
                    ,BV
                    ,PV
                    ,REZ
                    ,REZQ
                    ,DD
                    ,DDD
                    ,BVQ
                    ,CUSTTYPE
                    ,IDR
                    ,WDATE
                    ,OKPO
                    ,NMK
                    ,RZ
                    ,PAWN
                    ,ISTVAL
                    ,R013
                    ,REZN
                    ,REZNQ
                    ,ARJK
                    ,PVZ
                    ,PVZQ
                    ,ZALQ
                    ,ZPR
                    ,ZPRQ
                    ,PVQ
                    ,RU
                    ,INN
                    ,NRC
                    ,SDATE
                    ,IR
                    ,S031
                    ,K040
                    ,PROD
                    ,K110
                    ,K070
                    ,K051
                    ,S260
                    ,R011
                    ,R012
                    ,S240
                    ,S180
                    ,S580
                    ,NLS_REZ
                    ,NLS_REZN
                    ,S250
                    ,ACC_REZ
                    ,FIN_R
                    ,DISKONT
                    ,ISP
                    ,OB22
                    ,TIP
                    ,SPEC
                    ,ZAL_BL
                    ,S280_290
                    ,ZAL_BLQ
                    ,REZD
                    ,ACC_REZN
                    ,OB22_REZ
                    ,OB22_REZN
                    ,IR0
                    ,IRR0
                    ,ND_CP
                    ,SUM_IMP
                    ,SUMQ_IMP
                    ,PV_ZAL
                    ,VKR
                    ,S_L
                    ,SQ_L
                    ,ZAL_SV
                    ,ZAL_SVQ
                    ,GRP
                    ,KOL_SP
                    ,PVP
                    ,BV_30
                    ,BVQ_30
                    ,REZ_30
                    ,REZQ_30
                    ,NLS_REZ_30
                    ,ACC_REZ_30
                    ,BV_0
                    ,BVQ_0
                    ,REZ_0
                    ,REZQ_0
                    ,NLS_REZ_0
                    ,ACC_REZ_0
                    ,REZ39
                    ,S250_23
                    ,KAT39
                    ,REZQ39
                    ,S250_39
                    ,REZ23
                    ,REZQ23
                    ,KAT23
                    ,DAT_MI
                    ,OB22_REZ_30
                    ,OB22_REZ_0
                    ,TIPA
                    ,BVUQ
                    ,BVU
                    ,EAD
                    ,EADQ
                    ,CR
                    ,CRQ
                    ,FIN_351
                    ,KOL_351
                    ,KPZ
                    ,KL_351
                    ,LGD
                    ,OVKR
                    ,P_DEF
                    ,OVD
                    ,OPD
                    ,ZAL_351
                    ,ZALQ_351
                    ,RC
                    ,RCQ
                    ,CCF
                    ,TIP_351
                    ,PD_0
                    ,FIN_Z
                    ,ISTVAL_351
                    ,RPB
                    ,S080
                    ,S080_Z
                    ,DDD_6B
                    )
          VALUES 
                    (v_curs(indx).FDAT
                    ,v_curs(indx).KF
                    ,v_curs(indx).ID
                    ,v_curs(indx).RNK
                    ,v_curs(indx).NBS
                    ,v_curs(indx).KV
                    ,v_curs(indx).ND
                    ,v_curs(indx).CC_ID
                    ,v_curs(indx).ACC
                    ,v_curs(indx).NLS
                    ,v_curs(indx).BRANCH
                    ,v_curs(indx).FIN
                    ,v_curs(indx).OBS
                    ,v_curs(indx).KAT
                    ,v_curs(indx).K
                    ,v_curs(indx).IRR
                    ,v_curs(indx).ZAL
                    ,v_curs(indx).BV
                    ,v_curs(indx).PV
                    ,v_curs(indx).REZ
                    ,v_curs(indx).REZQ
                    ,v_curs(indx).DD
                    ,v_curs(indx).DDD
                    ,v_curs(indx).BVQ
                    ,v_curs(indx).CUSTTYPE
                    ,v_curs(indx).IDR
                    ,v_curs(indx).WDATE
                    ,v_curs(indx).OKPO
                    ,v_curs(indx).NMK
                    ,v_curs(indx).RZ
                    ,v_curs(indx).PAWN
                    ,v_curs(indx).ISTVAL
                    ,v_curs(indx).R013
                    ,v_curs(indx).REZN
                    ,v_curs(indx).REZNQ
                    ,v_curs(indx).ARJK
                    ,v_curs(indx).PVZ
                    ,v_curs(indx).PVZQ
                    ,v_curs(indx).ZALQ
                    ,v_curs(indx).ZPR
                    ,v_curs(indx).ZPRQ
                    ,v_curs(indx).PVQ
                    ,v_curs(indx).RU
                    ,v_curs(indx).INN
                    ,v_curs(indx).NRC
                    ,v_curs(indx).SDATE
                    ,v_curs(indx).IR
                    ,v_curs(indx).S031
                    ,v_curs(indx).K040
                    ,v_curs(indx).PROD
                    ,v_curs(indx).K110
                    ,v_curs(indx).K070
                    ,v_curs(indx).K051
                    ,v_curs(indx).S260
                    ,v_curs(indx).R011
                    ,v_curs(indx).R012
                    ,v_curs(indx).S240
                    ,v_curs(indx).S180
                    ,v_curs(indx).S580
                    ,v_curs(indx).NLS_REZ
                    ,v_curs(indx).NLS_REZN
                    ,v_curs(indx).S250
                    ,v_curs(indx).ACC_REZ
                    ,v_curs(indx).FIN_R
                    ,v_curs(indx).DISKONT
                    ,v_curs(indx).ISP
                    ,v_curs(indx).OB22
                    ,v_curs(indx).TIP
                    ,v_curs(indx).SPEC
                    ,v_curs(indx).ZAL_BL
                    ,v_curs(indx).S280_290
                    ,v_curs(indx).ZAL_BLQ
                    ,v_curs(indx).REZD
                    ,v_curs(indx).ACC_REZN
                    ,v_curs(indx).OB22_REZ
                    ,v_curs(indx).OB22_REZN
                    ,v_curs(indx).IR0
                    ,v_curs(indx).IRR0
                    ,v_curs(indx).ND_CP
                    ,v_curs(indx).SUM_IMP
                    ,v_curs(indx).SUMQ_IMP
                    ,v_curs(indx).PV_ZAL
                    ,v_curs(indx).VKR
                    ,v_curs(indx).S_L
                    ,v_curs(indx).SQ_L
                    ,v_curs(indx).ZAL_SV
                    ,v_curs(indx).ZAL_SVQ
                    ,v_curs(indx).GRP
                    ,v_curs(indx).KOL_SP
                    ,v_curs(indx).PVP
                    ,v_curs(indx).BV_30
                    ,v_curs(indx).BVQ_30
                    ,v_curs(indx).REZ_30
                    ,v_curs(indx).REZQ_30
                    ,v_curs(indx).NLS_REZ_30
                    ,v_curs(indx).ACC_REZ_30
                    ,v_curs(indx).BV_0
                    ,v_curs(indx).BVQ_0
                    ,v_curs(indx).REZ_0
                    ,v_curs(indx).REZQ_0
                    ,v_curs(indx).NLS_REZ_0
                    ,v_curs(indx).ACC_REZ_0
                    ,v_curs(indx).REZ39
                    ,v_curs(indx).S250_23
                    ,v_curs(indx).KAT39
                    ,v_curs(indx).REZQ39
                    ,v_curs(indx).S250_39
                    ,v_curs(indx).REZ23
                    ,v_curs(indx).REZQ23
                    ,v_curs(indx).KAT23
                    ,v_curs(indx).DAT_MI
                    ,v_curs(indx).OB22_REZ_30
                    ,v_curs(indx).OB22_REZ_0
                    ,v_curs(indx).TIPA
                    ,v_curs(indx).BVUQ
                    ,v_curs(indx).BVU
                    ,v_curs(indx).EAD
                    ,v_curs(indx).EADQ
                    ,v_curs(indx).CR
                    ,v_curs(indx).CRQ
                    ,v_curs(indx).FIN_351
                    ,v_curs(indx).KOL_351
                    ,v_curs(indx).KPZ
                    ,v_curs(indx).KL_351
                    ,v_curs(indx).LGD
                    ,v_curs(indx).OVKR
                    ,v_curs(indx).P_DEF
                    ,v_curs(indx).OVD
                    ,v_curs(indx).OPD
                    ,v_curs(indx).ZAL_351
                    ,v_curs(indx).ZALQ_351
                    ,v_curs(indx).RC
                    ,v_curs(indx).RCQ
                    ,v_curs(indx).CCF
                    ,v_curs(indx).TIP_351
                    ,v_curs(indx).PD_0
                    ,v_curs(indx).FIN_Z
                    ,v_curs(indx).ISTVAL_351
                    ,v_curs(indx).RPB
                    ,v_curs(indx).S080
                    ,v_curs(indx).S080_Z
                    ,v_curs(indx).DDD_6B
                    );
        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_nbu23_rez_dt;


  procedure fill_nbu23_rez_otcn_dt(p_date date default null, p_date_end date default null)
    is
    l_tab                   VARCHAR2(30) DEFAULT 'NBU23_REZ_OTCN';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_date                  DATE;
    l_date_end              DATE;


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_nbu23_rez_otcn_row IS TABLE OF NBU23_REZ_OTCN%ROWTYPE;
    v_curs t_nbu23_rez_otcn_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_NBU23_REZ_OTCN%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
         v_cur_exceptions (i).id                     := v_curs (v_indx).id;
         v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
         v_cur_exceptions (i).nbs                    := v_curs (v_indx).nbs;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_NBU23_REZ_OTCN
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
        l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
        --
         OPEN l_cur FOR
          'select
              fdat
              ,rukey(id) as id
              ,rukey(rnk) as rnk
              ,nbs
              ,kv
              ,rukey(nd) as nd
              ,cc_id
              ,rukey(acc) as acc
              ,nls
              ,branch
              ,fin
              ,obs
              ,kat
              ,k
              ,irr
              ,zal
              ,bv
              ,pv
              ,rez
              ,rezq
              ,dd
              ,ddd
              ,bvq
              ,custtype
              ,idr
              ,wdate
              ,okpo
              ,nmk
              ,rz
              ,pawn
              ,istval
              ,r013
              ,rezn
              ,reznq
              ,arjk
              ,pvz
              ,pvzq
              ,zalq
              ,zpr
              ,zprq
              ,pvq
              ,ru
              ,inn
              ,nrc
              ,sdate
              ,ir
              ,s031
              ,k040
              ,prod
              ,k110
              ,k070
              ,k051
              ,s260
              ,r011
              ,r012
              ,s240
              ,s180
              ,s580
              ,nls_rez
              ,nls_rezn
              ,s250
              ,rukey(acc_rez) as acc_rez
              ,fin_r
              ,diskont
              ,ruuser(isp) as isp
              ,ob22
              ,tip
              ,spec
              ,zal_bl
              ,s280_290
              ,zal_blq
              ,rezd
              ,rukey(acc_rezn) as acc_rezn
              ,ob22_rez
              ,ob22_rezn
              ,ir0
              ,irr0
              ,nd_cp
              ,sum_imp
              ,sumq_imp
              ,pv_zal
              ,vkr
              ,s_l
              ,sq_l
              ,zal_sv
              ,zal_svq
              ,grp
              ,kol_sp
              ,rukey(ref) as ref
              ,pvp
              ,bv_30
              ,bvq_30
              ,rez_30
              ,rezq_30
              ,nls_rez_30
              ,rukey(acc_rez_30) as acc_rez_30
              ,ob22_rez_30
              ,bv_0
              ,bvq_0
              ,rez_0
              ,rezq_0
              ,nls_rez_0
              ,rukey(acc_rez_0) as acc_rez_0
              ,ob22_rez_0
              ,kat39
              ,rez39
              ,rezq39
              ,s250_39
              ,rez23
              ,rezq23
              ,kat23
              ,s250_23
              ,dat_mi
              ,tipa
              ,bvuq
              ,bvu
              ,'''||g_kf||''' as kf
              , kl_351
              , ead
              , eadq
              , cr
              , crq
              , fin_351
              , kol_351
              , kpz
              , lgd
              , ovkr
              , p_def
              , ovd
              , opd
              , zal_351
              , zalq_351
              , rc
              , rcq
              , ccf
              , tip_351
              , pd_0
              , fin_z
              , istval_351
              , rpb
              , s080
              , s080_z
              , ddd_6b
         from '||pkf('NBU23_REZ_OTCN')||' where fdat between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.nbu23_rez_otcn
                                   VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_nbu23_rez_otcn_dt;

  procedure fill_nbu23_rez
    is
    l_tab                   VARCHAR2(30) DEFAULT 'NBU23_REZ';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_nbu23_rez_row IS TABLE OF nbu23_rez%ROWTYPE;
    v_curs t_nbu23_rez_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_NBU23_REZ%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
         v_cur_exceptions (i).id                     := v_curs (v_indx).id;
         v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
         v_cur_exceptions (i).nbs                    := v_curs (v_indx).nbs;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_NBU23_REZ
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        --
         OPEN l_cur FOR
          'select
                  fdat
                 ,rukey(id) as id
                 ,rukey(rnk) as rnk
                 ,nbs
                 ,kv
                 ,rukey(nd) as nd
                 ,cc_id
                 ,rukey(acc) as acc
                 ,nls
                 ,branch
                 ,fin
                 ,obs
                 ,kat
                 ,k
                 ,irr
                 ,zal
                 ,bv
                 ,pv
                 ,rez
                 ,rezq
                 ,dd
                 ,ddd
                 ,bvq
                 ,custtype
                 ,idr
                 ,wdate
                 ,okpo
                 ,nmk
                 ,rz
                 ,pawn
                 ,istval
                 ,r013
                 ,rezn
                 ,reznq
                 ,arjk
                 ,pvz
                 ,pvzq
                 ,zalq
                 ,zpr
                 ,zprq
                 ,pvq
                 ,ru
                 ,inn
                 ,nrc
                 ,sdate
                 ,ir
                 ,s031
                 ,k040
                 ,prod
                 ,k110
                 ,k070
                 ,k051
                 ,s260
                 ,r011
                 ,r012
                 ,s240
                 ,s180
                 ,s580
                 ,nls_rez
                 ,nls_rezn
                 ,s250
                 ,rukey(acc_rez) as acc_rez
                 ,fin_r
                 ,diskont
                 ,ruuser(isp) as isp
                 ,ob22
                 ,tip
                 ,spec
                 ,zal_bl
                 ,s280_290
                 ,zal_blq
                 ,rezd
                 ,rukey(acc_rezn) as acc_rezn
                 ,ob22_rez
                 ,ob22_rezn
                 ,ir0
                 ,irr0
                 ,nd_cp
                 ,sum_imp
                 ,sumq_imp
                 ,pv_zal
                 ,vkr
                 ,s_l
                 ,sq_l
                 ,zal_sv
                 ,zal_svq
                 ,grp
                 ,kol_sp
                 ,pvp
                 ,bv_30
                 ,bvq_30
                 ,rez_30
                 ,rezq_30
                 ,nls_rez_30
                 ,rukey(acc_rez_30) as acc_rez_30
                 ,bv_0
                 ,bvq_0
                 ,rez_0
                 ,rezq_0
                 ,nls_rez_0
                 ,rukey(acc_rez_0) as acc_rez_0
                 ,rez39
                 ,s250_23
                 ,kat39
                 ,rezq39
                 ,s250_39
                 ,rez23
                 ,rezq23
                 ,kat23
                 ,dat_mi
                 ,ob22_rez_30
                 ,ob22_rez_0
                 ,tipa
                 ,bvuq
                 ,bvu
                 ,'''||g_kf||''' as kf
                 ,ead
                 ,eadq
                 ,cr
                 ,crq
                 ,fin_351
                 ,kol_351
                 ,kpz
                 ,kl_351
                 ,lgd
                 ,ovkr
                 ,p_def
                 ,ovd
                 ,opd
                 ,zal_351
                 ,zalq_351
                 ,rc
                 ,rcq
                 ,ccf
                 ,tip_351
                 ,pd_0
                 ,fin_z
                 ,istval_351
                 ,rpb
                 ,s080
                 ,s080_z
                 ,ddd_6b
         from '||pkf('NBU23_REZ');
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.nbu23_rez
                                   VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_nbu23_rez;

  procedure fill_nbu23_rez_otcn
    is
    l_tab                   VARCHAR2(30) DEFAULT 'NBU23_REZ_OTCN';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);

     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_nbu23_rez_otcn_row IS TABLE OF NBU23_REZ_OTCN%ROWTYPE;
    v_curs t_nbu23_rez_otcn_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_NBU23_REZ_OTCN%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).fdat                   := v_curs (v_indx).fdat;
         v_cur_exceptions (i).id                     := v_curs (v_indx).id;
         v_cur_exceptions (i).rnk                    := v_curs (v_indx).rnk;
         v_cur_exceptions (i).nbs                    := v_curs (v_indx).nbs;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_NBU23_REZ_OTCN
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);

       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        --
         OPEN l_cur FOR
          'select
              fdat
              ,rukey(id) as id
              ,rukey(rnk) as rnk
              ,nbs
              ,kv
              ,rukey(nd) as nd
              ,cc_id
              ,rukey(acc) as acc
              ,nls
              ,branch
              ,fin
              ,obs
              ,kat
              ,k
              ,irr
              ,zal
              ,bv
              ,pv
              ,rez
              ,rezq
              ,dd
              ,ddd
              ,bvq
              ,custtype
              ,idr
              ,wdate
              ,okpo
              ,nmk
              ,rz
              ,pawn
              ,istval
              ,r013
              ,rezn
              ,reznq
              ,arjk
              ,pvz
              ,pvzq
              ,zalq
              ,zpr
              ,zprq
              ,pvq
              ,ru
              ,inn
              ,nrc
              ,sdate
              ,ir
              ,s031
              ,k040
              ,prod
              ,k110
              ,k070
              ,k051
              ,s260
              ,r011
              ,r012
              ,s240
              ,s180
              ,s580
              ,nls_rez
              ,nls_rezn
              ,s250
              ,rukey(acc_rez) as acc_rez
              ,fin_r
              ,diskont
              ,ruuser(isp) as isp
              ,ob22
              ,tip
              ,spec
              ,zal_bl
              ,s280_290
              ,zal_blq
              ,rezd
              ,rukey(acc_rezn) as acc_rezn
              ,ob22_rez
              ,ob22_rezn
              ,ir0
              ,irr0
              ,nd_cp
              ,sum_imp
              ,sumq_imp
              ,pv_zal
              ,vkr
              ,s_l
              ,sq_l
              ,zal_sv
              ,zal_svq
              ,grp
              ,kol_sp
              ,rukey(ref) as ref
              ,pvp
              ,bv_30
              ,bvq_30
              ,rez_30
              ,rezq_30
              ,nls_rez_30
              ,rukey(acc_rez_30) as acc_rez_30
              ,ob22_rez_30
              ,bv_0
              ,bvq_0
              ,rez_0
              ,rezq_0
              ,nls_rez_0
              ,rukey(acc_rez_0) as acc_rez_0
              ,ob22_rez_0
              ,kat39
              ,rez39
              ,rezq39
              ,s250_39
              ,rez23
              ,rezq23
              ,kat23
              ,s250_23
              ,dat_mi
              ,tipa
              ,bvuq
              ,bvu
              ,'''||g_kf||''' as kf
              , kl_351
              , ead
              , eadq
              , cr
              , crq
              , fin_351
              , kol_351
              , kpz
              , lgd
              , ovkr
              , p_def
              , ovd
              , opd
              , zal_351
              , zalq_351
              , rc
              , rcq
              , ccf
              , tip_351
              , pd_0
              , fin_z
              , istval_351
              , rpb
              , s080
              , s080_z
              , ddd_6b
         from '||pkf('NBU23_REZ_OTCN');
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.nbu23_rez_otcn
                                   VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_nbu23_rez_otcn;

  procedure fill_rez_log
    is
      begin
      mgr_utl.sync_table_auto('REZ_LOG',false,'row_id,"rukey(row_id)",user_id,"ruuser(user_id)"');
  end fill_rez_log;

  procedure fill_rez_protocol
    is
      begin
      mgr_utl.sync_table_auto('REZ_PROTOCOL',false,'USERID,"ruuser(USERID)",REF,"rukey(REF)"');
  end fill_rez_protocol;

  procedure fill_acc_fin_obs_kat
    is
      begin
      mgr_utl.sync_table_auto('ACC_FIN_OBS_KAT',false,'acc,"rukey(acc)"');
  end fill_acc_fin_obs_kat;

  procedure fill_tmp_rez_obesp23
    is
      begin
      mgr_utl.sync_table_auto('TMP_REZ_OBESP23',false,'userid,"ruuser(userid)",nd,"rukey(nd)",rnk,"rukey(rnk)",accs,"rukey(accs)",accz,"rukey(accz)"');
  end fill_tmp_rez_obesp23;

  procedure fill_tmp_rez_zalog23
    is
      begin
      mgr_utl.sync_table_auto('TMP_REZ_ZALOG23',false,'userid,"ruuser(userid)",nd,"rukey(nd)",accs,"rukey(accs)",accz,"rukey(accz)"');
  end fill_tmp_rez_zalog23;

  procedure fill_rez_doc_maket
    is
      begin
      mgr_utl.sync_table_auto('REZ_DOC_MAKET',false,'userid,"ruuser(userid)",ref,"rukey(ref)"');
  end fill_rez_doc_maket;

  procedure fill_test_finrez
    is
      begin
      mgr_utl.sync_table_auto('TEST_FINREZ',false,'acc,"rukey(acc)"');
  end fill_test_finrez;

  procedure fill_ebk_card_qlt_log
    is
      begin
      mgr_utl.sync_table_auto('EBK_CARD_QLT_LOG',false,'RNK,"rukey(RNK)",USER_ID,"ruuser(USER_ID)"');
  end fill_ebk_card_qlt_log;

  procedure fill_ebk_client_analysis_err
    is
      begin
      mgr_utl.sync_table_auto('EBK_CLIENT_ANALYSIS_ERRORS',false,'RNK,"rukey(RNK)"');
  end fill_ebk_client_analysis_err;

  procedure fill_ebk_duplicate_groups
    is
      begin
      mgr_utl.sync_table_auto('EBK_DUPLICATE_GROUPS',false,'M_RNK,"rukey(M_RNK)",D_RNK,"rukey(D_RNK)"');
  end fill_ebk_duplicate_groups;

  procedure fill_ebk_queue_updatecard
    is
      begin
      mgr_utl.sync_table_auto('EBK_QUEUE_UPDATECARD',false,'RNK,"rukey(RNK)"');
  end fill_ebk_queue_updatecard;

  procedure fill_ebk_qualityattr_gourps
    is
      begin
      mgr_utl.sync_table_auto('EBK_QUALITYATTR_GOURPS',false,'RNK,"rukey(RNK)"');
  end fill_ebk_qualityattr_gourps;

  procedure fill_ebkc_duplicate
    is
      begin
      mgr_utl.sync_table_auto('EBKC_DUPLICATE',false,'RNK,"rukey(RNK)",DUP_RNK,"rukey(DUP_RNK)"');
  end fill_ebkc_duplicate;

  procedure fill_ebkc_duplicate_groups
    is
      begin
      mgr_utl.sync_table_auto('EBKC_DUPLICATE_GROUPS',false,'M_RNK,"rukey(M_RNK)",D_RNK,"rukey(D_RNK)"');
  end fill_ebkc_duplicate_groups;

  procedure fill_ebkc_qualityattr_groups
    is
      begin
      init();
      --
      mgr_utl.sync_table('EBKC_QUALITYATTR_GROUPS',
                         'insert into  BARS.EBKC_QUALITYATTR_GROUPS(batchid, kf, rnk, name, quality, cust_type)
                         select batchid, '''||g_kf||''' as kf, rukey(rnk) as rnk, name, quality, cust_type
                         from ' ||pkf('EBKC_QUALITYATTR_GROUPS'),
                         false);
  end fill_ebkc_qualityattr_groups;

  --procedure fill_ebkc_queue_updatecard
  --  is
  --    begin
  --    mgr_utl.sync_table_auto('EBKC_QUEUE_UPDATECARD',false,'RNK,"rukey(RNK)"');
  --end fill_ebkc_queue_updatecard;

  procedure fill_ebkc_req_updatecard
    is
      begin
      init();
      --
      mgr_utl.sync_table('EBKC_REQ_UPDATECARD',
                         'insert into  BARS.EBKC_REQ_UPDATECARD(batchid, kf, rnk, quality, defaultgroupquality, group_id, cust_type)
                         select batchid, '''||g_kf||''' as kf, rukey(rnk) as rnk, quality, defaultgroupquality, group_id, cust_type
                         from ' ||pkf('EBKC_REQ_UPDATECARD'),
                         false);
  end fill_ebkc_req_updatecard;

  procedure fill_ebkc_req_updcard_attr
    is
      begin
      init();
      --
      mgr_utl.sync_table('EBKC_REQ_UPDCARD_ATTR',
                         'insert into  BARS.EBKC_REQ_UPDCARD_ATTR(kf, rnk, quality, name, value, recommendvalue, descr, cust_type)
                         select '''||g_kf||''' as kf, rukey(rnk) as rnk, quality, name, value, recommendvalue, descr, cust_type
                         from ' ||pkf('EBKC_REQ_UPDCARD_ATTR'),
                         false);
  end fill_ebkc_req_updcard_attr;

  procedure fill_ebkc_sendcards_hist
    is
      begin
      mgr_utl.sync_table_auto('EBKC_SENDCARDS_HIST',false,'RNK,"rukey(RNK)"');
  end fill_ebkc_sendcards_hist;

  procedure fill_otc_arc_cc_trans
    is
      begin
      mgr_utl.sync_table_auto('OTC_ARC_CC_TRANS',false,'acc,"rukey(acc)",ref,"rukey(ref)",refp,"rukey(refp)"');
  end fill_otc_arc_cc_trans;

  procedure fill_otc_arc_info
    is
      begin
      mgr_utl.sync_table_auto('OTC_ARC_INFO',false,'userid,"ruuser(userid)"');
  end fill_otc_arc_info;

  procedure fill_otc_ff8_history_acc
    is
      begin
      mgr_utl.sync_table_auto('OTC_FF8_HISTORY_ACC',false,'acc,"rukey(acc)",accc,"rukey(accc)",nd,"rukey(nd)",rnk,"rukey(rnk)",staff,"ruuser(staff)"');
  end fill_otc_ff8_history_acc;

  procedure fill_otcn_arch_pereoc
    is
      begin
      mgr_utl.sync_table_auto('OTCN_ARCH_PEREOC',false,'acc,"rukey(acc)"');
  end fill_otcn_arch_pereoc;

  procedure fill_otcn_del_3a
    is
      begin
      mgr_utl.sync_table_auto('OTCN_DEL_3A',false,'acc,"rukey(acc)",isp,"ruuser(isp)"');
  end fill_otcn_del_3a;

  procedure fill_otcn_f08_debz
    is
      begin
      mgr_utl.sync_table_auto('OTCN_F08_DEBZ',false,'accd,"rukey(accd)",acck,"rukey(acck)",isp,"ruuser(isp)",nd,"rukey(nd)"');
  end fill_otcn_f08_debz;

  procedure fill_otcn_f08_history
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'OTCN_F08_HISTORY';
      begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('OTCN_F08_HISTORY',
                         'insert into  BARS.OTCN_F08_HISTORY(accd, tt, ref, kv, nlsd, s, sq, fdat, nazn, acck, nlsk, isp, userid, tobo, kf, vob)
                         select rukey(accd) as accd, tt, ref, kv, nlsd, s, sq, fdat, nazn, rukey(acck) as acck, nlsk, null as isp, ruuser(userid) as userid, tobo, '''||g_kf||''' as kf, vob
                         from ' ||pkf('OTCN_F08_HISTORY')||' where fdat >= to_date(''01.01.2016'', ''DD.MM.YYYY'') log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_otcn_f08_history;

  procedure fill_otcn_f42_history
    is
      begin
      mgr_utl.sync_table_auto('OTCN_F42_HISTORY',false,'userid,"ruuser(userid)",rnk,"rukey(rnk)"');
  end fill_otcn_f42_history;

  procedure fill_otcn_f42_pr
    is
      begin
      mgr_utl.sync_table_auto('OTCN_F42_PR',false,'acc,"rukey(acc)"');
  end fill_otcn_f42_pr;

  procedure fill_otcn_f71_history
    is
      begin
      mgr_utl.sync_table_auto('OTCN_F71_HISTORY',false,'acc,"rukey(acc)",rnk,"rukey(rnk)",nd,"rukey(nd)"');
  end fill_otcn_f71_history;

  procedure fill_otcn_f71_history_sb
    is
      begin
      mgr_utl.sync_table_auto('OTCN_F71_HISTORY_SB',false,'acc,"rukey(acc)",rnk,"rukey(rnk)",nd,"rukey(nd)"');
  end fill_otcn_f71_history_sb;

  procedure fill_otcn_flag_blk
    is
      begin
      mgr_utl.sync_table_auto('OTCN_FLAG_BLK',false,'isp,"ruuser(isp)"');
  end fill_otcn_flag_blk;

  procedure fill_otcn_history
    is
      begin
      mgr_utl.sync_table_auto('OTCN_HISTORY',false,'acc,"rukey(acc)",isp,"ruuser(isp)",nd,"rukey(nd)",rnk,"rukey(rnk)",userid,"ruuser(userid)",recid,"rukey(recid)"');
  end fill_otcn_history;

  procedure fill_otcn_kap_sb
    is
      begin
      mgr_utl.sync_table_auto('OTCN_KAP_SB',false,'acc,"rukey(acc)"');
  end fill_otcn_kap_sb;

  procedure fill_otcn_lim_sb
    is
      begin
      mgr_utl.sync_table_auto('OTCN_LIM_SB',false,'acc,"rukey(acc)"');
  end fill_otcn_lim_sb;

  procedure fill_otcn_log
    is
    l_max_id  NUMBER;
      begin
      --решили не мигрировать
      --mgr_utl.sync_table_auto('OTCN_LOG',false,'userid,"ruuser(userid)"');
          begin
            bc.home();
            select trunc(nvl(max(id), 0)) + 1 into l_max_id from bars.otcn_log;
            mgr_utl.reset_sequence('s_otcn_log', l_max_id);
          exception when others then
            rollback;
            mgr_utl.save_error();
          end;
   end fill_otcn_log;

  procedure fill_kl_f00_int
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'KL_F00_INT$LOCAL';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_kl_f00_int;

  procedure fill_kl_f8b
    is
      begin
      mgr_utl.sync_table_auto('KL_F8B',false,'rnk,"rukey(rnk)"');
  end fill_kl_f8b;

  procedure fill_kl_ff1
    is
    l_tab     VARCHAR2(30 CHAR) DEFAULT 'KL_FF1';
    begin
      bpa.disable_policies(l_tab);
      mgr_oschad.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_kl_ff1;

  procedure fill_kf91
    is
      begin
      mgr_utl.sync_table_auto('KF91',false,'rnk,"rukey(rnk)"');
  end fill_kf91;

  procedure fill_kf77
    is
      begin
      mgr_utl.sync_table_auto('KF77',false,'rnk,"rukey(rnk)"');
  end fill_kf77;

  procedure fill_mway_log
    is
      begin
      mgr_utl.sync_table_auto('MWAY_LOG',false,'ID,"rukey(ID)",USERRNK,"rukey(USERRNK)"');
  end fill_mway_log;

  procedure fill_mway_match
    is
      begin
      mgr_utl.sync_table_auto('MWAY_MATCH',false,'ID,"rukey(ID)",REF_TR,"rukey(REF_TR)",REF_FEE_TR,"rukey(REF_FEE_TR)"');
  end fill_mway_match;

    procedure fill_cig_customers
    is
      begin
      mgr_utl.sync_table_auto('CIG_CUSTOMERS',false,'RNK,"rukey(RNK)"');
  end fill_cig_customers;

  procedure fill_cig_cust_individual
    is
      begin
      init();
      --
      mgr_utl.sync_table('CIG_CUST_INDIVIDUAL',
                         'insert into  BARS.CIG_CUST_INDIVIDUAL(cust_id, role_id, first_name, surname, fathers_name, gender, classification, birth_surname, date_birth, place_birth,
                                                                residency, citizenship, neg_status, education, marital_status, position, cust_key, passp_ser, passp_num,
                                                                passp_iss_date, passp_exp_date, passp_organ, phone_office, phone_mobile, phone_fax, email, website, fact_territory_id,
                                                                fact_street_buildnum, fact_post_index, reg_territory_id, reg_street_buildnum, reg_post_index, branch)
                         select cust_id, role_id, first_name, surname, fathers_name, gender, classification, birth_surname, date_birth, place_birth,
                                residency, citizenship, neg_status, education, marital_status, position, cust_key, passp_ser, passp_num,
                                passp_iss_date, passp_exp_date, passp_organ, phone_office, phone_mobile, phone_fax, email, website, fact_territory_id,
                                fact_street_buildnum, fact_post_index, reg_territory_id, reg_street_buildnum, reg_post_index, branch
                         from ' ||pkf('CIG_CUST_INDIVIDUAL')||' where fact_territory_id is not null ',
                         false);
  end fill_cig_cust_individual;

  procedure fill_cig_dog_general
    is
    l_tab     VARCHAR2(30) DEFAULT 'CIG_DOG_GENERAL';
    begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('CIG_DOG_GENERAL',false,'ND,"rukey(ND)"');
      bpa.enable_policies(l_tab);
  end fill_cig_dog_general;

  procedure fill_cig_dog_stop
    is
      begin
      mgr_utl.sync_table_auto('CIG_DOG_STOP',false,'STAFF_ID,"rukey(STAFF_ID)"');
  end fill_cig_dog_stop;

  procedure fill_cig_dog_sync_params
    is
      begin
      mgr_utl.sync_table_auto('CIG_DOG_SYNC_PARAMS',false,'ND,"rukey(ND)"');
  end fill_cig_dog_sync_params;

  procedure fill_cig_events
    is
    l_max_evt_id  NUMBER;
      begin
          begin
            bc.home;
            select nvl(max(evt_id), 0) + 1 into l_max_evt_id from bars.CIG_EVENTS;
            bc.go(g_kf);
            mgr_utl.reset_sequence('S_CIG_EVENTS', l_max_evt_id);
          exception when others then
            rollback;
            mgr_utl.save_error();
          end;
          mgr_utl.sync_table('CIG_EVENTS',
                              'INSERT INTO CIG_EVENTS
                              SELECT S_CIG_EVENTS.nextval evt_id, evt_date, evt_uname, evt_state_id, evt_message, evt_oraerr, 
                                     rukey(EVT_ND) evt_nd, rukey(EVT_RNK) evt_rnk, branch, evt_dtype, evt_custtype                       
                              FROM '||pkf('CIG_EVENTS')||' WHERE evt_date >= ADD_MONTHS(TRUNC(sysdate, ''MM''), -3) + 1/86400', false);
   end fill_cig_events;

  procedure fill_cig_events_dt(p_date date default null, p_date_end date default null, p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab                   VARCHAR2(30) DEFAULT 'cig_events';
    p                       CONSTANT VARCHAR2(62) := G_PKG||'.fill_'||l_tab;
    v_count                 PLS_INTEGER := 0;
    c_limit                 PLS_INTEGER := 50000;
    l_cur                   SYS_REFCURSOR;
    c_n                     PLS_INTEGER := 0;
    l_migration_start_time  date default sysdate;
    l_start_time            timestamp default current_timestamp;
    l_end_time              timestamp default current_timestamp;
    l_rowcount              number default 0;
    l_time_duration         interval day(3) to second(3);
    l_date                  DATE;
    l_date_end              DATE;


     /* "Exceptions encountered in FORALL" exception... */
     bulk_exceptions   EXCEPTION;
     PRAGMA EXCEPTION_INIT (bulk_exceptions, -24381);

    /*
     * Source data record and associative array type. Needed to
     * enable LIMIT-based fetching...
    */

    TYPE t_cig_events_row IS TABLE OF cig_events%ROWTYPE;
    v_curs t_cig_events_row;
---------------------------------------------------------------------------------
      /*local procedure for save error to err$table*/
    PROCEDURE error_logging IS
      /* Associative array type of the exceptions table... */
      TYPE t_cur_exception IS TABLE OF ERR$_cig_events%ROWTYPE INDEX BY PLS_INTEGER;

      v_cur_exceptions   t_cur_exception;

      v_indx          PLS_INTEGER;

      /* Emulate DML error logging behaviour... */
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      FOR i IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
         v_indx := SQL%BULK_EXCEPTIONS (i).ERROR_INDEX;

         /* Populate as many values as available... */
         v_cur_exceptions (i).ora_err_number$        := SQL%BULK_EXCEPTIONS (i).ERROR_CODE;
         v_cur_exceptions (i).ora_err_mesg$          := SQLERRM (SQL%BULK_EXCEPTIONS (i).ERROR_CODE * -1);
         v_cur_exceptions (i).ora_err_tag$           := 'FORALL ERROR LOGGING';
         v_cur_exceptions (i).ora_err_optyp$         := 'I';
         v_cur_exceptions (i).evt_date               := v_curs (v_indx).evt_date;
         v_cur_exceptions (i).evt_id                 := v_curs (v_indx).evt_id;
         v_cur_exceptions (i).evt_rnk                := v_curs (v_indx).evt_rnk;
         v_cur_exceptions (i).evt_nd                 := v_curs (v_indx).evt_nd;

      END LOOP;

      /* Load the exceptions into the exceptions table... */
      FORALL i IN INDICES OF v_cur_exceptions
         INSERT INTO ERR$_cig_events
              VALUES v_cur_exceptions (i);

      COMMIT;
    END error_logging;

    BEGIN

    bc.go(g_kf);
    --
    mgr_utl.before_fill(l_tab);
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
    execute immediate 'alter session set nls_date_format = ''dd.mm.yyyy''';
    --
       BEGIN
        l_migration_start_time := sysdate;
        l_start_time           := current_timestamp;
        l_date                 := coalesce(to_char(p_date, 'dd.mm.yyyy'), '01.01.1970');
        l_date_end             := coalesce(to_char(p_date_end, 'dd.mm.yyyy'), '31.12.2049');
        --
         OPEN l_cur FOR
          'SELECT S_CIG_EVENTS.nextval evt_id, evt_date, evt_uname, evt_state_id, evt_message, evt_oraerr, 
                  rukey(EVT_ND) evt_nd, rukey(EVT_RNK) evt_rnk, branch, evt_dtype, evt_custtype                       
           from '||pkf(l_tab, p_schema, p_dblink)||' where evt_date between to_date('''||l_date||''', ''dd.mm.yyyy'') and  to_date('''||l_date_end||''', ''dd.mm.yyyy'')';
              --
       LOOP
         FETCH l_cur BULK COLLECT INTO v_curs LIMIT c_limit;
           EXIT WHEN v_curs.COUNT = 0;

       BEGIN
        FORALL indx IN INDICES OF v_curs SAVE EXCEPTIONS
          INSERT INTO bars.cig_events
                                   VALUES v_curs(indx);

        EXCEPTION
               WHEN bulk_exceptions THEN
                  c_n := c_n + SQL%ROWCOUNT;
                  error_logging ();
       END;
        COMMIT;
          v_count := v_count + c_limit;
            dbms_application_info.set_action('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
            dbms_application_info.set_client_info('INS: ' || to_char(v_count)||'/'||to_char(sql%rowcount)||'/ TBL: '||l_tab||' ERR: ' || to_char(c_n));
       END LOOP;
       l_rowcount := l_cur%rowcount;
       CLOSE l_cur;
         l_end_time := current_timestamp;
         l_time_duration:= (l_end_time - l_start_time);
         mgr_log.p_save_log_info_mesg(ip_migration_id                   => g_kf
                                      ,ip_migration_start_time          => l_migration_start_time
                                      ,ip_table_name                    => l_tab
                                      ,ip_operation                     => p
                                      ,ip_row_count                     => l_rowcount
                                      ,ip_task_start_time               => l_start_time
                                      ,ip_task_end_time                 => l_end_time
                                      ,ip_time_duration                 => l_time_duration
                                      ,ip_log_message                   => 'Done'
                                       );
        EXCEPTION
              WHEN OTHERS THEN
                   --mgr_utl.save_error();
          mgr_log.p_save_log_error(ip_migration_id                      => g_kf
                                  ,ip_migration_start_time              => l_migration_start_time
                                  ,ip_table_name                        => l_tab
                                  ,ip_operation                         => p
                                  ,ip_row_count                         => l_rowcount
                                  ,ip_task_start_time                   => l_start_time
                                  ,ip_task_end_time                     => l_end_time
                                  ,ip_time_duration                     => l_time_duration
                                  ,ip_log_message                       => 'Error'
                                  );
       -- Clear collection for v_curs
      v_curs.delete;
      END;
  --
  bc.home();

  mgr_utl.finalize();
  --
  trace('%s: finished', p);
  --
  end fill_cig_events_dt;

  procedure fill_icb_events
    is
      begin
      mgr_utl.sync_table_auto('ICB_EVENTS',false,'EVT_ND,"rukey(EVT_ND)",EVT_RNK,"rukey(EVT_RNK)"');
  end fill_icb_events;

  procedure fill_asvo_immobile
    is
      begin
      mgr_utl.sync_table_auto('ASVO_IMMOBILE',false,'ID,"rukey(ID)",REF,"rukey(REF)",REFOUT,"rukey(REFOUT)",DPTID,"rukey(DPTID)"');
  end fill_asvo_immobile;

  procedure fill_batch_immobile
    is
      begin
      mgr_utl.sync_table_auto('BATCH_IMMOBILE',false,'ID,"rukey(ID)",USERID,"ruuser(USERID)"');
  end fill_batch_immobile;

  procedure fill_prvn_fin_deb
    is
      begin
      mgr_utl.sync_table_auto('PRVN_FIN_DEB',false,'ACC_SS,"rukey(ACC_SS)",ACC_SP,"rukey(ACC_SP)"');
  end fill_prvn_fin_deb;

  procedure fill_prvn_flow_details
    is
      begin
      mgr_utl.sync_table_auto('PRVN_FLOW_DETAILS',false,'ID,"rukey(ID)",ND,"rukey(ND)"');
  end fill_prvn_flow_details;

  procedure fill_prvn_flow_deals_const
    is
      begin
      mgr_utl.sync_table_auto('PRVN_FLOW_DEALS_CONST',false,'ID,"rukey(ID)",ND,"rukey(ND)",ACC,"rukey(ACC)",ACC8,"rukey(ACC8)",RNK,"rukey(RNK)"');
  end fill_prvn_flow_deals_const;

  procedure fill_prvn_flow_deals_var
    is
      begin
      mgr_utl.sync_table_auto('PRVN_FLOW_DEALS_VAR',false,'ID,"rukey(ID)",RNK,"rukey(RNK)"');
  end fill_prvn_flow_deals_var;

  procedure fill_prvn_autoevent_arc
    is
      begin
      mgr_utl.sync_table_auto('PRVN_AUTOEVENT_ARC',false,'ID,"rukey(ID)",REF_AGR,"rukey(REF_AGR)",RNK,"rukey(RNK)",CREATE_USER,"ruuser(CREATE_USER)"');
  end fill_prvn_autoevent_arc;

  procedure fill_prvn_fv_rez
    is
      begin
      mgr_utl.sync_table_auto('PRVN_FV_REZ',false,'RNK_CLIENT,"rukey(RNK_CLIENT)"');
  end fill_prvn_fv_rez;

  procedure fill_prvn_bv_details
    is
      begin
      mgr_utl.sync_table_auto('PRVN_BV_DETAILS',false,'ND,"rukey(ND)"');
  end fill_prvn_bv_details;

  procedure fill_prvn_osa
    is
      begin
      mgr_utl.sync_table_auto('PRVN_OSA',false,'ND,"rukey(ND)",RNK,"rukey(RNK)"');
  end fill_prvn_osa;

  procedure fill_prvn_loss_delay_days
    is
      begin
      mgr_utl.sync_table_auto('PRVN_LOSS_DELAY_DAYS',false,'REF_AGR,"rukey(REF_AGR)"');
  end fill_prvn_loss_delay_days;

  procedure fill_alt_bpk
    is
      begin
      mgr_utl.sync_table_auto('ALT_BPK',false,'ID,"rukey(ID)",REF,"rukey(REF)",USERID,"ruuser(USERID)"');
  end fill_alt_bpk;

  procedure fill_bpk_acc
    is
    l_tab                   VARCHAR2(30 CHAR) DEFAULT 'BPK_ACC';
      begin
      mgr_utl.mantain_error_table(l_tab);
      init();
      mgr_utl.sync_table('BPK_ACC',
                         'insert into  BARS.BPK_ACC(acc_pk, acc_ovr, acc_9129, acc_tovr, kf, acc_3570, acc_2208, nd, product_id,
                                                    acc_2207, acc_3579, acc_2209, acc_w4, fin, fin23, obs23, kat23, k23, dat_end, kol_sp, s250, grp, dat_close)
                         select rukey(ACC_PK) as acc_pk, rukey(ACC_OVR) as acc_ovr, rukey(ACC_9129) as acc_9129, rukey(ACC_TOVR) as acc_tovr, '''||g_kf||''' as kf, rukey(ACC_3570) as acc_3570, rukey(ACC_2208) as acc_2208, rukey(ND) as nd, product_id,
                                rukey(ACC_2207) as acc_2207, rukey(ACC_3579) as acc_3579, acc_2209, rukey(ACC_W4) as acc_w4, fin, fin23, obs23, kat23, k23, dat_end, kol_sp, s250, grp, dat_close
                         from ' ||pkf('BPK_ACC')||' log errors reject limit unlimited',
                         false);
      --
      trace('%s', get_errinfo('ERR$_'||l_tab));
      --
  end fill_bpk_acc;

  procedure fill_bpk_arsenal_str
    is
      begin
      mgr_utl.sync_table_auto('BPK_ARSENAL_STR',false,'ID,"rukey(ID)"');
  end fill_bpk_arsenal_str;

  procedure fill_bpk_arsenal_tarif
    is
      begin
      mgr_utl.sync_table_auto('BPK_ARSENAL_TARIF',false,'ID,"rukey(ID)"');
  end fill_bpk_arsenal_tarif;

  procedure fill_bpk_parameters
    is
    l_tab     VARCHAR2(30) DEFAULT 'BPK_PARAMETERS';
    begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('BPK_PARAMETERS',false,'ND,"rukey(ND)"');
      bpa.enable_policies(l_tab);
  end fill_bpk_parameters;

  procedure fill_bpk_pktow4
    is
    l_tab     VARCHAR2(30) DEFAULT 'BPK_PKTOW4';
    begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('BPK_PKTOW4',false,'ID,"rukey(ID)",ND,"rukey(ND)"');
      bpa.enable_policies(l_tab);
  end fill_bpk_pktow4;

  procedure fill_bpk_proect
    is
      begin
      mgr_utl.sync_table_auto('BPK_PROECT',false,'ID,"rukey(ID)"');
  end fill_bpk_proect;

  procedure fill_ow_acc_history
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_ACC_HISTORY';
    begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_ACC_HISTORY',false,'ACC,"rukey(ACC)", K_DONEBY,"ruuser(K_DONEBY)"');
      bpa.enable_policies(l_tab);
  end fill_ow_acc_history;

  procedure fill_ow_acc_que
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_ACC_QUE';
    begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_ACC_QUE',false,'ACC,"rukey(ACC)"');
      bpa.enable_policies(l_tab);
  end fill_ow_acc_que;

  procedure fill_ow_cl_info_data_err
    is
      begin
      mgr_utl.sync_table_auto('OW_CL_INFO_DATA_ERROR',false,'RNK,"rukey(RNK)"');
  end fill_ow_cl_info_data_err;

  procedure fill_ow_cng_data
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_CNG_DATA';
    begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_CNG_DATA',false,'ID,"rukey(ID)",CONTRACT_ID,"rukey(CONTRACT_ID)",CONTRACT_ACC,"rukey(CONTRACT_ACC)"');
      bpa.enable_policies(l_tab);
  end fill_ow_cng_data;

  procedure fill_ow_cng_files
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_CNG_FILES';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_CNG_FILES',false,'ID,"rukey(ID)"');
      bpa.enable_policies(l_tab);
  end fill_ow_cng_files;

  procedure fill_ow_crvacc_close
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_CRVACC_CLOSE';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_CRVACC_CLOSE',false,'ACC,"rukey(ACC)"');
      bpa.enable_policies(l_tab);
  end fill_ow_crvacc_close;

  procedure fill_ow_crvacc_request
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_CRVACC_REQUEST';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_CRVACC_REQUEST',false,'ACC,"rukey(ACC)"');
      bpa.enable_policies(l_tab);
  end fill_ow_crvacc_request;

  procedure fill_ow_crvfiles
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_CRVFILES';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_CRVFILES',false,'ID,"rukey(ID)"');
      bpa.enable_policies(l_tab);
  end fill_ow_crvfiles;

  procedure fill_ow_crvfiles_data
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_CRVFILES_DATA';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_CRVFILES_DATA',false,'ID,"rukey(ID)",RNK,"rukey(RNK)",ND,"rukey(ND)"');
      bpa.enable_policies(l_tab);
  end fill_ow_crvfiles_data;

  procedure fill_ow_iicfiles
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_IICFILES';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.tabsync(l_tab);
      bpa.enable_policies(l_tab);
  end fill_ow_iicfiles;

  procedure fill_ow_locpay_match
    is
      begin
      mgr_utl.sync_table_auto('OW_LOCPAY_MATCH',false,'REF,"rukey(REF)"');
  end fill_ow_locpay_match;

  procedure fill_ow_oic_atransfers_data
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_OIC_ATRANSFERS_DATA';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_OIC_ATRANSFERS_DATA',false,'ID,"rukey(ID)"');
      bpa.enable_policies(l_tab);
  end fill_ow_oic_atransfers_data;

  procedure fill_ow_oic_documents_data
    is
      begin
      mgr_utl.sync_table_auto('OW_OIC_DOCUMENTS_DATA',false,'ID,"rukey(ID)"');
  end fill_ow_oic_documents_data;

  procedure fill_ow_oic_documents_hist
    is
      begin
      mgr_utl.sync_table_auto('OW_OIC_DOCUMENTS_HIST',false,'ID,"rukey(ID)",REF,"rukey(REF)"');
  end fill_ow_oic_documents_hist;

  procedure fill_ow_oic_stransfers_data
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_OIC_STRANSFERS_DATA';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_OIC_STRANSFERS_DATA',false,'ID,"rukey(ID)"');
      bpa.enable_policies(l_tab);
  end fill_ow_oic_stransfers_data;

  procedure fill_ow_oic_stransfers_hist
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_OIC_STRANSFERS_HIST';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_OIC_STRANSFERS_HIST',false,'ID,"rukey(ID)",REF,"rukey(REF)"');
      bpa.enable_policies(l_tab);
  end fill_ow_oic_stransfers_hist;

  procedure fill_ow_pkk_history
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_PKK_HISTORY';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_PKK_HISTORY',false,'ACC,"rukey(ACC)",REF,"rukey(REF)",K_DONEBY,"ruuser(K_DONEBY)"');
      bpa.enable_policies(l_tab);
  end fill_ow_pkk_history;

  procedure fill_ow_pkk_que
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_PKK_QUE';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_PKK_QUE',false,'ACC,"rukey(ACC)",REF,"rukey(REF)"');
      bpa.enable_policies(l_tab);
  end fill_ow_pkk_que;

  procedure fill_ow_salary_data
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_SALARY_DATA';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_SALARY_DATA',false,'ID,"rukey(ID)",RNK,"rukey(RNK)",ND,"rukey(ND)"');
      bpa.enable_policies(l_tab);
  end fill_ow_salary_data;

  procedure fill_ow_salary_files
    is
    l_tab     VARCHAR2(30) DEFAULT 'OW_SALARY_FILES';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('OW_SALARY_FILES',false,'ID,"rukey(ID)"');
      bpa.enable_policies(l_tab);
  end fill_ow_salary_files;

  procedure fill_w4_acc_instant
    is
    l_tab     VARCHAR2(30) DEFAULT 'W4_ACC_INSTANT';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('W4_ACC_INSTANT',false,'ACC,"rukey(ACC)"');
      bpa.enable_policies(l_tab);
  end fill_w4_acc_instant;

  procedure fill_sw_staff_list
    is
      begin
      mgr_utl.sync_table_auto('SW_STAFF_LIST',false,'ID,"ruuser(ID)"');
  end fill_sw_staff_list;

  procedure fill_sw_oper
    is
      begin
      mgr_utl.sync_table_auto('SW_OPER',false,'REF,"rukey(REF)",SWREF,"rukey(SWREF)"');
  end fill_sw_oper;

  procedure fill_sw_operw
    is
      begin
      mgr_utl.sync_table_auto('SW_OPERW',false,'SWREF,"rukey(SWREF)"');
  end fill_sw_operw;

  procedure fill_sw_950
    is
      begin
      mgr_utl.sync_table_auto('SW_950',false,'SWREF,"rukey(SWREF)",NOSTRO_ACC,"rukey(NOSTRO_ACC)"');
  end fill_sw_950;

  procedure fill_sw_950d
    is
      begin
      mgr_utl.sync_table_auto('SW_950D',false,'SWREF,"rukey(SWREF)",CONTRA_ACC,"rukey(CONTRA_ACC)",OUR_REF,"rukey(OUR_REF)",SRC_SWREF,"rukey(SRC_SWREF)"');
  end fill_sw_950d;

  procedure fill_sw_procque
    is
      begin
      mgr_utl.sync_table_auto('SW_PROCQUE',false,'SWREF,"rukey(SWREF)"');
  end fill_sw_procque;

  procedure fill_sw_mvps_infdocs
    is
    l_tab     VARCHAR2(30) DEFAULT 'SW_MVPS_INFDOCS';
      begin
      bpa.disable_policies(l_tab);
      mgr_utl.sync_table_auto('SW_MVPS_INFDOCS',false,'REF,"rukey(REF)",INFREF,"rukey(INFREF)"');
      bpa.enable_policies(l_tab);
  end fill_sw_mvps_infdocs;

  procedure fill_sw_acc_sparam
    is
      begin
      mgr_utl.sync_table_auto('SW_ACC_SPARAM',false,'ACC,"rukey(ACC)"');
  end fill_sw_acc_sparam;

  procedure fill_sw_950a
    is
      begin
      mgr_utl.sync_table_auto('SW_950A',false,'SWREF,"rukey(SWREF)"');
  end fill_sw_950a;

  procedure fill_sw_stmt_info
    is
      begin
      mgr_utl.sync_table_auto('SW_STMT_INFO',false,'ACC,"rukey(ACC)",LAST_MESSAGE_REF,"rukey(LAST_MESSAGE_REF)"');
  end fill_sw_stmt_info;

  procedure fill_sw_messages
    is
      begin
      mgr_utl.sync_table_auto('SW_MESSAGES',false,'SWREF,"rukey(SWREF)",NOSTRO_ACC,"rukey(NOSTRO_ACC)"');
  end fill_sw_messages;

  procedure fill_tmp_sw_message
    is
      begin
      mgr_utl.sync_table_auto('TMP_SW_MESSAGE',false,'SWREF,"rukey(SWREF)"');
  end fill_tmp_sw_message;

  procedure fill_sw_docmsg_err
    is
      begin
      init();
      --
      mgr_utl.sync_table('SW_DOCMSG_ERR',
                         'insert into  BARS.SW_DOCMSG_ERR(ref, errmsg, kf)
                         select rukey(ref) as ref, errmsg, '''||g_kf||''' as kf
                         from ' ||pkf('SW_DOCMSG_ERR'),
                         false);
      mgr_utl.p_constraints_enable('SW_DOCMSG_ERR');
  end fill_sw_docmsg_err;

  procedure fill_cin_tk
    is
      begin
      mgr_utl.sync_table_auto('CIN_TK',false,'rnk,"rukey(rnk)"');
  end fill_cin_tk;

  procedure fill_cin_tag_tk
    is
      begin
      mgr_utl.sync_table_auto('CIN_TAG_TK',false,'rnk,"rukey(rnk)"');
  end fill_cin_tag_tk;

  procedure fill_cin_tag_rnk
    is
      begin
      mgr_utl.sync_table_auto('CIN_TAG_RNK',false,'rnk,"rukey(rnk)"');
  end fill_cin_tag_rnk;

  procedure fill_cin_cust
    is
      begin
      mgr_utl.sync_table_auto('CIN_CUST',false,'rnk,"rukey(rnk)"');
  end fill_cin_cust;

  procedure fill_cin_kom2
    is
      begin
      mgr_utl.sync_table_auto('CIN_KOM2',false,'rnk,"rukey(rnk)"');
  end fill_cin_kom2;

  procedure fill_cin_kom1
    is
      begin
      mgr_utl.sync_table_auto('CIN_KOM1',false,'rnk,"rukey(rnk)"');
  end fill_cin_kom1;

  procedure fill_alegro
    is
      begin
      mgr_utl.sync_table_auto('ALEGRO',false,'rnk,"rukey(rnk)"');
  end fill_alegro;

  procedure fill_mos_operw
    is
       l_tab    varchar2(30) default 'MOS_OPERW';
    begin
      init();
      --
      
      bpa.disable_policies('ND_TXT');
      mgr_utl.disable_table_triggers('ND_TXT');
      mgr_utl.disable_foreign_keys('ND_TXT');
      --
      execute_statement(
                         'insert into ND_TXT (nd, tag, txt, kf)
                          select rukey(m.nd) as nd, m.tag as tag, m.value as txt, d.kf as kf
                            from ' ||pkf('MOS_OPERW')|| ' m,
                              ' || pkf('CC_DEAL') || ' d ' ||
                         ' where d.nd = m.nd
                             and  not exists (select 1 from bars.nd_txt n where n.tag = m.tag and substr(n.nd,1,length(n.nd)-2) = m.nd)', 
                             'Завантаження додаткових атрибутів кредитних угод для МФО ' || g_kf ||' таблиця '||l_tab);
      --
      mgr_utl.enable_table_triggers('ND_TXT');
      mgr_utl.enable_foreign_keys('ND_TXT');
      bpa.enable_policies('ND_TXT');
      --
  end fill_mos_operw;
  
  procedure fill_ins_deal_scans
    is
      begin
      mgr_utl.sync_table_auto('INS_DEAL_SCANS',false,'DEAL_ID,"rukey(DEAL_ID)"');
  end fill_ins_deal_scans;

  procedure fill_e_tar_nd
    is
      begin
      mgr_utl.sync_table_auto('E_TAR_ND',false,'ND,"rukey(ND)"');
  end fill_e_tar_nd;

  procedure fill_branch_obu
    is
    begin
      init();
      mgr_utl.sync_table('BRANCH_OBU',
                         'insert into  BARS.BRANCH_OBU(branch, rid, ru, name, opendate, closedate)
                         select branch, rid, ru, name, to_date(opendate,''dd.mm.yyyy''), to_date(closedate,''dd.mm.yyyy'')
                         from ' ||pkf('BRANCH_OBU'),
                         false);
  end fill_branch_obu;

  procedure fill_acr_docs
    is
    l_min_ref number;
    begin
      init();
      bpa.disable_policies('ACR_DOCS');
      --
      execute immediate 'select trunc(nvl(op.ref/100, 1))
                           from (select min(ref) as ref
                                 from bars.oper
                                 where ref > 0
                                 and kf=:g_kf
                                 )op'
                           into l_min_ref using g_kf;
      --
      mgr_utl.sync_table('ACR_DOCS',
                         'insert into  BARS.ACR_DOCS(acc, id, int_date, int_ref, int_rest, kf)
                         select rukey(acc) as acc, id, int_date, rukey(int_ref) as int_ref, int_rest, '''||g_kf||''' as kf
                         from ' ||pkf('ACR_DOCS')||' where int_ref >= '||l_min_ref,
                         false);
      bpa.enable_policies('ACR_DOCS');
  end fill_acr_docs;

  procedure fill_e_deal$base_update(p_schema varchar2 default null,  p_dblink varchar2 default null)
   is
    l_tab         VARCHAR2(30) DEFAULT 'E_DEAL$BASE_UPDATE';
    l_max_idupd   bars.e_deal$base_update.idupd%type;

    begin
    init();
    --bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);
    mgr_utl.disable_foreign_keys(l_tab);
    --      
    l_max_idupd := get_max_idupd(l_tab);
    --
    mgr_utl.sync_table(l_tab,
                        'INSERT INTO '||l_tab||'
                        SELECT rukey(idupd) as idupd, chgaction, effectdate, chgdate, ruuser(doneby) as doneby, rukey(nd) as nd, rukey(rnk) as rnk,
                               sos, cc_id, sdate, wdate, ruuser(user_id) as user_id, sa, '''||g_kf||''' as kf,
                               rukey(acc26) as acc26, rukey(acc36) as acc36, rukey(accd) as accd, rukey(accp) as accp
                        FROM '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                        false);
    --
    bc.home;
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.e_deal$base_update;
    --
    mgr_utl.reset_sequence('s_edeal$baseupdate', l_max_idupd);
    --
    mgr_utl.enable_table_triggers(l_tab);
    mgr_utl.enable_foreign_keys(l_tab);
    --bpa.enable_policies(l_tab);
    --
  end fill_e_deal$base_update;

  procedure fill_nd_txt_update (p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'ND_TXT_UPDATE';
    l_max_idupd   bars.nd_txt_update.idupd%type;
/*    l_stmt        VARCHAR2(255) := 'begin bars_login.login_user'||p_dblink||'(sys_guid,1,null,null); end;';
    l_dblink      VARCHAR2(30) := p_dblink;
    l_sys_guid    VARCHAR2(255) := sys_guid;*/
      begin
        --mgr_utl.sync_table_auto('ND_TXT_UPDATE', false, 'ND,"rukey(ND)", DONEBY,"ruuser(DONEBY)", IDUPD,"rukey(IDUPD)"');  
        --      
        l_max_idupd := get_max_idupd(l_tab);
        --execute immediate l_stmt;
        --
        mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       ( nd
                         ,tag
                         ,txt
                         ,chgdate
                         ,chgaction
                         ,doneby
                         ,idupd
                         ,kf
                         ,effectdate
                         ,global_bdate
                       )
                        SELECT 
                         rukey(ND) as nd
                         ,tag
                         ,txt
                         ,chgdate
                         ,chgaction
                         ,ruuser(DONEBY) as doneby
                         ,rukey(IDUPD) as idupd
                         , '''||g_kf||''' as kf 
                         ,effectdate
                         ,global_bdate
                        FROM '
                        ||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd,
                         false);        --
        bc.home;
        --
        select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.ND_TXT_UPDATE;

        mgr_utl.reset_sequence('s_nd_txt_update', l_max_idupd);
        --
        mgr_utl.enable_table_triggers(l_tab);
        mgr_utl.enable_foreign_keys(l_tab);
        mgr_utl.p_constraints_enable(l_tab);
    end fill_nd_txt_update;
 
  procedure fill_fin_cust
    is
      begin
        mgr_utl.sync_table_auto('FIN_CUST', false, 'isp,"ruuser(isp)"');  
        mgr_utl.p_constraints_enable('FIN_CUST');
         --
         bc.home;
         --
      end fill_fin_cust;

  procedure fill_dpt_vidd_upd 
    is
    l_tab         VARCHAR2(30) DEFAULT 'DPT_VIDD_UPDATE';
    l_max_idupd   bars.dpt_vidd_update.idu%type;
      begin
        mgr_utl.sync_table_auto('DPT_VIDD_UPDATE', false, 'IDU,"rukey(IDU)", USERU,"ruuser(USERU)"');  
        mgr_utl.p_constraints_enable('DPT_VIDD_UPDATE');
         --
         --bc.home;
         --
    --
    select trunc(nvl(max(idu / 100), 0)) + 1 into l_max_idupd from bars.DPT_VIDD_UPDATE;

    mgr_utl.reset_sequence('s_dpt_vidd_update', l_max_idupd);
    --
    end fill_dpt_vidd_upd;

  procedure fill_tarif_scale_upd(p_schema varchar2 default null,  p_dblink varchar2 default null) 
    is
    l_tab         VARCHAR2(30) DEFAULT 'TARIF_SCALE_UPDATE';
    l_max_idupd   bars.TARIF_SCALE_UPDATE.idupd%type;
      begin
      --      
      l_max_idupd := get_max_idupd(l_tab);
      --
        mgr_utl.sync_table('TARIF_SCALE_UPDATE'
                           ,'insert into TARIF_SCALE_UPDATE(IDUPD, CHGACTION, CHGDATE, GLOBAL_BDATE, EFFECTDATE, DONEBY, KOD, SUM_LIMIT, SUM_TARIF, PR, KF, SMIN, SMAX)
                             select rukey(IDUPD), CHGACTION, CHGDATE, GLOBAL_BDATE, EFFECTDATE, ruuser(DONEBY), KOD, SUM_LIMIT, SUM_TARIF, PR, '''||g_kf||''' as kf, SMIN, SMAX
                               from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd
                           ,false);  
        mgr_utl.p_constraints_enable('TARIF_SCALE_UPDATE');
         --
         --bc.home;
         --
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.TARIF_SCALE_UPDATE;

    mgr_utl.reset_sequence('s_tfscale_update', l_max_idupd);
    --
    end fill_tarif_scale_upd;
 
  procedure fill_sh_tarif_scale_upd (p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'SH_TARIF_SCALE_UPDATE';
    l_max_idupd   bars.SH_TARIF_SCALE_UPDATE.idupd%type;
      begin
        --      
        l_max_idupd := get_max_idupd(l_tab);
        --
        mgr_utl.sync_table('SH_TARIF_SCALE_UPDATE'
                           ,'insert into SH_TARIF_SCALE_UPDATE(idupd, chgaction, chgdate, global_bdate, effectdate, doneby, ids, kod, sum_limit, sum_tarif, pr, kf, smin, smax)
                             select rukey(IDUPD) as idupd, chgaction, chgdate, global_bdate, effectdate, ruuser(DONEBY) as DONEBY, ids, kod, sum_limit, sum_tarif, pr, '''||g_kf||''' as kf, SMIN, SMAX
                               from '||pkf(l_tab, p_schema, p_dblink)||' where idupd >= '||l_max_idupd
                           ,false);  
        mgr_utl.p_constraints_enable('SH_TARIF_SCALE_UPDATE');
         --
         --bc.home;
         --
    --
    select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.SH_TARIF_SCALE_UPDATE;

    mgr_utl.reset_sequence('s_shtfscale_update', l_max_idupd);
    --
    end fill_sh_tarif_scale_upd;
 
  procedure fill_pawn_acc_update
    is
    l_tab         VARCHAR2(30) DEFAULT 'PAWN_ACC_UPDATE';
    l_max_idupd   bars.pawn_acc_update.idupd%type;
      begin
        --
        l_max_idupd := get_max_idupd(l_tab);
        --
        mgr_utl.sync_table(l_tab,
                       'INSERT INTO '||l_tab||'
                       (
                          idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,doneby
                         ,acc
                         ,pawn
                         ,mpawn
                         ,nree
                         ,idz
                         ,ndz
                         ,deposit_id
                         ,kf
                         ,sv
                         ,cc_idz
                         ,sdatz                       
                       )
                        SELECT 
                          rukey(idupd) as idupd
                         ,chgaction
                         ,effectdate
                         ,chgdate
                         ,ruuser(doneby) as doneby
                         ,rukey(acc) as acc
                         ,pawn
                         ,mpawn
                         ,nree
                         ,rukey(idz) as idz
                         ,rukey(ndz) as ndz
                         ,deposit_id
                         , '''||g_kf||''' as kf
                         ,sv
                         ,cc_idz
                         ,sdatz
                        FROM '
                        ||pkf(l_tab)||' where idupd >= '||l_max_idupd,
                         false);        --
        bc.home;
        --
        select trunc(nvl(max(idupd / 100), 0)) + 1 into l_max_idupd from bars.PAWN_ACC_UPDATE;

        mgr_utl.reset_sequence('s_pawnacc_update', l_max_idupd); 
        --
        mgr_utl.enable_table_triggers(l_tab);
        mgr_utl.enable_foreign_keys(l_tab);
        mgr_utl.p_constraints_enable(l_tab);
    end fill_pawn_acc_update;

    procedure map_staff_ad_user
    is
        l_report_line varchar2(32767 byte);
    begin
        for i in (select m.bars_login, m.branch, m.ad_login, a.user_id current_user_id, b.active_directory_name current_active_directory_name, s.id expected_user_id
                  from   staff_ad_user_mapping m
                  left join staff_ad_user a on a.active_directory_name = m.ad_login
                  left join staff$base s on ruuser(m.bars_login) = s.logname
                  left join staff_ad_user b on b.user_id = s.id
                  where  m.branch like bars_context.make_branch(g_kf) || '%' and
                         m.bars_login is not null) loop

            l_report_line := rpad(substr(i.ad_login, 1, 50), 50) || ' - ' || rpad(i.bars_login, 30) || ' : ';
            savepoint before_iteration;
            begin
                if (i.expected_user_id is null) then
                    l_report_line := l_report_line || 'Користувач АБС з логіном {' || ruuser(i.bars_login) || '} не знайдений';
                elsif (i.current_user_id = i.expected_user_id) then
                    l_report_line := l_report_line || 'Користувач вже прив''язаний до облікового запису Active Directory';
                else
                    if (i.current_active_directory_name is not null) then
                        l_report_line := l_report_line || 'Користувач АБС з логіном {' || ruuser(i.bars_login) ||
                                         '} прив''язаний до іншого облікового запису Active Directory {' || i.current_active_directory_name ||
                                         '} - виконуємо переприв''язку до {' || i.ad_login || '}. ';
                    end if;

                    delete staff_ad_user t
                    where  t.user_id = i.current_user_id or
                           t.active_directory_name = i.current_active_directory_name;

                    insert into staff_ad_user
                    values (i.expected_user_id, i.ad_login);

                    l_report_line := l_report_line || 'Користувач успішно прив''язаний до облікового запису Active Directory';
                end if;
                dbms_output.put_line(l_report_line);
            exception
                when others then
                     rollback to before_iteration;
                     dbms_output.put_line(l_report_line || dbms_utility.format_error_stack || chr(10) || dbms_utility.format_error_backtrace());
            end;
        end loop;

        dbms_output.put_line('');
        dbms_output.put_line('Відключення зовнішніх ключів перед оновленням логінів користувачів');
        dbms_output.put_line('-----------------------------------------------------------------------------------------');

        for i in (select * from user_constraints t where t.constraint_type = 'R' and t.r_constraint_name = 'UK_STAFF') loop
            dbms_output.put_line('Відключення зовнішнього ключа ' || i.constraint_name || ' для таблиці ' || i.table_name);
            ddl_utl.execute_statement_autonomous('alter table ' || i.table_name || ' disable constraint ' || i.constraint_name);
        end loop;

        dbms_output.put_line('');
        dbms_output.put_line('Оновлення логінів користувачів');
        dbms_output.put_line('-----------------------------------------------------------------------------------------');

        for i in (select a.active_directory_name, s.id, s.logname, s.fio, sl.id redundant_user_id, sl.logname redundant_user_login, replace(a.active_directory_name, 'OSCHADBANK\') new_login_name
                  from   staff_ad_user a
                  join   staff$base s on s.id = a.user_id
                  left join staff$base sl on sl.logname = replace(a.active_directory_name, 'OSCHADBANK\') and sl.id <> s.id
                  where  s.branch like bars_context.make_branch(g_kf) || '%') loop

            l_report_line := rpad(substr(i.active_directory_name, 1, 50), 50) || ' - ' || rpad(i.logname, 30) || ' : ';

            savepoint before_iteration;

            begin

                if (i.logname = i.new_login_name) then
                    l_report_line := l_report_line || 'Логін користувача АБС відповідає обліковому запису ActiveDirectory';
                else
                    if (i.redundant_user_id is not null) then
                        l_report_line := l_report_line || 'Знайдений новий обліковий запис користувача {' || i.redundant_user_login || ' (' || i.redundant_user_id || ')}, зареєстрований за його логіном в ActiveDirectory - закриваємо цей обліковий запис. ';

                        update staff$base s
                        set    s.logname = substr('RED_' || s.logname, 1, 30),
                               s.disable = 1,
                               s.active = 0
                        where  s.id = i.redundant_user_id;

                        update web_usermap s
                        set    s.dbuser = 'RED_' || s.dbuser,
                               s.webuser = 'red_' || s.webuser,
                               s.blocked = 1
                        where  s.dbuser = i.redundant_user_login;
                    end if;

                    update staff$base s
                    set    s.logname = i.new_login_name
                    where  s.id = i.id;

                    update web_usermap s
                    set    s.dbuser = i.new_login_name,
                           s.webuser = lower(i.new_login_name)
                    where  s.dbuser = i.logname;

                    bars_audit.security('Логін користувача {' || i.logname || '} змінюється на {' || i.active_directory_name || '} в рамках прив''язки користувача до облікового запису ActiveDirectory');
                    l_report_line := l_report_line || 'Оновлення логіну користувача з {' || i.logname || '} на {' || i.active_directory_name || '} пройшло успішно';
                end if;

                dbms_output.put_line(l_report_line);
            exception
                when others then
                     rollback to before_iteration;
                     dbms_output.put_line(l_report_line || dbms_utility.format_error_stack || chr(10) || dbms_utility.format_error_backtrace());
            end;
        end loop;

        commit;

        for i in (select * from user_constraints t where t.r_constraint_name = 'UK_STAFF') loop
            ddl_utl.execute_statement_autonomous('alter table ' || i.table_name || ' enable novalidate constraint ' || i.constraint_name);
        end loop;

    end map_staff_ad_user;
    
  procedure fill_cim_f36 
    is
    l_tab         VARCHAR2(30) DEFAULT 'CIM_F36';
      begin
        --      
        init();
        mantain_error_table(l_tab);
        --
         mgr_utl.sync_table( l_tab
                            ,'insert into '||l_tab||'( b041
                                                      ,k020
                                                      ,p17
                                                      ,p16
                                                      ,doc_date
                                                      ,p21
                                                      ,p14
                                                      ,p01
                                                      ,p22
                                                      ,p02
                                                      ,p02_old
                                                      ,p06
                                                      ,p06_old
                                                      ,p07
                                                      ,p07_old
                                                      ,p08
                                                      ,p08_old
                                                      ,p09
                                                      ,p13
                                                      ,p15
                                                      ,p18
                                                      ,p19
                                                      ,p20
                                                      ,p23
                                                      ,p24
                                                      ,p25
                                                      ,create_date
                                                      ,p27
                                                      ,branch
                                                     )
                                              select   b041
                                                      ,k020
                                                      ,p17
                                                      ,p16
                                                      ,doc_date
                                                      ,p21
                                                      ,p14
                                                      ,p01
                                                      ,p22
                                                      ,p02
                                                      ,p02_old
                                                      ,p06
                                                      ,p06_old
                                                      ,p07
                                                      ,p07_old
                                                      ,p08
                                                      ,p08_old
                                                      ,p09
                                                      ,p13
                                                      ,p15
                                                      ,p18
                                                      ,p19
                                                      ,p20
                                                      ,p23
                                                      ,p24
                                                      ,p25
                                                      ,create_date
                                                      ,p27
                                                      ,'''||'/'||g_kf||'/'||''' as branch
                                                 from '||pkf(l_tab)||' log errors reject limit unlimited'
                           ,false);  
         --
        bc.home;
       --mgr_utl.p_constraints_enable(l_tab);
     --
    end fill_cim_f36;
    
  procedure sync_dpu_vidd 
    is
    l_tab         VARCHAR2(30) DEFAULT 'DPU_VIDD';
    l_max_vidd   bars.dpu_vidd.vidd%type;
      begin
        --      
        init();
        --
         execute_statement(
              'merge into '||l_tab||' a using (select  vidd
                                                      ,name
                                                      ,kv
                                                      ,srok
                                                      ,bsd
                                                      ,bsn
                                                      ,basey
                                                      ,metr
                                                      ,br_id
                                                      ,freq_n
                                                      ,freq_v
                                                      ,acc7
                                                      ,tt
                                                      ,comproc
                                                      ,id_stop
                                                      ,min_summ
                                                      ,limit
                                                      ,penya
                                                      ,shablon
                                                      ,comments
                                                      ,flag
                                                      ,fl_add
                                                      ,fl_extend
                                                      ,tip_ost
                                                      ,dpu_type
                                                      ,fl_autoextend
                                                      ,dpu_code
                                                      ,max_summ
                                                      ,type_id
                                                      ,term_type
                                                      ,term_min
                                                      ,term_max
                                                      ,term_add
                                                      ,irrevocable
                                                      ,null as exn_mth_id
                                                 from '||pkf(l_tab)||' where dpu_type is not null) s on (a.vidd = s.vidd) 
              when not matched then insert values    ( s.vidd
                                                      ,s.name
                                                      ,s.kv
                                                      ,s.srok
                                                      ,s.bsd
                                                      ,s.bsn
                                                      ,s.basey
                                                      ,s.metr
                                                      ,s.br_id
                                                      ,s.freq_n
                                                      ,s.freq_v
                                                      ,s.acc7
                                                      ,s.tt
                                                      ,s.comproc
                                                      ,s.id_stop
                                                      ,s.min_summ
                                                      ,s.limit
                                                      ,s.penya
                                                      ,s.shablon
                                                      ,s.comments
                                                      ,s.flag
                                                      ,s.fl_add
                                                      ,s.fl_extend
                                                      ,s.tip_ost
                                                      ,s.dpu_type
                                                      ,s.fl_autoextend
                                                      ,s.dpu_code
                                                      ,s.max_summ
                                                      ,s.type_id
                                                      ,s.term_type
                                                      ,s.term_min
                                                      ,s.term_max
                                                      ,s.term_add
                                                      ,s.irrevocable
                                                      ,s.exn_mth_id)',
                    'Доповнення новими значеннями '||l_tab);
         --
        bc.home;
       --mgr_utl.p_constraints_enable(l_tab);
        --
        select max(vidd)+ 1 into l_max_vidd from BARS.DPU_VIDD;

        mgr_utl.reset_sequence('s_dpu_vidd', l_max_vidd); 
        --
         exception when others then
         rollback;
     --
    end sync_dpu_vidd;
    
  procedure sync_dpu_types 
    is
    l_tab         VARCHAR2(30) DEFAULT 'DPU_TYPES';
      begin
        --      
        init();
        --
         execute_statement(
              'merge into '||l_tab||' a using (select  type_id
                                                      ,type_name
                                                      ,type_code
                                                      ,sort_ord
                                                      ,fl_active
                                                      ,sum_min
                                                      ,sum_max
                                                      ,sum_add
                                                      ,stop_id
                                                      ,br_id
                                                      ,shablon
                                                      ,comproc
                                                      ,metr_id
                                                      ,extension_id
                                                      ,term_type
                                                      ,term_min
                                                      ,term_max
                                                      ,term_add
                                                 from '||pkf(l_tab)||') s on (a.type_id = s.type_id) 
              when not matched then insert values    ( s.type_id
                                                      ,s.type_name
                                                      ,s.type_code
                                                      ,s.sort_ord
                                                      ,s.fl_active
                                                      ,s.sum_min
                                                      ,s.sum_max
                                                      ,s.sum_add
                                                      ,s.stop_id
                                                      ,s.br_id
                                                      ,s.shablon
                                                      ,s.comproc
                                                      ,s.metr_id
                                                      ,s.extension_id
                                                      ,s.term_type
                                                      ,s.term_min
                                                      ,s.term_max
                                                      ,s.term_add)',
                    'Доповнення новими значеннями '||l_tab);
         --
        bc.home;
       --mgr_utl.p_constraints_enable(l_tab);
        --
          exception when others then
         rollback;
     --
    end sync_dpu_types;
    
  procedure sync_dpu_vidd_rate 
    is
    l_tab         VARCHAR2(30) DEFAULT 'DPU_VIDD_RATE';
    l_max_id   bars.DPU_VIDD_RATE.id%type;
      begin
        --      
        init();
        --
        mgr_utl.mantain_error_table(l_tab);
        select nvl(greatest(count(*), max(id)), 0)+ 1 into l_max_id from BARS.dpu_vidd_rate;

        mgr_utl.reset_sequence('s_dpu_vidd_rate', l_max_id); 

        bpa.disable_policies(l_tab);
         execute_statement(
              'merge into '||l_tab||' a using (select  id
                                                      ,vidd
                                                      ,term
                                                      ,limit
                                                      ,rate
                                                      ,term_days
                                                      ,term_include
                                                      ,summ_include
                                                      ,max_rate
                                                      ,type_id
                                                      ,kv
                                                      ,'||G_KF||' as kf
                                                 from '||pkf(l_tab)||') s on (a.vidd = s.vidd) 
              when not matched then insert values    ( s_dpu_vidd_rate.nextval 
                                                      ,s.vidd
                                                      ,s.term
                                                      ,s.limit
                                                      ,s.rate
                                                      ,s.term_days
                                                      ,s.term_include
                                                      ,s.summ_include
                                                      ,s.max_rate
                                                      ,s.type_id
                                                      ,s.kv
                                                      ,s.kf) log errors reject limit unlimited                                        
                                                      ',
                    'Доповнення новими значеннями '||l_tab);
         --
        bc.home;
       --mgr_utl.p_constraints_enable(l_tab);
        --
        /*select max(id)+ 1 into l_max_id from BARS.dpu_vidd_rate;

        mgr_utl.reset_sequence('s_dpu_vidd_rate', l_max_id);*/ 
        
        bpa.enable_policies(l_tab);
        --
         exception when others then
         rollback;
     --
    end sync_dpu_vidd_rate;
    
  procedure sync_tabval$global 
    is
    l_tab         VARCHAR2(30) DEFAULT 'TABVAL$GLOBAL';
      begin
        --      
        init();
        --
        bpa.disable_policies(l_tab);
         execute_statement(
              'merge into '||l_tab||' a using (select  kv
                                                      ,grp
                                                      ,name
                                                      ,lcv
                                                      ,nominal
                                                      ,sv
                                                      ,dig
                                                      ,unit
                                                      ,country
                                                      ,basey
                                                      ,gender
                                                      ,d_close
                                                      ,denom
                                                      ,threshold
                                                      ,prv
                                                      ,coin
                                                      ,fx_base

                                                 from '||pkf(l_tab)||') s on (a.kv = s.kv) 
                       when matched then update set    a.grp = s.grp
                                                      ,a.name = s.name
                                                      ,a.lcv = s.lcv
                                                      ,a.nominal = s.nominal
                                                      ,a.sv = s.sv
                                                      ,a.dig = s.dig
                                                      ,a.unit = s.unit
                                                      ,a.country = s.country
                                                      ,a.basey = s.basey
                                                      ,a.gender = s.gender
                                                      ,a.d_close = s.d_close
                                                      ,a.denom = s.denom
                                                      ,a.threshold = s.threshold
                                                      ,a.prv = s.prv
                                                      ,a.coin = s.coin
                                                      ,a.fx_base = s.fx_base
              when not matched then insert values    ( s.kv
                                                      ,s.grp
                                                      ,s.name
                                                      ,s.lcv
                                                      ,s.nominal
                                                      ,s.sv
                                                      ,s.dig
                                                      ,s.unit
                                                      ,s.country
                                                      ,s.basey
                                                      ,s.gender
                                                      ,s.d_close
                                                      ,s.denom
                                                      ,s.threshold
                                                      ,s.prv
                                                      ,s.coin
                                                      ,s.fx_base)',
                    'Доповнення новими значеннями '||l_tab);
         --
        bc.home;
       --mgr_utl.p_constraints_enable(l_tab);
        
        bpa.enable_policies(l_tab);
        --
         exception when others then
         rollback;
     --
    end sync_tabval$global;

  procedure fill_ebkc_gcif(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'EBKC_GCIF';
  begin
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' (kf, rnk, gcif, cust_type, insert_date)
                                   select '||G_KF||' as kf, 
                                          rukey(RNK) as rnk, 
                                          gcif, 
                                          cust_type, 
                                          insert_date
                                     from '||pkf(l_tab, p_schema,  p_dblink)||' log errors reject limit unlimited'
                                   , false);
  end fill_ebkc_gcif;

  procedure fill_ebkc_queue_updatecard(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'EBKC_QUEUE_UPDATECARD';
  begin
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' (rnk, status, insert_date, branch, cust_type, kf)
                                   select rukey(RNK) as rnk, 
                                          status, 
                                          insert_date, 
                                          branch, 
                                          cust_type,
                                          '||G_KF||' as kf
                                     from '||pkf(l_tab, p_schema,  p_dblink)||' log errors reject limit unlimited'
                                   , false);
  end fill_ebkc_queue_updatecard;

  procedure fill_ebkc_rcif(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'EBKC_RCIF';
  begin
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' (kf, rcif, send, cust_type)
                                   select '||G_KF||' as kf, 
                                          rukey(rcif) as rcif, 
                                          send, 
                                          cust_type
                                     from '||pkf(l_tab, p_schema,  p_dblink)||' log errors reject limit unlimited'
                                   , false);
  end fill_ebkc_rcif;

  procedure fill_ebkc_slave(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'EBKC_SLAVE';
  begin
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table(l_tab);
    --
      mgr_utl.sync_table(l_tab,'insert into '||l_tab||' (gcif,slave_kf,cust_type,slave_rnk)
                                       select  gcif
                                              ,slave_kf
                                              ,cust_type
                                              ,concat(slave_rnk, k2.ru) as slave_rnk 
                                         from '||pkf(l_tab, p_schema,  p_dblink)||'
                                         left join kf_ru k2
                                           on k2.kf = slave_kf log errors reject limit unlimited'     
                                              ,false);
  end fill_ebkc_slave;

  procedure fill_ebk_gcif(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'EBK_GCIF';
  begin
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table('EBKC_GCIF');
    --
    -- данные записываем не в EBK_GCIF, а в EBKC_GCIF
      mgr_utl.sync_table('EBKC_GCIF','insert into EBKC_GCIF (kf, rnk, gcif, CUST_TYPE, insert_date)                                              
                                       select t.kf
                                              ,concat(t.rnk, k1.ru) rnk
                                              ,t.gcif
                                              ,''I'' CUST_TYPE
                                              ,t.insert_date
                                         from '||pkf(l_tab, p_schema,  p_dblink)||' t
                                         left join kf_ru k1
                                           on k1.kf = t.kf 
                                         left join bars.EBKC_GCIF e
                                           on (t.kf = e.kf and concat(t.rnk, k1.ru) = e.rnk)
                                           or t.gcif = e.gcif                                          
                                        where e.kf is null                                       
                                           log errors reject limit unlimited'     
                                              ,false);
  end fill_ebk_gcif;

  procedure fill_ebk_rcif(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'EBK_RCIF';
  begin
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' (kf, rcif, send)
                                   select '||G_KF||' as kf, 
                                          rukey(rcif) as rcif, 
                                          send
                                     from '||pkf(l_tab, p_schema,  p_dblink)||' log errors reject limit unlimited'
                                   , false);
  end fill_ebk_rcif;

  procedure fill_ebk_slave_client(p_schema varchar2 default null,  p_dblink varchar2 default null)
    is
    l_tab         VARCHAR2(30) DEFAULT 'EBK_SLAVE_CLIENT';
  begin
    --
    -- mantain_error_table - создает/очищает таблицу ошибок err$_<p_table>
    mgr_utl.mantain_error_table('EBKC_SLAVE');
    --
    -- данные записываем не в EBK_SLAVE_CLIENT, а в EBKC_SLAVE
      mgr_utl.sync_table('EBKC_SLAVE','insert into EBKC_SLAVE (gcif, slave_kf, cust_type, slave_rnk)                                               
                                       select  gcif
                                              ,slave_kf
                                              , ''I''
                                              ,concat(slave_rnk, k2.ru) as slave_rnk 
                                         from '||pkf(l_tab, p_schema,  p_dblink)||'
                                         left join kf_ru k2
                                           on k2.kf = slave_kf log errors reject limit unlimited'     
                                              ,false);
  end fill_ebk_slave_client;

  procedure sync_P_L_2C
  is
      l_tab         VARCHAR2(30) DEFAULT 'P_L_2C';
  begin
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' 
                                select id
                                     , name
                                     , delete_date
                                  from '||pkf(l_tab)||'
                                 where regexp_like(id,''^[0-9]+$'')', true );
  end;
  
  procedure fill_acc_sob 
    is
    l_tab         VARCHAR2(30) DEFAULT 'ACC_SOB';
    l_max_id   bars.ACC_SOB.id%type;
      begin
        select nvl(max(id),0) + 1 
          into l_max_id
          from bars.acc_sob;
        --   
        mgr_utl.reset_sequence('s_acc_sob', l_max_id);
        --
        mgr_utl.sync_table_auto(l_tab, false, 'ID,"s_acc_sob.nextval", ACC,"rukey(ACC)", ISP,"rukey(ISP)"');  
        mgr_utl.p_constraints_enable(l_tab);
        bc.home;
    --
    end fill_acc_sob;
  procedure fill_social_agency(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
      l_tab              VARCHAR2(30) DEFAULT 'SOCIAL_AGENCY';
      l_max_agency_id    bars.SOCIAL_AGENCY.agency_id%type;
  begin
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' 
                                       (
                                        agency_id, 
                                        name, 
                                        branch, 
                                        debit_acc, 
                                        credit_acc, 
                                        card_acc, 
                                        contract, 
                                        date_on, 
                                        date_off, 
                                        address, 
                                        phone, 
                                        details, 
                                        type_id, 
                                        comiss_acc
                                       )
                                select 
                                        rukey(agency_id), 
                                        name, 
                                        branch, 
                                        rukey(debit_acc), 
                                        rukey(credit_acc), 
                                        rukey(card_acc), 
                                        contract, 
                                        date_on, 
                                        date_off, 
                                        address, 
                                        phone, 
                                        details, 
                                        type_id, 
                                        rukey(comiss_acc)
                                  from '||pkf(l_tab, p_schema,  p_dblink), false );
    --
    select nvl(max(trunc(agency_id/100) + 1), 1)
    into l_max_agency_id
    from SOCIAL_AGENCY;
    --
    mgr_utl.reset_sequence('s_social_agency', l_max_agency_id); 

  end fill_social_agency;  
  procedure fill_dpt_file_row(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
      l_tab         VARCHAR2(30) DEFAULT 'DPT_FILE_ROW';
  begin
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' 
                                       (
                                        info_id, 
                                        filename, 
                                        dat, 
                                        nls, 
                                        branch_code, 
                                        dpt_code, 
                                        sum, 
                                        fio, 
                                        pasp, 
                                        branch, 
                                        ref, 
                                        incorrect, 
                                        closed, 
                                        excluded, 
                                        header_id, 
                                        agency_id, 
                                        agency_name, 
                                        id_code, 
                                        file_payoff_date, 
                                        payoff_date, 
                                        marked4payment, 
                                        deal_created, 
                                        acc_type

                                       )
                                select 
                                        info_id, 
                                        filename, 
                                        dat, 
                                        nls, 
                                        branch_code, 
                                        dpt_code, 
                                        sum, 
                                        fio, 
                                        pasp, 
                                        branch, 
                                        ref, 
                                        incorrect, 
                                        closed, 
                                        excluded, 
                                        header_id, 
                                        rukey(agency_id), 
                                        agency_name, 
                                        id_code, 
                                        file_payoff_date, 
                                        payoff_date, 
                                        marked4payment, 
                                        deal_created, 
                                        acc_type

                                  from '||pkf(l_tab, p_schema,  p_dblink), false );
  end fill_dpt_file_row;  

  procedure fill_social_contracts(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
      l_tab         VARCHAR2(30) DEFAULT 'SOCIAL_CONTRACTS';
  begin
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' 
                                       (
                                        contract_id, 
                                        type_id, 
                                        agency_id, 
                                        branch, 
                                        rnk, 
                                        acc, 
                                        contract_num, 
                                        contract_date, 
                                        closed_date, 
                                        card_account, 
                                        pension_num, 
                                        details
                                       )
                                select 
                                        contract_id, 
                                        type_id, 
                                        rukey(agency_id), 
                                        branch, 
                                        rukey(rnk), 
                                        rukey(acc), 
                                        contract_num, 
                                        contract_date, 
                                        closed_date, 
                                        card_account, 
                                        pension_num, 
                                        details
                                  from '||pkf(l_tab, p_schema,  p_dblink), false );
  end fill_social_contracts;   

  procedure fill_dpt_file_agency(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
      l_tab         VARCHAR2(30) DEFAULT 'DPT_FILE_AGENCY';
  begin
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' 
                                       (
                                        header_id, 
                                        branch, 
                                        agency_id
                                       )
                                select 
                                        header_id, 
                                        branch, 
                                        rukey(agency_id)
                                  from '||pkf(l_tab, p_schema,  p_dblink), false );
 
  end fill_dpt_file_agency;  

  procedure fill_fm_stable_partner_arc(p_schema varchar2 default null,  p_dblink varchar2 default null)
  is
      l_tab         VARCHAR2(30) DEFAULT 'FM_STABLE_PARTNER_ARC';
  begin
    -- переливаем таблицу FM_PARTNER_ARC в FM_STABLE_PARTNER_ARC
    
      mgr_utl.sync_table(l_tab,'INSERT INTO '||l_tab||' 
                                       (
                                        dat, 
                                        rnk, 
                                        partner_list, 
                                        kf
                                       )
                                select 
                                        dat, 
                                        okpo, 
                                        partner_list, 
                                        '''||g_kf||'''
                                  from '||pkf('FM_PARTNER_ARC', p_schema,  p_dblink), false );
 
  end fill_fm_stable_partner_arc;  

  procedure fill_zapros_users
  is
      l_tab         VARCHAR2(30) DEFAULT 'ZAPROS_USERS';
  begin
      mgr_utl.mantain_error_table(l_tab);
      mgr_utl.sync_table(l_tab, 'insert into '||l_tab||' 
                                  select KODZ
                                       , ruuser(USER_ID) as USER_ID
                                    from '||pkf(l_tab)||' log errors reject limit unlimited
                                       ', false);
  end fill_zapros_users;
  
  procedure fill_xoz_ref
  is
      l_tab         VARCHAR2(30) DEFAULT 'XOZ_REF';
  begin
      mgr_utl.sync_table_auto(l_tab, false, 'REF1,"rukey(REF1)",REF2,"rukey(REF2)",SMTP1,"rukey(SMTP1)",ACC,"rukey(ACC)"');
  end fill_xoz_ref;
  
  procedure fill_fin_rnk_okpo
  is
  l_tab varchar2(30) default 'FIN_RNK_OKPO';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'RNK,"rukey(RNK)"');
  end fill_fin_rnk_okpo;
  
  procedure fill_nbu23_cck_ul_kor
  is
  l_tab varchar2(30) default 'NBU23_CCK_UL_KOR';
  l_max_id   bars.NBU23_CCK_UL_KOR.id%type;
      begin
        select nvl(max(id),0) + 1 
          into l_max_id
          from bars.NBU23_CCK_UL_KOR;
        --   
        mgr_utl.reset_sequence('s_nbu23_cck_ul_kor', l_max_id);
        --
    mgr_utl.sync_table_auto(l_tab, false, 'ID,"s_nbu23_cck_ul_kor.nextval",ND,"rukey(ND)"');
  end fill_nbu23_cck_ul_kor;
 
  procedure fill_rez_cr
  is
  l_tab varchar2(30) default 'REZ_CR';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'ACC,"rukey(ACC)",ND,"rukey(ND)",RNK,"rukey(RNK)"');
  end fill_rez_cr;

  procedure fill_fin_nd_hist
  is
  l_tab varchar2(30) default 'FIN_ND_HIST';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'ND,"rukey(ND)",RNK,"rukey(RNK)"');
  end fill_fin_nd_hist;

  procedure fill_fin_dat
  is
  l_tab varchar2(30) default 'FIN_DAT';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'ND,"rukey(ND)",RNK,"rukey(RNK)"');
  end fill_fin_dat;

  procedure fill_fin_kved
  is
  l_tab varchar2(30) default 'FIN_KVED';
  begin
    mantain_error_table(l_tab);
    
    mgr_utl.sync_table(l_tab,'
    
    insert into '||l_tab||'(okpo, dat, kved, volme_sales, weight, flag)
    select t.okpo, t.dat, t.kved, t.volme_sales, t.weight, t.flag 
    from '||pkf(l_tab)||' t log errors reject limit unlimited ', false );
  end fill_fin_kved;

  procedure fill_doc_scheme
  is
  l_tab varchar2(30) default 'DOC_SCHEME';
  begin
    
   case when g_kf = g_glb_mfo then
    execute_statement (
              'merge into '||l_tab||' a using (select id, 
                                              name, 
                                              print_on_blank, 
                                              template, 
                                              header, 
                                              footer, 
                                              header_ex, 
                                              d_close, 
                                              fr, 
                                              file_name

                                         from '||pkf(l_tab)||') s on (a.id = s.id) 
                 when matched then update set a.name = s.name, 
                                              a.print_on_blank = s.print_on_blank, 
                                              a.template = s.template, 
                                              a.header = s.header, 
                                              a.footer = s.footer, 
                                              a.header_ex = s.header_ex, 
                                              a.d_close = s.d_close, 
                                              a.fr = s.fr, 
                                              a.file_name = s.file_name
              when not matched then insert values    (  s.id, 
                                              s.name, 
                                              s.print_on_blank, 
                                              s.template, 
                                              s.header, 
                                              s.footer, 
                                              s.header_ex, 
                                              s.d_close, 
                                              s.fr, 
                                              s.file_name)','Доповнення новими значеннями '||l_tab);
   else 
    execute_statement (
              'merge into '||l_tab||' a using (select id, 
                                              name, 
                                              print_on_blank, 
                                              template, 
                                              header, 
                                              footer, 
                                              header_ex, 
                                              d_close, 
                                              fr, 
                                              file_name

                                         from '||pkf(l_tab)||') s on (a.id = s.id) 
              when not matched then insert values    (  s.id, 
                                              s.name, 
                                              s.print_on_blank, 
                                              s.template, 
                                              s.header, 
                                              s.footer, 
                                              s.header_ex, 
                                              s.d_close, 
                                              s.fr, 
                                              s.file_name)','Доповнення новими значеннями '||l_tab);
   end case;
  
  end fill_doc_scheme;
  
  procedure fill_doc_attr
  is
  l_tab varchar2(30) default 'DOC_ATTR';
  begin
    
   case when g_kf = g_glb_mfo then
    execute_statement (
              'merge into '||l_tab||' a using (select 
                                                id,
                                                name,
                                                field,
                                                ssql
                                         from '||pkf(l_tab)||') s on (a.id = s.id) 
               when matched then update set a.name = s.name, 
                                            a.field = s.field, 
                                            a.ssql = s.ssql
               when not matched then insert values    (  s.id, 
                                                         s.name, 
                                                         s.field, 
                                                         s.ssql
               )','Доповнення новими значеннями '||l_tab);
   else 
    execute_statement (
              'merge into '||l_tab||' a using (select 
                                                id,
                                                name,
                                                field,
                                                ssql
                                            from '||pkf(l_tab)||') s on (a.id = s.id) 
              when not matched then insert values    (  s.id, 
                                                        s.name,
                                                        s.field,
                                                        s.ssql
                       )','Доповнення новими значеннями '||l_tab);
   end case;
  
  end fill_doc_attr;

  procedure fill_repvp_nolimitusr
  is
  l_tab varchar2(30) default 'REPVP_NOLIMITUSR';
  begin
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'(USERID)
    select ruuser(t.userid) 
      from '||pkf(l_tab)||' t 
      left join '||l_tab||' tt 
        on ruuser(t.userid) = tt.userid
     where tt.userid is null', false );
  end fill_repvp_nolimitusr;

  procedure fill_mbm
  is
  l_tab varchar2(30);
  l_max_id number(30);
  begin
  l_tab := 'MBM_ACSK_CERTIFICATE_REQ';
    
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'( id
                            ,rel_cust_id
                            ,request_time
                            ,request_state
                            ,request_state_message
                            ,certificate_sn
                            ,template_name
                            ,template_oid
                            ,certificate_id
                            ,certificate_body
                            ,revoke_code
                            ,token_sn
                            ,token_name
                            )
                    select   id
                            ,rukey(rel_cust_id) as rel_cust_id
                            ,request_time
                            ,request_state
                            ,request_state_message
                            ,certificate_sn
                            ,template_name
                            ,template_oid
                            ,certificate_id
                            ,certificate_body
                            ,revoke_code
                            ,token_sn
                            ,token_name
      from '||pkf(l_tab), false );
      
  l_tab := 'MBM_ACSK_REGISTRATION';
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'(
                             registration_id
                            ,rel_cust_id
                            ,acsk_user_id
                            ,registration_date   
                            )
                    select  
                             registration_id
                            ,rukey(rel_cust_id) as rel_cust_id
                            ,acsk_user_id
                            ,registration_date
 
      from '||pkf(l_tab), false );
      
  l_tab := 'MBM_ACSK_REQUESTS_HISTORY';
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'( nonce
                            ,request_date
                            ,request_body
                            ,response_date
                            ,response_code
                            ,response_message
                            )
                    select   nonce
                            ,request_date
                            ,request_body
                            ,response_date
                            ,response_code
                            ,response_message
 
      from '||pkf(l_tab), false );
      
  l_tab := 'MBM_CUST_REL_USERS_MAP';
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'(cust_id, 
                            rel_cust_id, 
                            sign_number, 
                            user_id, 
                            is_approved, 
                            approved_type
                            )
                    select  rukey(cust_id) as cust_id, 
                            rukey(rel_cust_id) as rel_cust_id, 
                            sign_number, 
                            user_id, 
                            is_approved, 
                            approved_type
 
      from '||pkf(l_tab), false );
      
  l_tab := 'MBM_REL_CUSTOMERS';
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'( id
                            ,tax_code
                            ,first_name
                            ,last_name
                            ,second_name
                            ,doc_type
                            ,doc_series
                            ,doc_number
                            ,doc_organization
                            ,doc_date
                            ,birth_date
                            ,created_date
                            ,cell_phone
                            ,address
                            ,email
                             )
                    select   rukey(id) as id
                            ,tax_code
                            ,first_name
                            ,last_name
                            ,second_name
                            ,doc_type
                            ,doc_series
                            ,doc_number
                            ,doc_organization
                            ,doc_date
                            ,birth_date
                            ,created_date
                            ,cell_phone
                            ,address
                            ,email
 
      from '||pkf(l_tab), false );

  execute immediate '
  select nvl(max(id), 0)/100 + 1 from '||l_tab
  into l_max_id ;
  mgr_utl.reset_sequence(seq_name => 'mbm_rel_cust_seq', startvalue => l_max_id);

      
  l_tab := 'MBM_REL_CUSTOMERS_ADDRESS';
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'( rel_cust_id
                            ,region_id
                            ,city
                            ,street
                            ,house_number
                            ,addition
                            )
                    select   rukey(rel_cust_id) as rel_cust_id
                            ,region_id
                            ,city
                            ,street
                            ,house_number
                            ,addition
 
      from '||pkf(l_tab), false );

  l_tab := 'MBM_REL_CUST_VISA_STAMPS';
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'(
                             rel_cust_id
                            ,visa_id
                            ,user_id
                            ,visa_date
                            ,key_id
                            ,signature
    
                            )
                    select   rukey(rel_cust_id) as rel_cust_id
                            ,visa_id
                            ,ruuser(user_id) as user_id
                            ,visa_date
                            ,key_id
                            ,signature
 
      from '||pkf(l_tab), false );
      
  end fill_mbm;

  procedure fill_cp_accc
  is
  l_tab varchar2(30) default 'CP_ACCC';
  begin

    bpa.disable_policies(l_tab);
    mgr_utl.disable_table_triggers(l_tab);

    execute_statement (
              'merge into '||l_tab||' a using (select vidd, ryn, nlsa, nlsd, nlsp, nlsr, nlss, nlsz, nlsn1, nlsn2, nlsn3, 
                                                      nlsn4, nlse, nlsg, nlsr2, emi, pf, idb, nlszf, nls_fxp, nlssn, nls71, s605, s605p, nls_pr, nls_fxr, 
                                                      s2vd, s2vp, s2vd0, s2vp0, s2vd1, s2vp1, b4621r, s6499, s7499, nlss5, nls_5040, s2vd2, s2vp2, nls_5040_2, 
                                                      nls_5040_3, nlsexpn, nlsexpr, nlsr3, nls_1819, nls_1919, unrec, nlsfd
              from '||pkf(l_tab)||') s on (a.vidd = s.vidd and a.emi = s.emi and a.pf = s.pf and a.ryn = s.ryn) 
              when matched then update
                   set  a.nlsa = s.nlsa
                       ,a.nlsd = s.nlsd
                       ,a.nlsp = s.nlsp
                       ,a.nlsr = s.nlsr
                       ,a.nlss = s.nlss
                       ,a.nlsz = s.nlsz
                       ,a.nlsn1 = s.nlsn1
                       ,a.nlsn2 = s.nlsn2
                       ,a.nlsn3 = s.nlsn3
                       ,a.nlsn4 = s.nlsn4
                       ,a.nlse = s.nlse
                       ,a.nlsg = s.nlsg
                       ,a.nlsr2 = s.nlsr2
                       ,a.idb = s.idb
                       ,a.nlszf = s.nlszf
                       ,a.nls_fxp = s.nls_fxp
                       ,a.nlssn = s.nlssn
                       ,a.nls71 = s.nls71
                       ,a.s605 = s.s605
                       ,a.s605p = s.s605p
                       ,a.nls_pr = s.nls_pr
                       ,a.nls_fxr = s.nls_fxr
                       ,a.s2vd = s.s2vd
                       ,a.s2vp = s.s2vp
                       ,a.s2vd0 = s.s2vd0
                       ,a.s2vp0 = s.s2vp0
                       ,a.s2vd1 = s.s2vd1
                       ,a.s2vp1 = s.s2vp1
                       ,a.b4621r = s.b4621r
                       ,a.s6499 = s.s6499
                       ,a.s7499 = s.s7499
                       ,a.nlss5 = s.nlss5
                       ,a.nls_5040 = s.nls_5040
                       ,a.s2vd2 = s.s2vd2
                       ,a.s2vp2 = s.s2vp2
                       ,a.nls_5040_2 = s.nls_5040_2
                       ,a.nls_5040_3 = s.nls_5040_3
                       ,a.nlsexpn = s.nlsexpn
                       ,a.nlsexpr = s.nlsexpr
                       ,a.nlsr3 = s.nlsr3
                       ,a.nls_1819 = s.nls_1819
                       ,a.nls_1919 = s.nls_1919
                       ,a.unrec = s.unrec
                       ,a.nlsfd = s.nlsfd
              when not matched then insert values ( s.vidd, s.ryn, s.nlsa, s.nlsd, s.nlsp, s.nlsr, s.nlss, s.nlsz, s.nlsn1, s.nlsn2, s.nlsn3, 
                      s.nlsn4, s.nlse, s.nlsg, s.nlsr2, s.emi, s.pf, s.idb, s.nlszf, s.nls_fxp, s.nlssn, s.nls71, 
                      s.s605, s.s605p, s.nls_pr, s.nls_fxr, s.s2vd, s.s2vp, s.s2vd0, s.s2vp0, s.s2vd1, s.s2vp1, 
                      s.b4621r, s.s6499, s.s7499, s.nlss5, s.nls_5040, s.s2vd2, s.s2vp2, s.nls_5040_2, s.nls_5040_3, 
                      s.nlsexpn, s.nlsexpr, s.nlsr3, s.nls_1819, s.nls_1919, s.unrec, s.nlsfd)','Доповнення новими значеннями '||l_tab);

    mgr_utl.enable_table_triggers(l_tab);             
    bpa.enable_policies(l_tab); 

  end fill_cp_accc;

  procedure fill_sno_gpp
  is
  l_tab varchar2(30) default 'SNO_GPP';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'ND,"rukey(ND)",ACC,"rukey(ACC)"');
  end fill_sno_gpp;

  procedure fill_sno_ref
  is
  l_tab varchar2(30) default 'SNO_REF';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'ND,"rukey(ND)",ACC,"rukey(ACC)",REF,"rukey(REF)"');
  end fill_sno_ref;

  procedure fill_escr_register
  is
  l_tab varchar2(30) default 'ESCR_REGISTER';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'USER_ID,"ruuser(USER_ID)",ID,"rukey(ID)"');
  end fill_escr_register;

  procedure fill_escr_reg_mapping
  is
  l_tab varchar2(30) default 'ESCR_REG_MAPPING';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'ID,"rukey(ID)",IN_DOC_ID,"rukey(IN_DOC_ID)",OUT_DOC_ID,"rukey(OUT_DOC_ID)"');
  end fill_escr_reg_mapping;

  procedure fill_escr_reg_obj_state
  is
  l_tab varchar2(30) default 'ESCR_REG_OBJ_STATE';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'USER_ID,"ruuser(USER_ID)",OBJ_ID,"rukey(OBJ_ID)"');
  end fill_escr_reg_obj_state;

  procedure fill_fin_kod
  is
  l_tab varchar2(30) default 'FIN_KOD';
  begin
    mgr_utl.mantain_error_table(l_tab);
    mgr_utl.sync_table(l_tab,'    
    insert into '||l_tab||'(name, 
                            ord, 
                            kod, 
                            idf
                           )
                    select  name, 
                            ord, 
                            kod, 
                            idf 
      from '||pkf(l_tab)||'   log errors reject limit unlimited', true );
  end fill_fin_kod;
  
  procedure fill_acc262005
  is
  l_tab varchar2(30) default 'ACC262005';
  begin
    mgr_utl.sync_table_auto(l_tab, false, 'ACC,"rukey(ACC)"');
  end fill_acc262005;

  procedure fill_dpt_extrefusals
    is
    begin
      --mgr_utl.sync_table_auto('DPT_EXTREFUSALS', true,'DPTID,"rukey(DPTID)", DPTID,"ruuser(VRF_USERID)"');

          mgr_utl.sync_table('DPT_EXTREFUSALS',
                             'insert into bars.DPT_EXTREFUSALS
                             select rukey(DPTID) as dptid, branch, ruuser(req_userid) as req_userid, req_bnkdat, req_sysdat, req_machine, req_state, ruuser(VRF_USERID) as vrf_userid, vrf_bnkdat, vrf_sysdat, vrf_machine, vrf_reason, '''||g_kf||''' as kf
                             from '||mgr_utl.pkf('DPT_EXTREFUSALS'),
                             true);  
  end fill_dpt_extrefusals;

  procedure fill_per_que
  is
    begin

          mgr_utl.sync_table('PER_QUE',
                             'insert into bars.PER_QUE
                              select rukey(ref) as ref, rukey(refx) as refx
                             from '||mgr_utl.pkf('PER_QUE'),
                             false);
  end fill_per_que;

  procedure fill_rec_que
  is
    begin

          mgr_utl.sync_table('REC_QUE',
                             'insert into bars.REC_QUE
                              select rukey(rec) as rec, rukey(rec_g) as rec_g, otm, '''||g_kf||''' as kf, fmcheck
                             from '||mgr_utl.pkf('REC_QUE'),
                             true);
  end fill_rec_que;

  procedure fill_rnkp_kod_acc
  is
    begin

          mgr_utl.sync_table('RNKP_KOD_ACC',
                             'insert into bars.RNKP_KOD_ACC
                             select rukey(rnk) as rnk, kodk, rukey(ACC) as acc 
                             from '||mgr_utl.pkf('RNKP_KOD_ACC'),
                             false);
  end fill_rnkp_kod_acc;
  
  procedure fill_cust_zay
  is
    begin

          mgr_utl.sync_table('CUST_ZAY',
                             'insert into bars.CUST_ZAY
                             select rukey(rnk) as rnk, nls29, nls26, mfop, nlsp, kom, mfo26, okpop, okpo26, dk, nal_note, nal_date, tel, fio, 
                             nazn_pf, rnk_pf, kom2, fl_pf, mfov, nlsv, nls_kom, nls_kom2, kf, custacc4cms, kom3, nls_pf
                             from '||mgr_utl.pkf('CUST_ZAY'),
                             false);
  end fill_cust_zay;

  procedure fill_deal
    is
    l_max_id   bars.DEAL.id%type;
      begin
      mgr_utl.sync_table('DEAL',
                         'insert into DEAL
                          select rukey(d_kf.id) as id, ot.id, d_kf.deal_number, rukey(d_kf.customer_id) as customer_id, d_kf.product_id, d_kf.start_date, 
                                d_kf.expiry_date, d_kf.close_date, d_kf.state_id, d_kf.branch_id, rukey(d_kf.curator_id) as curator_id
                          from ' || mgr_utl.pkf('DEAL') ||' d_kf, ' ||
                                   mgr_utl.pkf('OBJECT_TYPE') || ' ot_kf, ' ||
                          ' bars.object_type ot
                           where d_kf.deal_type_id = ot_kf.id
                           and ot_kf.type_code = ot.type_code',
                           false);
    --
    bc.home();
    --    
    select trunc(nvl(max(id / 100), 0)) + 1 into l_max_id from bars.DEAL;
    --
    mgr_utl.reset_sequence('deal_seq', l_max_id);
  
  end fill_deal;

  procedure fill_prvn_automatic_event
    is
  begin
    mgr_utl.sync_table_auto('prvn_automatic_event',true,'ID,"rukey(ID)",REF_AGR,"rukey(REF_AGR)",RNK,"rukey(RNK)"');
  end;
  
  procedure fill_FINMON_QUE
    is
    
    begin 
      mgr_utl.mantain_error_table('FINMON_QUE');
      mgr_utl.sync_table('FINMON_QUE', 'insert into FINMON_QUE
                                        select  t.id, 
                                                rukey(t.ref) as ref, 
                                                t.rec, 
                                                t.status, 
                                                t.opr_vid1, 
                                                t.opr_vid2, 
                                                t.comm_vid2, 
                                                t.opr_vid3, 
                                                t.comm_vid3, 
                                                t.agent_id, 
                                                t.in_date, 
                                                t.monitor_mode, 
                                                t.rnk_a, 
                                                t.rnk_b, 
                                                t.comments, 
                                                ''' || g_kf || ''' as kf, 
                                                t.dat_i

                                          from '||mgr_utl.pkf('FINMON_QUE')||' t
                                          left join FINMON_QUE tt on t.id = tt.id
                                         where (tt.id is null) 
                                           and t.in_date >= to_date(''01.01.2016'', ''dd.mm.yyyy'')
                                           
                                          log errors reject limit unlimited ', false);

  end;
 

  procedure fill_FINMON_QUE_MODIFICATION
    is
    
  begin 
    mgr_utl.sync_table('FINMON_QUE_MODIFICATION', 'insert into FINMON_QUE_MODIFICATION
                                      select  t.id, 
                                              t.mod_date, 
                                              t.mod_type, 
                                              t.user_id, 
                                              t.user_name, 
                                              t.mod_value, 
                                              ''' || g_kf || ''' as kf 

                                        from '||mgr_utl.pkf('FINMON_QUE_MODIFICATION')||' t
                                        left join FINMON_QUE_MODIFICATION tt on t.id = tt.id
                                       where tt.id is null', false);
  end;

  procedure fill_FINMON_QUE_VID2
   is    
   begin 
     mgr_utl.sync_table('FINMON_QUE_VID2', 'insert into FINMON_QUE_VID2
                                      select  t.id, 
                                              t.vid, 
                                              t.comm, 
                                              ''' || g_kf || ''' as kf 
                                        from '||mgr_utl.pkf('FINMON_QUE_VID2')||' t
                                        left join FINMON_QUE_VID2 tt on t.id = tt.id
                                       where tt.id is null', false);

   
  end;

  procedure fill_OTCN_TRACE_12
   is    
   begin 
      mgr_utl.mantain_error_table('OTCN_TRACE_12');
     mgr_utl.sync_table('OTCN_TRACE_12', 'insert into OTCN_TRACE_12
                                      select 
                                        datf, 
                                        ruuser(userid) as userid, 
                                        nls, 
                                        kv, 
                                        odate, 
                                        kodp, 
                                        znap, 
                                        nbuc, 
                                        rukey(isp), 
                                        rukey(rnk), 
                                        rukey(acc), 
                                        rukey(ref), 
                                        comm, 
                                        nd, 
                                        mdate, 
                                        tobo
                                        from '||mgr_utl.pkf('OTCN_TRACE_12')||' t
                                       where t.datf  >= to_date(''01.01.2016'', ''dd.mm.yyyy'') 
                                        log errors reject limit unlimited', false);

   end;

  procedure fill_notary_profit
   is    
   begin 
      mgr_utl.mantain_error_table('notary_profit');
      mgr_utl.sync_table('notary_profit',
      'insert into notary_profit
      select 
      s_notary_profit.nextval as id, 
      notary_id, 
      accr_id, 
      branch, 
      nbsob22, 
      ref_oper, 
      dat_oper, 
      profit

      from '||mgr_utl.pkf('notary_profit')||'
      log errors reject limit unlimited', false);
   end;

  procedure fill_ACCC
   is    
   begin 
     mgr_utl.sync_table_auto(p_table => 'ACCC', p_delete => true, p_column_replace => 'ACC,"rukey(ACC)"');
   end;

  procedure fill_ACCE
   is    
   begin 
     mgr_utl.sync_table_auto(p_table => 'ACCE', p_delete => true, p_column_replace => 'ACC,"rukey(ACC)"');
   end;

  procedure fill_ACCI
   is    
   begin 
     mgr_utl.sync_table_auto(p_table => 'ACCI', p_delete => true, p_column_replace => 'ACC,"rukey(ACC)"');
   end;

  procedure fill_KLPACC
   is    
   begin 
     mgr_utl.sync_table_auto(p_table => 'KLPACC', p_delete => true, p_column_replace => 'ACC,"rukey(ACC)"');
   end;

  procedure fill_ref_koddz
   is    
  begin
    mgr_utl.mantain_error_table('REF_KODDZ');
    mgr_utl.sync_table(p_table => 'REF_KODDZ', p_stmt => '
    insert into REF_KODDZ( ref, kf)
    select rukey(ref) as ref,
           '''||g_kf||''' as  kf 
      from '||pkf('REF_KODDZ')||' t 
       log errors reject limit unlimited', p_delete =>  false);
  end fill_ref_koddz;

  procedure fill_cim_f503
    is 
    l_max_id number;
  begin
      mgr_utl.mantain_error_table('CIM_F503');
      mgr_utl.sync_table(p_table => 'CIM_F503',p_stmt => 
      'insert into cim_f503(
        f503_id, 
        contr_id, 
        p_date_to, 
        date_reg, 
        user_reg, 
        date_ch, 
        user_ch, 
        branch, 
        kf, 
        p1000, 
        z, 
        p0100, 
        p1300, 
        p0300, 
        p1400, 
        p1900, 
        pval, 
        p1500, 
        m, 
        p1600, 
        p9800, 
        p1700, 
        p0200, 
        r_agree_no, 
        p1200, 
        p1800, 
        t, 
        p9500, 
        p9600, 
        p3100, 
        p9900, 
        p0400, 
        p0800_1, 
        p0800_2, 
        p0800_3, 
        p0700, 
        p0900, 
        p0500, 
        p0600, 
        p2010, 
        p2011, 
        p2012, 
        p2013, 
        p2014, 
        p2016, 
        p2017, 
        p2018, 
        p2020, 
        p2021, 
        p2022, 
        p2023, 
        p2024, 
        p2025, 
        p2026, 
        p2027, 
        p2028, 
        p2029, 
        p2030, 
        p2031, 
        p2032, 
        p2033, 
        p2034, 
        p2035, 
        p2036, 
        p2037, 
        p2038, 
        p2042, 
        p3000
      )
      select 
        rukey(t.f503_id) as f503_id, 
        rukey(t.contr_id) as contr_id, 
        t.p_date_to, 
        t.date_reg, 
        t.user_reg, 
        t.date_ch, 
        t.user_ch, 
        t.branch, 
        t.kf, 
        t.p1000, 
        t.z, 
        t.p0100, 
        t.p1300, 
        t.p0300, 
        t.p1400, 
        t.p1900, 
        t.pval, 
        t.p1500, 
        t.m, 
        t.p1600, 
        t.p9800, 
        t.p1700, 
        t.p0200, 
        t.r_agree_no, 
        t.p1200, 
        t.p1800, 
        t.t, 
        t.p9500, 
        t.p9600, 
        t.p3100, 
        t.p9900, 
        t.p0400, 
        t.p0800_1, 
        t.p0800_2, 
        t.p0800_3, 
        t.p0700, 
        t.p0900, 
        t.p0500, 
        t.p0600, 
        t.p2010, 
        t.p2011, 
        t.p2012, 
        t.p2013, 
        t.p2014, 
        t.p2016, 
        t.p2017, 
        t.p2018, 
        t.p2020, 
        t.p2021, 
        t.p2022, 
        t.p2023, 
        t.p2024, 
        t.p2025, 
        t.p2026, 
        t.p2027, 
        t.p2028, 
        t.p2029, 
        t.p2030, 
        t.p2031, 
        t.p2032, 
        t.p2033, 
        t.p2034, 
        t.p2035, 
        t.p2036, 
        t.p2037, 
        t.p2038, 
        t.p2042, 
        t.p3000
       from '||mgr_utl.pkf('cim_f503')||' t
      left join cim_contracts_credit c
        on c.contr_id = rukey(t.contr_id) 
      where c.contr_id is null
      log errors reject limit unlimited
      ',p_delete => false);
    --
    bc.home();
    --    
    select trunc(nvl(max(f503_id / 100), 0)) + 1 into l_max_id from bars.cim_f503;
    --
    mgr_utl.reset_sequence('s_cim_f503', l_max_id);

  end fill_cim_f503;

  procedure fill_CIM_F503_AUTO_CHANGE_HIST
   is    
   begin 
     mgr_utl.sync_table_auto(p_table => 'CIM_F503_AUTO_CHANGE_HIST', p_delete => true, p_column_replace => 'F503_ID,"rukey(F503_ID)"');
   end;

  procedure fill_cim_f504
    is 
    l_max_id number;
  begin
      mgr_utl.mantain_error_table('CIM_F504');
      mgr_utl.sync_table(p_table => 'CIM_F504',p_stmt => 
      'insert into cim_f504(
      f504_id, 
      contr_id, 
      p_date_to, 
      date_reg, 
      user_reg, 
      date_ch, 
      user_ch, 
      branch, 
      kf, 
      p101, 
      z, 
      r_agree_no, 
      p103, 
      pval, 
      t, 
      m, 
      p107, 
      p108, 
      p184, 
      p140, 
      p142, 
      p141, 
      p020, 
      p143, 
      p050, 
      p060, 
      p090, 
      p960, 
      p310, 
      p999, 
      p212, 
      p213, 
      p201, 
      p222, 
      p223, 
      p292, 
      p293
      )
      select 
      rukey(t.f504_id) as f504_id, 
      rukey(t.contr_id) as contr_id, 
      t.p_date_to, 
      t.date_reg, 
      t.user_reg, 
      t.date_ch, 
      t.user_ch, 
      t.branch, 
      t.kf, 
      t.p101, 
      t.z, 
      t.r_agree_no, 
      t.p103, 
      t.pval, 
      t.t, 
      t.m, 
      t.p107, 
      t.p108, 
      t.p184, 
      t.p140, 
      t.p142, 
      t.p141, 
      t.p020, 
      t.p143, 
      t.p050, 
      t.p060, 
      t.p090, 
      t.p960, 
      t.p310, 
      t.p999, 
      t.p212, 
      t.p213, 
      t.p201, 
      t.p222, 
      t.p223, 
      t.p292, 
      t.p293

       from '||mgr_utl.pkf('cim_f504')||' t
      left join cim_contracts_credit c
        on c.contr_id = rukey(t.contr_id) 
      where c.contr_id is null
      log errors reject limit unlimited
      ',p_delete => false);
    --
    bc.home();
    --    
    select trunc(nvl(max(f504_id / 100), 0)) + 1 into l_max_id from bars.cim_f504;
    --
    mgr_utl.reset_sequence('s_cim_f504', l_max_id);
  
  end fill_cim_f504;
  
  procedure fill_CIM_F504_AUTO_CHANGE_HIST
   is    
   begin 
     mgr_utl.sync_table_auto(p_table => 'CIM_F504_AUTO_CHANGE_HIST', p_delete => true, p_column_replace => 'F503_ID,"rukey(F503_ID)"');
   end;

  procedure fill_cim_f504_detail
    is 
  begin
      mgr_utl.mantain_error_table('CIM_F504_DETAIL');
      mgr_utl.sync_table(p_table => 'CIM_F504_DETAIL',p_stmt => 
      'insert into CIM_F504_DETAIL(
      f504_det_id, 
      f504_id, 
      indicator_id, 
      indicator_name, 
      noprognosis, 
      rrrr, 
      w, 
      val, 
      date_reg, 
      user_reg, 
      date_ch, 
      user_ch

      )
      select 
      rukey(t.f504_det_id) as f504_det_id, 
      rukey(t.f504_id) as f504_id, 
      t.indicator_id, 
      t.indicator_name, 
      t.noprognosis, 
      t.rrrr, 
      t.w, 
      t.val, 
      t.date_reg, 
      t.user_reg, 
      t.date_ch, 
      t.user_ch
    from '||mgr_utl.pkf('CIM_F504_DETAIL')||' t
      log errors reject limit unlimited
      ',p_delete => false);
     
  end fill_CIM_F504_DETAIL;

  procedure fill_cim_f504_detail2
    is 
  begin
      mgr_utl.mantain_error_table('CIM_F504_DETAIL2');
      mgr_utl.sync_table(p_table => 'CIM_F504_DETAIL2',p_stmt => 
      'insert into CIM_F504_DETAIL2(
      f504_det_id, 
      f504_id, 
      indicator_id, 
      indicator_name, 
      rrrr, 
      w, 
      val, 
      date_reg, 
      user_reg, 
      date_ch, 
      user_ch
      )
      select 
      rukey(t.f504_det_id) as f504_det_id, 
      rukey(t.f504_id) as f504_id, 
      t.indicator_id, 
      t.indicator_name, 
      t.rrrr, 
      t.w, 
      t.val, 
      t.date_reg, 
      t.user_reg, 
      t.date_ch, 
      t.user_ch
    from '||mgr_utl.pkf('CIM_F504_DETAIL2')||' t
      log errors reject limit unlimited
      ',p_delete => false);
     
  end fill_CIM_F504_DETAIL2;

  procedure fill_FM_TURN_ARC
   is    
   begin 
          mgr_utl.merge_table_auto(  p_table => 'FM_TURN_ARC'
                                   , p_matched => false
                                   , p_not_matched => true
                                   , p_column_replace => 'RNK,"rukey(RNK)"'
                                   );
   end fill_FM_TURN_ARC;

  
begin
    init;
    /*
        -- Предварительно настройте SQL*Plus
        -- и включите трассировку скриптом
        --
        -- @trace
        --
        -- или с помощью команд, содержащихся в данном скрипте

        set feed off echo off term off
        set serveroutput on size unlimited
        exec logger.set_log_level(8);
        exec logger.set_output(1);
        exec logger.set_trace_objects('ALL');
        set feed on echo on term on

        Последовательность импорта
        --
        от имени BARS
        --------------------------
        --
        --
        -- задать рабочее МФО
        exec ikf(<kf>);
        --
        -- синхронизировать справочники
        BANKS
        -- отчетность и др.
        --
        ---
        --Виконати перед импортом

        --
        exec mgr_oschad.do_checks();
        --
        -- операции
        --exec mgr_oschad.fill_tts();
        --

        ------------------------------------------------------------
        -- ВАЛИДАЦИЯ
        ------------------------------------------------------------
        После процедуры импорта данных(как и после очистки)
        необходимо включить и провалидировать все внешние ключи

        exec mgr_utl.enable_foreign_keys();
        --exec mgr_utl.validate_foreign_keys();
        exec mgr_utl.validate_cons_in_parallel('CONS2VALID');

        Если остаются невалидированные ссылки, обязательно разобраться !!!
        ------------------------------------------------------------

        ------------------------------------------------------------
        -- СБОР СТАТИСТИКИ
        ------------------------------------------------------------
        После импорта существенно меняется кол-во и распределение данных в таблицах,
        поэтому необходимо собрать статистику

        exec dbms_stats.gather_schema_stats('BARS', method_opt=>'for all indexed columns', cascade=>true);

        -----------------------------------------------------------

        Последовательность очистки
        --------------------------

        --
        ------------------------------------------------------------------------
        -- Как получать и анализировать протокол расхождений таблиц при импорте
        ------------------------------------------------------------------------

        -- 1. Установить импортируемое МФО

              SQL> exec ikf(<mfo>);

        -- 2. Выполить процедуру

              SQL> exec mgr_oschad.diff_<table>;

        -- 3. Проанализировать протокол в таблице diff_<table>_<kf>

              SQL> select * from diff_<table>_<kf>;

        -- 4. Проставить в поле diff_result значения +/- как "принять/отклонить"
              и комментарий в поле diff_comment

        Н-р:

        SQL> exec ikf('399131');
        SQL> exec mgr_oschad.diff_zapros;
        SQL> select * from diff_zapros_399131;


        ------------------------------------------------------------------------
        -- Как выдать недостающие роли пользователям
        ------------------------------------------------------------------------

        SQL> exec mbu.adjust_role_grants;

    */
end mgr_oschad;
/

