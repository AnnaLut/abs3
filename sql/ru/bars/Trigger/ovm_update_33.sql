

PROMPT ===================================================================================== 
PROMPT *** Run *** ========== Scripts /Sql/BARS/Trigger/OVM_UPDATE_33.sql =========*** Run *
PROMPT ===================================================================================== 


PROMPT *** Create  trigger OVM_UPDATE_33 ***

  CREATE OR REPLACE TRIGGER BARS.OVM_UPDATE_33 INSTEAD OF UPDATE ON BARS.POLICY_TABLE_BASE FOR EACH ROW DECLARE dummy integer; curver integer; crStatus varchar2(20); isRef integer; l_state varchar2(30); lockmode varchar2(2); l_rowid2 rowid := :old.wm_rowid ; l_ltlock varchar2(100) default null; overwritemode_int integer := 1; par_lock_str varchar2(100); lock_status integer; wm$hasCRChild_var boolean := false; prev_wm$hasCRChild boolean := false; prev_old_nextver varchar2(1000); prev_op_ctx varchar2(100); /*** needed for dynamic update statements ***/ upd_stmt varchar2(32000); /*** Begin needed for implementing RIC's ***/ needToFire boolean; nullsInFK boolean; dependent_rows boolean; es_sql_string varchar2(32000); /*** End needed for implementing RIC's ***/ ricLockStatus integer; dummyLockStatus integer; op_ctx_var varchar2(100); N$TABLE_NAME VARCHAR2(30) := :NEW.TABLE_NAME; N$SELECT_POLICY VARCHAR2(10) := :NEW.SELECT_POLICY; N$INSERT_POLICY VARCHAR2(10) := :NEW.INSERT_POLICY; N$UPDATE_POLICY VARCHAR2(10) := :NEW.UPDATE_POLICY; N$DELETE_POLICY VARCHAR2(10) := :NEW.DELETE_POLICY; N$REPL_TYPE VARCHAR2(10) := :NEW.REPL_TYPE; N$POLICY_GROUP VARCHAR2(30) := :NEW.POLICY_GROUP; N$OWNER VARCHAR2(30) := :NEW.OWNER; N$POLICY_COMMENT VARCHAR2(4000) := :NEW.POLICY_COMMENT; N$CHANGE_TIME DATE := :NEW.CHANGE_TIME; N$APPLY_TIME DATE := :NEW.APPLY_TIME; N$WHO_ALTER VARCHAR2(256) := :NEW.WHO_ALTER; N$WHO_CHANGE VARCHAR2(256) := :NEW.WHO_CHANGE;procedure apply_unique_constraints is begin null ; end; BEGIN prev_old_nextver := wmsys.lt_ctx_pkg.old_nextver; wmsys.lt_ctx_pkg.old_nextver := :old.WM_nextver; prev_wm$hasCRChild := wmsys.lt_ctx_pkg.wm$hasCRChild; prev_op_ctx := wmsys.lt_ctx_pkg.op_ctx; wmsys.lt_ctx_pkg.op_ctx := nvl(SYS_CONTEXT('lt_ctx','opContext'),'DML'); wmsys.lt_ctx_pkg.initializeRicLockingVars; l_state := nvl(sys_context('lt_ctx', 'state'), 'LIVE'); if (wmsys.lt_ctx_pkg.version != -1) then WMSYS.WM_ERROR.RAISEERROR(WMSYS.LT.WM_ERROR_13_NO); end if; wmsys.lt_ctx_pkg.checkFreezeStatus(l_state, curver, lock_status, crStatus, isRef); if (crStatus = wmsys.lt_ctx_pkg.CRSTATUS_ALLCR or crStatus = wmsys.lt_ctx_pkg.CRSTATUS_MIXED) then wmsys.lt_ctx_pkg.wm$hasCRChild := true; end if; BEGIN lockMode := wmsys.lt_ctx_pkg.lock_Mode;if (wmsys.lt_ctx_pkg.rowlock_status != 'F') then if ( wmsys.lt_ctx_pkg.dml_var = 'ON' or (wmsys.lt_ctx_pkg.triggerOpCtx != 'DML' and ( wmsys.lt_ctx_pkg.tab_merge_wo_remove_var
= 'ON' or wmsys.lt_ctx_pkg.tab_merge_w_remove_var = 'ON' or wmsys.lt_ctx_pkg.wspc_merge_wo_remove_var = 'ON' or wmsys.lt_ctx_pkg.wspc_merge_w_remove_var = 'ON' or wmsys.lt_ctx_pkg.table_refresh_var = 'ON' ))) then BARS.wm$TBIU_POLICYTABLE_io(N$TABLE_NAME, :OLD.TABLE_NAME, N$SELECT_POLICY, :OLD.SELECT_POLICY, N$INSERT_POLICY, :OLD.INSERT_POLICY, N$UPDATE_POLICY, :OLD.UPDATE_POLICY, N$DELETE_POLICY, :OLD.DELETE_POLICY, N$REPL_TYPE, :OLD.REPL_TYPE, N$POLICY_GROUP, :OLD.POLICY_GROUP, N$OWNER, :OLD.OWNER, N$POLICY_COMMENT, :OLD.POLICY_COMMENT, N$CHANGE_TIME, :OLD.CHANGE_TIME, N$APPLY_TIME, :OLD.APPLY_TIME, N$WHO_ALTER, :OLD.WHO_ALTER, N$WHO_CHANGE, :OLD.WHO_CHANGE, l_rowid2, :old.wm_rowid); end if; null; end if; /* Make sure that the pkey is not being updated */ IF :old.TABLE_NAME != N$TABLE_NAME or N$TABLE_NAME is null or :old.POLICY_GROUP != N$POLICY_GROUP or N$POLICY_GROUP is null or :old.OWNER != N$OWNER or N$OWNER is null then WMSYS.WM_ERROR.RAISEERROR(WMSYS.LT.WM_ERROR_3_NO); end if;apply_unique_constraints; if (:old.WM_version = curver) then /* The row is in our current version */ upd_stmt := ' begin if(true or :1 is null or :2 is null or :3 is null or :4 is null or :5 is null or :6 is null or :7 is null or :8 is null or :9 is null or :10 is null or :11 is null or :12 is null or :13 is null or :14 is null or :15 is null or :16 is null) then null; end if; update BARS.POLICY_TABLE_LT set ';upd_stmt := upd_stmt || 'SELECT_POLICY = :5,';upd_stmt := upd_stmt || 'INSERT_POLICY = :6,';upd_stmt := upd_stmt || 'UPDATE_POLICY = :7,';upd_stmt := upd_stmt || 'DELETE_POLICY = :8,';upd_stmt := upd_stmt || 'REPL_TYPE = :9,';upd_stmt := upd_stmt || 'POLICY_COMMENT = :12,';upd_stmt := upd_stmt || 'CHANGE_TIME = :13,';upd_stmt := upd_stmt || 'APPLY_TIME = :14,';upd_stmt := upd_stmt || 'WHO_ALTER = :15,';upd_stmt := upd_stmt || 'WHO_CHANGE = :16,';upd_stmt := upd_stmt || ' ltlock=wmsys.lt_ctx_pkg.checkngetlock(wmsys.lt_ctx_pkg.lock_Mode, ltlock, nextver, :2, 1,''UPDATE'', version, delstatus, :3), delstatus=delstatus+1 where rowid = :1 ; end;' ; execute immediate upd_stmt using :OLD.WM_ROWID,l_state,isRef,N$TABLE_NAME,N$SELECT_POLICY,N$INSERT_POLICY,N$UPDATE_POLICY,N$DELETE_POLICY,N$REPL_TYPE,N$POLICY_GROUP,N$OWNER,N$POLICY_COMMENT,N$CHANGE_TIME,N$APPLY_TIME,N$WHO_ALTER,N$WHO_CHANGE; else /* The row is in our ancestor(s) */ UPDATE BARS.POLICY_TABLE_LT SET ltlock = wmsys.lt_ctx_pkg.checkngetlock(lockmode,
 ltlock, nextver, l_state, 0,'UPDATE', version, delstatus, isRef), nextver = wmsys.lt_ctx_pkg.getNextVer(nextver,curver,version,l_state,crStatus,33) WHERE ROWID = :old.WM_rowid; /* If lockmode is set, then generate the current lock info, * else carry-forward the parent lock to current version. */ /* Insert the changed row in our version. */ INSERT INTO BARS.POLICY_TABLE_LT(TABLE_NAME,SELECT_POLICY,INSERT_POLICY,UPDATE_POLICY,DELETE_POLICY,REPL_TYPE,POLICY_GROUP,OWNER,POLICY_COMMENT,CHANGE_TIME,APPLY_TIME,WHO_ALTER,WHO_CHANGE,VERSION,NEXTVER,DELSTATUS,LTLOCK) VALUES (N$TABLE_NAME,N$SELECT_POLICY,N$INSERT_POLICY,N$UPDATE_POLICY,N$DELETE_POLICY,N$REPL_TYPE,N$POLICY_GROUP,N$OWNER,N$POLICY_COMMENT,N$CHANGE_TIME,N$APPLY_TIME,N$WHO_ALTER,N$WHO_CHANGE, curver, wmsys.lt_ctx_pkg.CRCurNextver, :old.WM_delstatus+1, wmsys.lt_ctx_pkg.cur_lock_str) returning rowid into l_rowid2; end if;if (wmsys.lt_ctx_pkg.rowlock_status != 'F') then if ( wmsys.lt_ctx_pkg.dml_var = 'ON' or (wmsys.lt_ctx_pkg.triggerOpCtx != 'DML' and ( wmsys.lt_ctx_pkg.tab_merge_wo_remove_var = 'ON' or wmsys.lt_ctx_pkg.tab_merge_w_remove_var = 'ON' or wmsys.lt_ctx_pkg.wspc_merge_wo_remove_var = 'ON' or wmsys.lt_ctx_pkg.wspc_merge_w_remove_var = 'ON' or wmsys.lt_ctx_pkg.table_refresh_var = 'ON' ))) then BARS.wm$TAIU_POLICY_TABLE(N$TABLE_NAME, :OLD.TABLE_NAME, N$SELECT_POLICY, :OLD.SELECT_POLICY, N$INSERT_POLICY, :OLD.INSERT_POLICY, N$UPDATE_POLICY, :OLD.UPDATE_POLICY, N$DELETE_POLICY, :OLD.DELETE_POLICY, N$REPL_TYPE, :OLD.REPL_TYPE, N$POLICY_GROUP, :OLD.POLICY_GROUP, N$OWNER, :OLD.OWNER, N$POLICY_COMMENT, :OLD.POLICY_COMMENT, N$CHANGE_TIME, :OLD.CHANGE_TIME, N$APPLY_TIME, :OLD.APPLY_TIME, N$WHO_ALTER, :OLD.WHO_ALTER, N$WHO_CHANGE, :OLD.WHO_CHANGE, l_rowid2, :old.wm_rowid); end if; null; end if; wmsys.lt_ctx_pkg.update_modified_tables('BARS','POLICY_TABLE', curver, l_state,33) ; if (wmsys.lt_ctx_pkg.do_ct_ric_check) then needToFire := false;if ( :OLD.POLICY_GROUP is null and N$POLICY_GROUP is not null ) then needToFire := true; else if ( :OLD.POLICY_GROUP is not null and N$POLICY_GROUP is null ) then needToFire := true; else if ( N$POLICY_GROUP != :OLD.POLICY_GROUP) then needToFire := true; end if; end if; end if;nullsInFK := false;if ( N$POLICY_GROUP IS NULL ) then nullsInFK := true; end if; if ( needToFire and not nullsInFK ) then BEGIN ricLockStatus := wmsys.lt_ctx_pkg.request(10000001,4, wmsys.lt_ctx_pkg.MAXWAIT,
 true); if ( ricLockStatus = 0 ) then wmsys.lt_ctx_pkg.addToRicLocksList( 'BARS.POLICY_GROUPS', 'S' ); else if ( ricLockStatus = 4 ) then if ( wmsys.lt_ctx_pkg.hasRicLockOn('BARS.POLICY_GROUPS', 'RE')) then ricLockStatus := wmsys.lt_ctx_pkg.request(10000002, 6, 0, true); if ( ricLockStatus != 0 and ricLockStatus != 4 ) then WMSYS.WM_ERROR.RAISEERROR(WMSYS.LT.WM_ERROR_171_NO, 'deadlock detected while trying to acquire lock on BARS.POLICY_GROUPS'); end if; ricLockStatus := wmsys.lt_ctx_pkg.convert(10000001, 6, wmsys.lt_ctx_pkg.MAXWAIT); if ( ricLockStatus != 0 ) then dummyLockStatus := wmsys.lt_ctx_pkg.release(10000002); WMSYS.WM_ERROR.RAISEERROR(WMSYS.LT.WM_ERROR_171_NO, 'error while trying to acquire lock on BARS.POLICY_GROUPS, status = ' || ricLockStatus ); end if; end if; else WMSYS.WM_ERROR.RAISEERROR(WMSYS.LT.WM_ERROR_171_NO, 'error while trying to acquire lock on BARS.POLICY_GROUPS, status = ' || ricLockStatus ); end if; end if; select 1 into dummy from BARS.POLICY_GROUPS where (POLICY_GROUP = N$POLICY_GROUP); EXCEPTION when NO_DATA_FOUND then WMSYS.WM_ERROR.RAISEERROR(WMSYS.LT.WM_ERROR_6_NO, 'BARS', 'FK_POLICYTABLE_POLICYGROUPS'); when others then RAISE; END; end if; end if; wmsys.lt_ctx_pkg.wm$hasCRChild := prev_wm$hasCRChild; wmsys.lt_ctx_pkg.old_nextver := prev_old_nextver; wmsys.lt_ctx_pkg.op_ctx := prev_op_ctx; exception when others then wmsys.lt_ctx_pkg.wm$hasCRChild := prev_wm$hasCRChild; wmsys.lt_ctx_pkg.old_nextver := prev_old_nextver; wmsys.lt_ctx_pkg.op_ctx := prev_op_ctx; if (lock_status = 0) then wmsys.lt_ctx_pkg.releaseLock(wmsys.lt_ctx_pkg.state_lock_id); end if; RAISE; END; END;
/
ALTER TRIGGER BARS.OVM_UPDATE_33 ENABLE;


PROMPT ===================================================================================== 
PROMPT *** End *** ========== Scripts /Sql/BARS/Trigger/OVM_UPDATE_33.sql =========*** End *
PROMPT ===================================================================================== 
