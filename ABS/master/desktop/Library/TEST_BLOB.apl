.head 0 +  Application Description: Centura  Builder starter application
.head 1 -  Outline Version - 4.0.26
.head 1 +  Design-time Settings
.data VIEWINFO
0000: 6F00000001000000 FFFF01000D004347 5458566965775374 6174650400010000
0020: 0000000000A50000 002C000000020000 0003000000FFFFFF FFFFFFFFFFFCFFFF
0040: FFE2FFFFFFFFFFFF FF000000007C0200 004D010000010000 0000000000010000
0060: 000F4170706C6963 6174696F6E497465 6D00000000
.enddata
.head 2 -  Outline Window State: Normal
.head 2 +  Outline Window Location and Size
.data VIEWINFO
0000: 6600040003002D00 0000000000000000 0000B71E5D0E0500 1D00FFFF4D61696E
0020: 0000000000000000 0000000000000000 0000003B00010000 00000000000000E9
0040: 1E800A00008600FF FF496E7465726E61 6C2046756E637469 6F6E730000000000
0060: 0000000000000000 0000000000003200 0100000000000000 0000E91E800A0000
0080: DF00FFFF56617269 61626C6573000000 0000000000000000 0000000000000000
00A0: 3000010000000000 00000000F51E100D 0000F400FFFF436C 6173736573000000
00C0: 0000000000000000 0000000000000000
.enddata
.data VIEWSIZE
0000: D000
.enddata
.head 3 -  Left:   -0.013"
.head 3 -  Top:    0.0"
.head 3 -  Width:  8.013"
.head 3 -  Height: 4.969"
.head 2 +  Options Box Location
.data VIEWINFO
0000: 0418B80BB80B2500
.enddata
.data VIEWSIZE
0000: 0800
.enddata
.head 3 -  Visible? Yes
.head 3 -  Left:   4.15"
.head 3 -  Top:    1.885"
.head 3 -  Width:  3.8"
.head 3 -  Height: 2.073"
.head 2 +  Class Editor Location
.head 3 -  Visible? No
.head 3 -  Left:   0.575"
.head 3 -  Top:    0.094"
.head 3 -  Width:  5.063"
.head 3 -  Height: 2.719"
.head 2 +  Tool Palette Location
.head 3 -  Visible? No
.head 3 -  Left:   6.388"
.head 3 -  Top:    0.729"
.head 2 -  Fully Qualified External References? Yes
.head 2 -  Reject Multiple Window Instances? No
.head 2 -  Enable Runtime Checks Of External References? Yes
.head 2 -  Use Release 4.0 Scope Rules? No
.head 1 +  Libraries
.head 2 -  File Include: VTFILE.APL
.head 2 -  File Include: Constant.apl
.head 1 +  Global Declarations
.head 2 +  Window Defaults
.head 3 +  Tool Bar
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Form Window
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Dialog Box
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Top Level Table Window
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Data Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Multiline Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Spin Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Background Text
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Pushbutton
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Radio Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Check Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Option Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Group Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Child Table Window
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  List Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Combo Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Line
.head 4 -  Line Color: Use Parent
.head 3 +  Frame
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: 3D Face Color
.head 3 +  Picture
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 2 +  Formats
.head 3 -  Number: 0'%'
.head 3 -  Number: #0
.head 3 -  Number: ###000
.head 3 -  Number: ###000;'($'###000')'
.head 3 -  Date/Time: hh:mm:ss AMPM
.head 3 -  Date/Time: M/d/yy
.head 3 -  Date/Time: MM-dd-yy
.head 3 -  Date/Time: dd-MMM-yyyy
.head 3 -  Date/Time: MMM d, yyyy
.head 3 -  Date/Time: MMM d, yyyy hh:mm AMPM
.head 3 -  Date/Time: MMMM d, yyyy hh:mm AMPM
.head 2 +  External Functions
.head 2 +  Constants
.data CCDATA
0000: 3000000000000000 0000000000000000 00000000
.enddata
.data CCSIZE
0000: 1400
.enddata
.head 3 +  System
.head 3 +  User
.head 2 -  Resources
.head 2 +  Variables
.head 3 -  Sql Handle: hSql
.head 3 -  Long String: strTestString
.head 3 -  Long String: strTestStringFromDB
.head 3 -  Number: nTestStringSize
.head 3 -  File Handle: hTextFile
.head 3 -  Number: i
.head 2 +  Internal Functions
.head 3 +  Function: PutFileToBlob
.head 4 -  Description: Загрузка данных из файла в поле BLOB
.head 4 +  Returns
.head 5 -  Boolean: bOk
.head 4 +  Parameters
.head 5 -  ! SQL соединение
.head 5 -  Sql Handle: hSqlHandle
.head 5 -  ! Имя файла загружаемого в БД
.head 5 -  String: strFileName
.head 5 -  ! Имя таблицы
.head 5 -  String: strTableName
.head 5 -  ! Имя ключевого поля в таблице
.head 5 -  String: strKeyColumnName
.head 5 -  ! Имя поля содержащего BLOB значение
.head 5 -  String: strValueColumnName
.head 5 -  ! Значение ключевого поля (число)
.head 5 -  Number: nKeyValue
.head 5 -  ! Значение ключевого поля (строка)
.head 5 -  String: strKeyValue
.head 5 -  ! Условие для обновления строки (если ключ композитный)
.head 5 -  String: strWhereClause
.head 5 -  ! Признак вставки новой строки в таблицу (1/0)
.head 5 -  Number: nInsertRow
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! Файл
.head 5 -  File Handle: hFile
.head 5 -  ! Ошибка при открытии файла
.head 5 -  Number: nErrCode
.head 5 -  ! Буфер чтения файла
.head 5 -  Long String: sBuffer
.head 5 -  ! Максимальный размер буфера (3999)
.head 5 -  Number: nBufferSize
.head 5 -  ! Количество прочитанных байт
.head 5 -  Number: nBytesRead
.head 5 -  ! Номер строки в таблице TMP_LOB
.head 5 -  Number: nRowNumber
.head 4 +  Actions
.head 5 -  ! Это максимальный теоритический предел для вставки в БД
.head 5 -  Set nBufferSize=3999
.head 5 -  ! Здесь мы удаляем даные из временной таблицы
.head 5 -  Call SqlPrepareAndExecute( hSqlHandle, 'BEGIN bars_lob.clear_temporary; END; ' )
.head 5 -  ! Открываем файл для чтения
.head 5 -  Set nErrCode = VisFileOpen( hFile, strFileName, OF_Binary | OF_Read )
.head 5 +  If nErrCode
.head 6 -  Return FALSE
.head 5 -  ! Инитим № строки во временной таблице
.head 5 -  Set nRowNumber = 1
.head 5 -  ! В цикле по частям вычитываем файл и складываем его во временую таблицу БД
.head 5 +  Loop
.head 6 +  If SalStrSetBufferLength( sBuffer, nBufferSize+1 )
.head 7 -  Set nBytesRead = VisFileRead( hFile, sBuffer, nBufferSize )
.head 7 -  Call SalStrSetBufferLength( sBuffer, nBytesRead+1 )
.head 7 +  If nBytesRead
.head 8 +  If SqlPrepare( hSqlHandle, 'INSERT INTO TMP_LOB (ID, BLOBDATA) VALUES (:nRowNumber, :sBuffer)' )
.head 9 +  If SqlSetLongBindDatatype(2, BLOB_BYTE)
.head 10 +  If SqlExecute(hSqlHandle) 
.head 11 -  Set nRowNumber=nRowNumber+1
.head 10 +  Else
.head 11 -  Return FALSE
.head 9 +  Else
.head 10 -  Return FALSE
.head 8 +  Else
.head 9 -  Return FALSE
.head 8 +  If nBytesRead<nBufferSize
.head 9 -  Break
.head 7 +  Else
.head 8 -  Break
.head 6 +  Else
.head 7 -  Return FALSE
.head 5 -  ! Закрываем файл
.head 5 -  Call VisFileClose( hFile )
.head 5 -  ! Здесь мы зовем процедуру, которая перекладывает данные из временной таблицы в поле БД
.head 5 -  Call SqlPLSQLCommand( hSqlHandle, 
'bars_lob.write_blob(
    strTableName, 
    strKeyColumnName, 
    strValueColumnName, 
    nKeyValue, 
    strKeyValue, 
    strWhereClause,
    nInsertRow     )' )
.head 5 -  ! Сохраняем изменения
.head 5 -  Call SqlCommit( hSqlHandle )
.head 5 -  Return TRUE
.head 3 +  Function: PutBlobToFile
.head 4 -  Description: Выгрузка данных из BLOB в файл 
.head 4 +  Returns
.head 5 -  Boolean: bOk
.head 4 +  Parameters
.head 5 -  ! SQL соединение
.head 5 -  Sql Handle: hSqlHandle
.head 5 -  ! Имя создаваемого файла
.head 5 -  String: strFileName
.head 5 -  ! Имя таблицы
.head 5 -  String: strTableName
.head 5 -  ! Имя ключевого поля в таблице
.head 5 -  String: strKeyColumnName
.head 5 -  ! Имя поля содержащего BLOB значение
.head 5 -  String: strValueColumnName
.head 5 -  ! Значение ключевого поля (число)
.head 5 -  Number: nKeyValue
.head 5 -  ! Значение ключевого поля (строка)
.head 5 -  String: strKeyValue
.head 5 -  ! Условие для выборки строки (если ключ композитный)
.head 5 -  String: strWhereClause
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! Файл
.head 5 -  File Handle: hFile
.head 5 -  ! Ошибка при открытии файла
.head 5 -  Number: nErrCode
.head 5 -  ! Буфер чтения файла
.head 5 -  Long String: sBuffer
.head 5 -  ! Максимальный размер буфера (2000)
.head 5 -  Number: nBufferSize
.head 5 -  ! Количество байт в BLOBе
.head 5 -  Number: nBlobSize
.head 5 -  ! Количество байт, записанное в файл
.head 5 -  Number: nBytesWrote
.head 5 -  !
.head 5 -  Number: nFetchRes
.head 4 +  Actions
.head 5 -  ! Это максимальный теоритический предел
.head 5 -  Set nBufferSize=2000
.head 5 -  ! Здесь мы зовем функцию пакета, которая читает данные из указанного места в БД и складывает их во временую таблицу
.head 5 -  Call SqlPLSQLCommand( hSqlHandle, 
'bars_lob.read_blob(
    strTableName, 
    strKeyColumnName, 
    strValueColumnName, 
    nKeyValue, 
    strKeyValue, 
    strWhereClause  )' )
.head 5 -  ! Создаем файл
.head 5 -  Set nErrCode = VisFileOpen( hFile, strFileName, OF_Binary | OF_Create )
.head 5 +  If nErrCode
.head 6 -  Return FALSE
.head 5 -  ! В цикле по частям вычитываем файл из временной таблицы БД и сохраняю их в файл
.head 5 +  If SqlPrepare( hSqlHandle, 'SELECT RAWLEN, RAWDATA INTO :nBlobSize, :sBuffer FROM TMP_LOB ORDER BY ID' )
.head 6 +  If SqlSetLongBindDatatype( 2, BLOB_BYTE )
.head 7 +  If SqlExecute( hSqlHandle )
.head 8 +  Loop
.head 9 +  If SalStrSetBufferLength( sBuffer, nBufferSize+1 )
.head 10 +  If SqlFetchNext( hSqlHandle, nFetchRes )
.head 11 -  Set nBytesWrote = VisFileWrite( hFile, sBuffer, nBlobSize )
.head 10 +  Else
.head 11 -  Break
.head 9 +  Else
.head 10 -  Return FALSE
.head 7 +  Else
.head 8 -  Return FALSE
.head 6 +  Else
.head 7 -  Return FALSE
.head 5 +  Else
.head 6 -  Return FALSE
.head 5 -  ! Закрываем файл
.head 5 -  Call VisFileClose( hFile )
.head 5 -  Return TRUE
.head 3 +  Function: PutStringToClob
.head 4 -  Description: Запись данных из длинной строки в поле СLOB
.head 4 +  Returns
.head 5 -  Boolean: bOk
.head 4 +  Parameters
.head 5 -  ! SQL соединение
.head 5 -  Sql Handle: hSqlHandle
.head 5 -  ! Строка для сохранения в CLOB
.head 5 -  Long String: strStringToPut
.head 5 -  ! Имя таблицы
.head 5 -  String: strTableName
.head 5 -  ! Имя ключевого поля в таблице
.head 5 -  String: strKeyColumnName
.head 5 -  ! Имя поля содержащего CLOB значение
.head 5 -  String: strValueColumnName
.head 5 -  ! Значение ключевого поля (число)
.head 5 -  Number: nKeyValue
.head 5 -  ! Значение ключевого поля (строка)
.head 5 -  String: strKeyValue
.head 5 -  ! Условие для обновления строки (если ключ композитный)
.head 5 -  String: strWhereClause
.head 5 -  ! Признак вставки новой строки в таблицу (1/0)
.head 5 -  Number: nInsertRow
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! Текущий фрагмет строки
.head 5 -  Long String: sBuffer
.head 5 -  ! Максимальный размер буфера (4000)
.head 5 -  Number: nBufferSize
.head 5 -  ! Номер строки в таблице TMP_LOB (также используется как № фрагмента в строке)
.head 5 -  Number: nRowNumber
.head 4 +  Actions
.head 5 -  ! Это максимальный теоритический предел для вставки в БД
.head 5 -  Set nBufferSize=4000
.head 5 -  ! Здесь мы удаляем даные из временной таблицы
.head 5 -  Call SqlPrepareAndExecute( hSqlHandle, 'BEGIN bars_lob.clear_temporary; END; ' )
.head 5 -  ! Инитим № строки во временной таблице
.head 5 -  Set nRowNumber = 1
.head 5 -  ! В цикле по частям вычитываем файл и складываем его во временую таблицу БД
.head 5 +  Loop
.head 6 -  ! Выбираем соответствующую подстроку из целой строки strStringToPut
.head 6 -  Set sBuffer = SalStrMidX( strStringToPut, nBufferSize * (nRowNumber-1), nBufferSize )
.head 6 -  ! Сохраняем подстроку в БД
.head 6 +  If SqlPrepare( hSqlHandle, 'INSERT INTO TMP_LOB (ID, STRDATA) VALUES (:nRowNumber, :sBuffer)' )
.head 7 +  If SqlSetLongBindDatatype(2, BLOB_TEXT)
.head 8 +  If SqlExecute(hSqlHandle) 
.head 9 -  Set nRowNumber=nRowNumber+1
.head 8 +  Else
.head 9 -  Return FALSE
.head 7 +  Else
.head 8 -  Return FALSE
.head 6 +  Else
.head 7 -  Return FALSE
.head 6 -  ! Выходим по окончании строки
.head 6 +  If SalStrLength( strStringToPut )< nBufferSize * (nRowNumber-1)
.head 7 -  Break
.head 5 -  ! Здесь мы зовем процедуру, которая перекладывает данные из временной таблицы в поле БД
.head 5 -  Call SqlPLSQLCommand( hSqlHandle, 
'bars_lob.write_clob(
    strTableName, 
    strKeyColumnName, 
    strValueColumnName, 
    nKeyValue, 
    strKeyValue, 
    strWhereClause,
    nInsertRow     )' )
.head 5 -  ! Сохраняем изменения
.head 5 -  Call SqlCommit( hSqlHandle )
.head 5 -  Return TRUE
.head 3 +  Function: GetStringFromClob
.head 4 -  Description: Чтение данных из поля СLOB в длинную строку
.head 4 +  Returns
.head 5 -  Long String:
.head 4 +  Parameters
.head 5 -  ! SQL соединение
.head 5 -  Sql Handle: hSqlHandle
.head 5 -  ! Имя таблицы
.head 5 -  String: strTableName
.head 5 -  ! Имя ключевого поля в таблице
.head 5 -  String: strKeyColumnName
.head 5 -  ! Имя поля содержащего CLOB значение
.head 5 -  String: strValueColumnName
.head 5 -  ! Значение ключевого поля (число)
.head 5 -  Number: nKeyValue
.head 5 -  ! Значение ключевого поля (строка)
.head 5 -  String: strKeyValue
.head 5 -  ! Условие для выборки строки (если ключ композитный)
.head 5 -  String: strWhereClause
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! Текущий фрагмет строки
.head 5 -  Long String: sBuffer
.head 5 -  !
.head 5 -  Number: nFetchRes
.head 5 -  !
.head 5 -  Long String: strResult
.head 4 +  Actions
.head 5 -  ! Здесь мы зовем функцию пакета, которая читает данные из указанного места в БД и складывает их во временую таблицу
.head 5 -  Call SqlPLSQLCommand( hSqlHandle, 
'bars_lob.read_clob(
    strTableName, 
    strKeyColumnName, 
    strValueColumnName, 
    nKeyValue, 
    strKeyValue, 
    strWhereClause  )' )
.head 5 -  Set strResult = ''
.head 5 -  ! В цикле по частям вычитываем фрагменты строки из временной таблицы БД и конкатенируем их в единую строку
.head 5 +  If SqlPrepare( hSqlHandle, 'SELECT STRDATA INTO :sBuffer FROM TMP_LOB ORDER BY ID' )
.head 6 +  If SqlSetLongBindDatatype( 2, BLOB_TEXT )
.head 7 +  If SqlExecute( hSqlHandle )
.head 8 +  Loop
.head 9 +  If SqlFetchNext( hSqlHandle, nFetchRes )
.head 10 -  Set strResult = strResult || sBuffer
.head 9 +  Else
.head 10 -  Break
.head 7 +  Else
.head 8 -  Return ''
.head 6 +  Else
.head 7 -  Return ''
.head 5 +  Else
.head 6 -  Return ''
.head 5 -  Return strResult
.head 2 -  Named Menus
.head 2 -  Class Definitions
.head 2 +  Default Classes
.head 3 -  MDI Window: cBaseMDI
.head 3 -  Form Window:
.head 3 -  Dialog Box:
.head 3 -  Table Window:
.head 3 -  Quest Window:
.head 3 -  Data Field:
.head 3 -  Spin Field:
.head 3 -  Multiline Field:
.head 3 -  Pushbutton:
.head 3 -  Radio Button:
.head 3 -  Option Button:
.head 3 -  Check Box:
.head 3 -  Child Table:
.head 3 -  Quest Child Window: cQuickDatabase
.head 3 -  List Box:
.head 3 -  Combo Box:
.head 3 -  Picture:
.head 3 -  Vertical Scroll Bar:
.head 3 -  Horizontal Scroll Bar:
.head 3 -  Column:
.head 3 -  Background Text:
.head 3 -  Group Box:
.head 3 -  Line:
.head 3 -  Frame:
.head 3 -  Custom Control:
.head 2 +  Application Actions
.head 3 +  On SAM_AppStartup
.head 4 -  Set SqlDatabase='DELLIGR'
.head 4 -  Set SqlUser='BARS'
.head 4 -  Set SqlPassword='BARS'
.head 4 -  Call SqlConnect( hSql )
.head 4 -  ! ------------------ TEST BLOB ------------------
.head 4 -  ! Готовим вставку
.head 4 -  Call SqlPrepareAndExecute( hSql, 'DELETE FROM TMP_DG WHERE ID=1' )
.head 4 -  ! Из файла в BLOB
.head 4 +  If PutFileToBlob( hSql, 'D:\\BARS98\\BIN\\fcred.dll', 'TMP_DG', 'ID', 'LOBDATA', 1, '', '', 1 )
.head 5 -  Call SalMessageBox( 'Вставка прошла успешно!', 'BLOB: Вставка в БД', MB_IconAsterisk )
.head 4 +  Else
.head 5 -  Call SalMessageBox( 'Вставка прошла НЕ успешно!', 'BLOB: Вставка в БД', MB_IconStop )
.head 4 -  ! Из BLOBа в файл
.head 4 +  If PutBlobToFile( hSql, 'C:\\fcred.dll', 'TMP_DG', 'ID', 'LOBDATA', 1, '', '' )
.head 5 -  Call SalMessageBox( 'Выгрузка файла прошла успешно!', 'BLOB: Выгрузка файла', MB_IconAsterisk )
.head 4 +  Else
.head 5 -  Call SalMessageBox( 'Выгрузка файла прошла НЕ успешно!', 'BLOB: Выгрузка файла', MB_IconStop )
.head 4 -  ! ------------------ TEST CLOB ------------------
.head 4 -  ! Готовим вставку
.head 4 -  Call SqlPrepareAndExecute( hSql, 'DELETE FROM TMP_DG WHERE ID=1' )
.head 4 -  ! Тестовый размер строки 1Mb
.head 4 -  Set nTestStringSize = 1048576
.head 4 -  ! Set nTestStringSize = 4000
.head 4 -  ! Готовим строку нужного размера
.head 4 -  Set strTestString = ''
.head 4 +  Loop
.head 5 -  Set strTestString=strTestString || '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789-'
.head 5 +  If SalStrLength( strTestString )>nTestStringSize
.head 6 -  Break
.head 4 -  ! Готовим строку
.head 4 -  ! Set nTestStringSize = 1048576
.head 4 -  ! Set nTestStringSize = 64000
.head 4 -  ! Call SalStrSetBufferLength( strTestString, nTestStringSize )
.head 4 +  ! If VisFileOpen( hTextFile, 'C:\\Text_ori.txt', OF_Read | OF_Text ) = 0
.head 5 -  Set nTestStringSize = VisFileRead( hTextFile, strTestString, nTestStringSize )
.head 5 -  Call SalStrSetBufferLength( strTestString, nTestStringSize )
.head 5 -  Call VisFileClose( hTextFile )
.head 4 +  If PutStringToClob( hSql, strTestString, 'TMP_DG', 'ID', 'CLOBDATA', 1, '', '', 1 )
.head 5 -  Call SalMessageBox( 'Вставка прошла успешно!', 'CLOB: Вставка в БД', MB_IconAsterisk )
.head 4 +  Else
.head 5 -  Call SalMessageBox( 'Вставка прошла НЕ успешно!', 'CLOB: Вставка в БД', MB_IconStop )
.head 4 -  Set strTestStringFromDB=GetStringFromClob( hSql, 'TMP_DG', 'ID', 'CLOBDATA', 1, '', '' )
.head 4 +  If strTestStringFromDB=strTestString
.head 5 -  Call SalMessageBox( 'Чтение прошло успешно! Вставленая и прочтенная строка идентичны!', 'CLOB: Чтение из БД', MB_IconAsterisk )
.head 4 +  Else
.head 5 -  Call SalMessageBox( 'Чтение прошло НЕ успешно! Вставленая и прочтенная строка НЕ идентичны! См. C:\\Text_db.txt
Оригинальная строка: ' || SalNumberToStrX( SalStrLength( strTestString ), 0 ) || '
Прочтенная строка строка: ' || SalNumberToStrX( SalStrLength( strTestStringFromDB ), 0 ), 'CLOB: Чтение из БД', MB_IconStop )
.head 5 -  Set i=0
.head 5 +  Loop
.head 6 +  If SalStrMidX( strTestStringFromDB,i,1 ) != SalStrMidX( strTestString,i,1 )
.head 7 -  Call SalMessageBox( 'Ошибка в позиции '||SalNumberToStrX( i, 0 ), 'CLOB: Чтение из БД', MB_IconStop )
.head 6 -  Set i = i + 1
.head 6 +  If i+1>SalStrLength(strTestStringFromDB) or i+1>SalStrLength(strTestString)
.head 7 -  Call SalMessageBox( 'Достигнут конец одной из сторок. Ошибки не найдено. ', 'CLOB: Чтение из БД', MB_IconStop )
.head 7 -  Break
.head 5 +  If VisFileOpen( hTextFile, 'C:\\Text_db.txt', OF_Create | OF_Binary )=0
.head 6 -  Call VisFileWrite( hTextFile, strTestStringFromDB, SalStrLength( strTestStringFromDB ) )
.head 6 -  Call VisFileClose( hTextFile )
.head 3 +  On SAM_AppExit
.head 4 -  Call SqlDisconnect( hSql )
