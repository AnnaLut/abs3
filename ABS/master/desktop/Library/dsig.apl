.head 0 +  Application Description: ! Digital Signature Library
! Бибилиотека функций для работы с ЭЦП
! Подключать как Dynalib: dsig.apd
! SERG
.head 1 -  Outline Version - 4.0.26
.head 1 +  Design-time Settings
.data VIEWINFO
0000: 6F00000001000000 FFFF01000D004347 5458566965775374 6174650400010000
0020: 0000000000D40000 002C000000030000 00030000004B0000 00C6000000F8FFFF
0040: FFE2FFFFFFFCFFFF FFFEFFFFFF720200 00C3010000010000 0001000000010000
0060: 000F4170706C6963 6174696F6E497465 6D00000000
.enddata
.data DT_MAKERUNDLG
0000: 0200000000001C51 3A5C424152533938 5C4C494252415259 5C4162736170692E
0020: 646C6C1C513A5C42 41525339385C4C49 42524152595C4162 736170692E617063
0040: 00000101011C513A 5C4241525339385C 4C4942524152595C 4162736170692E72
0060: 756E1C513A5C4241 525339385C4C4942 524152595C416273 6170692E646C6C1C
0080: 513A5C4241525339 385C4C4942524152 595C416273617069 2E61706300000101
00A0: 01145C4241525339 385C42696E5C6473 69672E617064165C 4241525339385C42
00C0: 696E5C4162736170 692E646C6C165C42 41525339385C4269 6E5C416273617069
00E0: 2E61706300000101 01001C513A5C4241 525339385C4C4942 524152595C416273
0100: 6170692E646C6C1C 513A5C4241525339 385C4C4942524152 595C416273617069
0120: 2E61706300000101 01
.enddata
.head 2 -  Outline Window State: Normal
.head 2 +  Outline Window Location and Size
.data VIEWINFO
0000: 6600040003002D00 0000000000000000 0000B71E5D0E0500 1D00FFFF4D61696E
0020: 0000000000000000 0000000000000000 0000003B00010000 00000000000000E9
0040: 1E800A00008600FF FF496E7465726E61 6C2046756E637469 6F6E730000000000
0060: 0000000000000000 0000000000003200 0100000000000000 0000E91E800A0000
0080: DF00FFFF56617269 61626C6573000000 0000000000000000 0000000000000000
00A0: 3000010000000000 00000000F51E100D 0000F400FFFF436C 6173736573000000
00C0: 0000000000000000 0000000000000000
.enddata
.data VIEWSIZE
0000: D000
.enddata
.head 3 -  Left:   -0.013"
.head 3 -  Top:    0.0"
.head 3 -  Width:  8.013"
.head 3 -  Height: 4.969"
.head 2 +  Options Box Location
.data VIEWINFO
0000: 0218B80BB80B2500
.enddata
.data VIEWSIZE
0000: 0800
.enddata
.head 3 -  Visible? Yes
.head 3 -  Left:   4.15"
.head 3 -  Top:    1.885"
.head 3 -  Width:  3.8"
.head 3 -  Height: 2.073"
.head 2 +  Class Editor Location
.head 3 -  Visible? No
.head 3 -  Left:   0.575"
.head 3 -  Top:    0.094"
.head 3 -  Width:  5.063"
.head 3 -  Height: 2.719"
.head 2 +  Tool Palette Location
.head 3 -  Visible? No
.head 3 -  Left:   6.388"
.head 3 -  Top:    0.729"
.head 2 -  Fully Qualified External References? Yes
.head 2 -  Reject Multiple Window Instances? No
.head 2 -  Enable Runtime Checks Of External References? Yes
.head 2 -  Use Release 4.0 Scope Rules? No
.head 1 +  Libraries
.head 2 -  Dynalib: Global.apd
.head 2 -  Dynalib: ABSAPI.APD
.head 2 -  File Include: dsconst.apl
.head 2 -  File Include: dsdll.apl
.head 2 -  File Include: WINBARS2.APL
.head 2 -  File Include: CONSTANT.APL
.head 1 +  Global Declarations
.head 2 +  Window Defaults
.head 3 +  Tool Bar
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Form Window
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Dialog Box
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Top Level Table Window
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Data Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Multiline Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Spin Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Background Text
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Pushbutton
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Radio Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Check Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Option Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Group Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Child Table Window
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  List Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Combo Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Line
.head 4 -  Line Color: Use Parent
.head 3 +  Frame
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: 3D Face Color
.head 3 +  Picture
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 2 +  Formats
.head 3 -  Number: 0'%'
.head 3 -  Number: #0
.head 3 -  Number: ###000
.head 3 -  Number: ###000;'($'###000')'
.head 3 -  Date/Time: hh:mm:ss AMPM
.head 3 -  Date/Time: M/d/yy
.head 3 -  Date/Time: MM-dd-yy
.head 3 -  Date/Time: dd-MMM-yyyy
.head 3 -  Date/Time: MMM d, yyyy
.head 3 -  Date/Time: MMM d, yyyy hh:mm AMPM
.head 3 -  Date/Time: MMMM d, yyyy hh:mm AMPM
.head 2 +  External Functions
.head 2 +  Constants
.data CCDATA
0000: 3000000000000000 0000000000000000 00000000
.enddata
.data CCSIZE
0000: 1400
.enddata
.head 3 +  System
.head 3 +  User
.head 2 -  Resources
.head 2 +  Variables
.data RESOURCE 0 0 1 2177790550
0000: 6C0000002A000000 0000000000000000 0200000400000058 010000E0010D0000
0020: 00FF3F6501BA0001 00FFFFE872010001 FE00FFA37F010001 FB00FF0F
.enddata
.head 3 -  ! // SECURAPI - Переменные ///////////////////////////////////////////////////////
.head 3 -  !
.head 3 -  Number: nUserId
.head 3 -  !
.head 3 -  String: strUserLogin
.head 3 -  String: strLogName
.head 3 -  !
.head 3 -  Number: nFetchRes
.head 3 -  !
.head 3 -  ! !
.head 3 -  String: strBars98ini			!   Имя INI-файла
.head 3 -  ! !
.head 3 -  ! ! // SQLAPI.APL - Переменные //////////////////////////////////////////////////
.head 3 -  ! !
.head 3 -  Boolean: bRollback
.head 3 -  ! !
.head 3 -  Number: nLastSerial
.head 3 -  ! !
.head 3 -  ! ! // PRINTAPI - Переменные //////////////////////////////////////////////////////
.head 3 -  ! !
.head 3 -  ! ! // для печати таблиц
.head 3 -  ! !
.head 3 -  String: strColumnHeader[*]
.head 3 -  Number: nColumnWidth[*]
.head 3 -  Number: nColumnID[*]
.head 3 -  Number: nColumnJustify[*]
.head 3 -  Boolean: bColumnSum[*]
.head 3 -  Number: nColumns
.head 3 -  ! !
.head 3 -  ! ! // для печати документов
.head 3 -  ! !
.head 3 -  Long String: szVArray[*,2]
.head 3 -  Number: nVarNum
.head 3 -  ! !
.head 3 -  Number: nLeftMargin
.head 3 -  Number: nRightMargin
.head 3 -  Number: nTextWidth
.head 3 -  Number: nCenterMode
.head 3 -  Number: nActualWidth
.head 3 -  ! !
.head 3 -  ! Глобальные переменные для функций DSig_*
.head 3 -  Boolean: g_bSignInited	    			! __exported
.head 3 -  String: g_sBuf
.head 3 -  String: g_sUid
.head 3 -  String: g_sUidCheck
.head 3 -  Number: g_nNullContext
.head 3 -  Number: g_nCredHandle
.head 3 -  Number: g_nTim          			! __exported
! время переинициализации подписи (в минутах)
.head 3 -  Boolean: g_InsertCertFlag 
! флаг необходимости вставки сертификата в БД
.head 3 -  Long String: g_lsSecretKey   ! Секрентный ключ
.head 3 -  Long String: g_lsSecretKeyCopy   ! Копия секретного ключа
(необх. для отката при записи измененного ключа на TouchMemory)
.head 3 -  Long String: g_lsCertificate  !  сертификат откр. ключа
.head 3 -  Number: g_nErrorSign				! __exported
! глобальный код ошибки ЭЦП
.head 3 -  String: g_strErrorSign				! __exported
! глобальное описание кода ошибки ЭЦП
.head 3 -  Boolean: g_hideErrorMsg				! __exported
.head 3 -  ! скрывать сообщения об ошибках при проверке ЭЦП
.head 2 +  Internal Functions
.head 3 +  Function: TestDsig				! __exported
.head 4 -  Description:
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! ! cDoc: doc
.head 5 -  Number: nFetchRes
.head 5 -  String: p_val
.head 4 +  Actions
.head 5 -  Call Debug( 'TestDsig' )
.head 5 +  While TRUE
.head 6 -  Call Debug( '0' )
.head 6 +  If not SqlPrepareAndExecute( hSql(), "SELECT substr(val,1,10) FROM params WHERE par='BANKDATE' INTO :p_val" )
.head 7 -  Break
.head 6 -  Call Debug( '1' )
.head 6 +  If not SqlFetchNext( hSql(), nFetchRes )
.head 7 -  Break
.head 6 -  Call Debug( '3' )
.head 6 -  Call Debug( 'p_val='||p_val )
.head 6 -  Break
.head 3 -  ! Функции работы с ЭЦП (для использования в классе cDoc)
.head 3 +  Function: DSig_UNIFormatMessage			! __exported
.head 4 -  Description: возвращает описание ошибки ЭЦП UNI
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  Number: nErrorCode
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: strMessage
.head 5 -  Number: nMsgSize
.head 5 -  Number: nBufAddress
.head 5 -  Number: message_context
.head 5 -  Number: min_status
.head 5 -  Number: maj_status
.head 4 +  Actions
.head 5 -  Call SalStrSetBufferLength( strMessage, 4096 )
.head 5 -  Set message_context = 0
.head 5 -  Set maj_status = gss_display_status(
	min_status,
	nErrorCode,
	2, 0,
	message_context,
	nMsgSize, nBufAddress
)
.head 5 -  Call memmove( strMessage, NumPtr2Str( nBufAddress ), nMsgSize )
.head 5 -  Set strMessage = Left(strMessage,nMsgSize) || Chr(0)
.head 5 -  Call gss_release_buffer( min_status, nMsgSize, nBufAddress )
.head 5 -  Return 'UNI: KeyID='||GetIdOper()||PutCrLf()||
  ' Error='||SalNumberToStrX( nErrorCode, 0 )
  ||PutCrLf()||strMessage
.head 3 +  Function: DSig_UNIFormatGSSMessage		! __exported
.head 4 -  Description: возвращает описание ошибки ЭЦП UNI функций GSS
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  Number: minor_status
.head 5 -  Number: status_value
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: strMessage
.head 5 -  String: strBuf
.head 5 -  String: strBuf2
.head 5 -  Number: nMsgSize
.head 5 -  Number: nBufAddress
.head 5 -  Number: nMsgSize2
.head 5 -  Number: nBufAddress2
.head 5 -  Number: message_context
.head 5 -  Number: maj_status
.head 5 -  Number: min_status
.head 4 +  Actions
.head 5 -  Set strMessage = ''
.head 5 -  ! --1
.head 5 -  Call SalStrSetBufferLength( strBuf, 4096 )
.head 5 -  Set message_context = 0
.head 5 -  Set nMsgSize = 0
.head 5 -  Set nBufAddress = 0
.head 5 -  Set maj_status = gss_display_status(
	min_status,
	status_value,
	1, 0,
	message_context,
	nMsgSize, nBufAddress
)
.head 5 -  Call memmove( strBuf, NumPtr2Str( nBufAddress ), nMsgSize )
.head 5 -  Set strBuf = Left(strBuf,nMsgSize) || Chr(0)
.head 5 -  Call gss_release_buffer( min_status, nMsgSize, nBufAddress )
.head 5 -  Set strMessage = strMessage || strBuf
.head 5 -  ! --2
.head 5 -  Call SalStrSetBufferLength( strBuf2, 4096 )
.head 5 -  Set message_context = 0
.head 5 -  Set nMsgSize2 = 0
.head 5 -  Set nBufAddress2 = 0
.head 5 -  Set maj_status = gss_display_status(
	min_status,
	minor_status,
	2, 0,
	message_context,
	nMsgSize2, nBufAddress2
)
.head 5 -  Call memmove( strBuf2, NumPtr2Str( nBufAddress2 ), nMsgSize2 )
.head 5 -  Set strBuf2 = Left(strBuf2,nMsgSize2) || Chr(0)
.head 5 -  Call gss_release_buffer( min_status, nMsgSize2, nBufAddress2 )
.head 5 -  Set strMessage = strMessage || strBuf2
.head 5 -  Return 'UNI: KeyID='||GetIdOper()
  ||PutCrLf()||'minor_status='
    ||SalNumberToStrX( minor_status, 0 )||' ('||NumberToHexSX(minor_status)||')'
  ||PutCrLf()||'status_value='
    ||SalNumberToStrX( status_value, 0 )||' ('||NumberToHexSX(status_value)||')'
  ||PutCrLf()||strMessage
.head 3 +  Function: DSig_CredFormatMessage		! __exported
.head 4 -  Description: Возвращает описание ошибок для функций библиотеки CreateCred.dll
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  Number: nErrorCode
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: strMessage
.head 4 +  Actions
.head 5 -  Call SalStrSetBufferLength( strMessage, 4096 )
.head 5 +  ! Select Case ( nErrorCode )
.head 6 +  Case 0
.head 7 -  Set strMessage = 'Ok'
.head 7 -  Break
.head 6 +  Case 1
.head 7 -  Set strMessage = 'Неопределенная ошибка'
.head 7 -  Break
.head 6 +  Case 3
.head 7 -  Set strMessage = 'Время ожидания закончилось'
.head 7 -  Break
.head 6 +  Case 4
.head 7 -  Set strMessage = 'Программа NbuSecurity не запущена'
.head 7 -  Break
.head 6 +  Case 5
.head 7 -  Set strMessage = 'Недопустимые аргументы'
.head 7 -  Break
.head 6 +  Default
.head 7 -  Set strMessage = 'Неизвестный код ошибки ' || Str(nErrorCode)
.head 5 -  Set strMessage = SalNumberToStrX( nErrorCode, 0 )
|| ' - Помилка системи захисту НБУ'
.head 5 -  Return strMessage
.head 3 +  Function: DSig_DefaultSignSize			! __exported
.head 4 -  Description: Возвращает размер буфера ЭЦП используемого в системе типа
.head 4 +  Returns
.head 5 -  Number:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 -  Local variables
.head 4 +  Actions
.head 5 -  Return DSig_GetSignSize( GetSignType() )
.head 3 +  Function: DSig_GetSignSize 			! __exported
.head 4 -  Description: Возвращает размер буфера ЭЦП указанного типа
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  String: strSignType
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: locSignType
.head 5 -  Number: nSignSize
.head 4 +  Actions
.head 5 -  Set locSignType = strSignType
.head 5 +  If locSignType = STRING_Null
.head 6 -  Set locSignType = GetSignType()
.head 5 +  If locSignType = 'NBU'
.head 6 -  Set nSignSize = NBU_SIGN_SIZE
.head 5 +  Else If locSignType = 'PRX'
.head 6 -  Set nSignSize = PRX_SIGN_SIZE
.head 5 +  Else If locSignType = 'VEG'
.head 6 -  Set nSignSize = VEG_SIGN_SIZE
.head 5 +  Else If locSignType = 'UNI'
.head 6 -  Set nSignSize = UNI_SIGN_SIZE
.head 5 +  Else If locSignType = 'UKR'
.head 6 -  Set nSignSize = UKR_SIGN_SIZE
.head 5 +  Else If locSignType = 'KAZ'
.head 6 -  Set nSignSize = 66
.head 5 +  Else If locSignType = 'HCB'
.head 6 -  Set nSignSize = 128
.head 5 +  Else If locSignType = 'SSF'
.head 6 -  ! Длинну подписи берем из params
.head 6 -  Set nSignSize = GetGlobalOptionEx('SSF_SLEN')
.head 6 -  ! Если не нашли - по дефолту 717
.head 6 +  If nSignSize = NUMBER_Null
.head 7 -  Set nSignSize = 717
.head 5 +  Else
.head 6 -  Call Debug( 'Ошибка: неизвестный тип ЭЦП '||locSignType )
.head 6 -  Set nSignSize = 0
.head 5 -  Return nSignSize
.head 3 +  Function: DSig_GetSepSignMsg			! __exported
.head 4 -  Description: возвращает описание ошибки
инициализации/наложения/снятия ЭЦП СЭП НБУ
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  Number: nCode
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: strMsg
.head 4 +  Actions
.head 5 +  Select Case (Abs(nCode))
.head 6 +  Case 0
.head 7 -  Set strMsg = 'Ok'
.head 7 -  Break
.head 6 +  Case 1
.head 7 -  Set strMsg = 'Подпись неверна'
.head 7 -  Break
.head 6 +  Case 2
.head 7 -  Set strMsg = 'Недостаточно памяти'
.head 7 -  Break
.head 6 +  Case 3
.head 7 -  Set strMsg = 'Неверно указан дисковод с дискетой с секретным ключом'
.head 7 -  Break
.head 6 +  Case 4
.head 7 -  Set strMsg = 'Ошибка работы с файлом секретного ключа'
.head 7 -  Break
.head 6 +  Case 5
.head 7 -  Set strMsg = 'Неверно указан путь к таблицам открытых ключей'
.head 7 -  Break
.head 6 +  Case 6
.head 7 -  Set strMsg = 'Ошибка работы с индексным файлом pub_odb.ind'
.head 7 -  Break
.head 6 +  Case 7
.head 7 -  Set strMsg = 'Индексный файл pub_odb.ind испорчен'
.head 7 -  Break
.head 6 +  Case 8
.head 7 -  Set strMsg = 'Ошибка работы с файлом открытых ключей pub_odb.key'
.head 7 -  Break
.head 6 +  Case 9
.head 7 -  Set strMsg = 'Файл открытых ключей pub_odb.key испорчен'
.head 7 -  Break
.head 6 +  Case 10
.head 7 -  Set strMsg = 'Не найден идентификатор открытого ключа'
.head 7 -  Break
.head 6 +  Case 11
.head 7 -  Set strMsg = 'Испорчена строка в таблице открытых ключей'
.head 7 -  Break
.head 6 +  Case 12
.head 7 -  Set strMsg = 'Срок действия ключа истек'
.head 7 -  Break
.head 6 +  Case 13
.head 7 -  Set strMsg = 'Секретный ключ испорчен'
.head 7 -  Break
.head 6 +  Case 14
.head 7 -  Set strMsg = 'Файл секретного ключа переименован'
.head 7 -  Break
.head 6 +  Case 15
.head 7 -  Set strMsg = 'Несовпадение номера сеанса генерации ключа'
.head 7 -  Break
.head 6 +  Case 16
.head 7 -  Set strMsg = 'Несоответствие открытого и секретного ключа'
.head 7 -  Break
.head 6 +  Case 17
.head 7 -  Set strMsg = 'Ошибка чтения входного файла'
.head 7 -  Break
.head 6 +  Case 18
.head 7 -  Set strMsg = 'Подпись сделана старым ключом'
.head 7 -  Break
.head 6 +  Case 20
.head 7 -  Set strMsg = 'Прерывание пользователя (при работе с Touch Memory)'
.head 7 -  Break
.head 6 +  Case 21
.head 7 -  Set strMsg = 'Ошибка чтения при работе с Touch Memory'
.head 7 -  Break
.head 6 +  Case 22
.head 7 -  Set strMsg = 'Неверный пароль для секретного ключа'
.head 7 -  Break
.head 6 +  Case 47
.head 7 -  Set strMsg = 'Несоответствие файла pub_odb.key и pub_odb.ind'
.head 7 -  Break
.head 6 +  Case 70
.head 7 -  Set strMsg = 'Последний день действия ключа'
.head 7 -  Break
.head 6 +  Case 71
.head 7 -  Set strMsg = 'До истечения срока действия ключа остался 1 день'
.head 7 -  Break
.head 6 +  Case 72
.head 7 -  Set strMsg = 'До истечения срока действия ключа осталось 2 дня'
.head 7 -  Break
.head 6 +  Case 73
.head 7 -  Set strMsg = 'До истечения срока действия ключа осталось 3 дня'
.head 7 -  Break
.head 6 +  Case 74
.head 7 -  Set strMsg = 'До истечения срока действия ключа осталось 4 дня'
.head 7 -  Break
.head 6 +  Case 75
.head 7 -  Set strMsg = 'До истечения срока действия ключа осталось 5 дней'
.head 7 -  Break
.head 6 +  Case 76
.head 7 -  Set strMsg = 'До истечения срока действия ключа осталось 6 дней'
.head 7 -  Break
.head 6 +  Case 91
.head 7 -  Set strMsg = 'Неверные параметры вызова функции'
.head 7 -  Break
.head 6 +  Case 92
.head 7 -  Set strMsg = 'Неверно указан тип параметров вызова функции'
.head 7 -  Break
.head 6 +  Default
.head 7 -  Set strMsg = ''
.head 7 -  Break
.head 5 -  Return strMsg
.head 3 +  Function: DSig_InsertCert2DB			! __exported
.head 4 -  Description: Вставка сертификата открытого ключа в БД
если его там нету
.head 4 -  Returns
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: szTestMsg
.head 5 -  Number: nTestMsgLen
.head 5 -  Long String: lsCertID
.head 5 -  String: szHexCertID
.head 5 -  Number: i
.head 5 -  Number: nChar
.head 5 -  Number: nLowPart
.head 5 -  Number: nHighPart
.head 5 -  Number: nKeyCount
.head 5 -  Number: nFetchRes
.head 5 -  Number: nErrorSign
.head 5 -  String: strErrorSign
.head 5 -  String: szTempBuf
.head 5 -  String: szOperID
.head 5 -  Number: min_status
.head 5 -  Number: maj_status
.head 5 -  Number: nSignLen
.head 5 -  Number: nCertLen
.head 5 -  Number: nSignHandle
.head 5 -  Number: nCertHandle
.head 5 -  Long String: loc_lsSign
.head 5 -  Long String: loc_lsCertificate
.head 5 -  Long String: strHexCertificate
.head 5 -  Number: nIns
.head 4 +  Actions
.head 5 +  If g_InsertCertFlag
.head 6 -  ! Call Debug( 'InsertCertFlag=TRUE' )
.head 5 +  Else
.head 6 -  ! Call Debug( 'InsertCertFlag=FALSE' )
.head 5 +  If g_InsertCertFlag
.head 6 +  If GetSignType() = 'UNI'  ! только для внутр. подписи НБУ
.head 7 -  ! Сначала подпишем тестовую строку,
чтобы получить сертификат откр. ключа
.head 7 -  Call SalStrSetBufferLength( loc_lsSign, UNI_SIGN_SIZE+1 )
.head 7 -  Call SalStrSetBufferLength( loc_lsCertificate, UNI_CERT_SIZE+1 )
.head 7 -  Set szTestMsg = 'Тестовое сообщение для ЭЦП'
.head 7 -  Set nTestMsgLen = SalStrLength( szTestMsg )
.head 7 -  Set nCertLen = UNI_CERT_SIZE
.head 7 -  Set nErrorSign = NG_CREATE_SIGN_CRED( min_status,
			g_nCredHandle,
			nTestMsgLen, szTestMsg,
			nSignLen, nSignHandle,
			nCertLen, nCertHandle)
.head 7 +  If nErrorSign
.head 8 -  Call MessageErrorEx( DSig_UNIFormatGSSMessage(min_status, nErrorSign) )
.head 8 -  Return 0
.head 7 -  Call ConvertHexToBin( NumPtr2HexStr(nSignHandle, nSignLen),
	loc_lsSign, nSignLen )
.head 7 -  Call ConvertHexToBin( NumPtr2HexStr(nCertHandle, nCertLen),
	loc_lsCertificate, nCertLen )
.head 7 -  Call SalStrSetBufferLength( strHexCertificate, 2*nCertLen+1 )
.head 7 -  Call ConvertBinToHex( loc_lsCertificate, strHexCertificate, nCertLen )
.head 7 -  ! Вычленяем 9 байт ID сертификата
.head 7 -  Set szHexCertID = SalStrRepeatX( SalNumberToChar( 0 ), 9 )
.head 7 -  Set i = 0
.head 7 +  Loop
.head 8 +  If i=7
.head 9 -  Break
.head 8 -  Call SalStrLop( loc_lsSign )
.head 8 -  Set i = i+1
.head 7 -  Set i = 0
.head 7 +  Loop
.head 8 +  If i=9
.head 9 -  Break
.head 8 -  Set nChar = SalStrLop( loc_lsSign )
.head 8 -  Set nLowPart  = nChar & 0x0F
.head 8 -  Set nHighPart = ( nChar & 0xF0 ) / 16
.head 8 -  Set szHexCertID = szHexCertID || DSig_GetHexChar(nHighPart)||DSig_GetHexChar(nLowPart)
.head 8 -  Set i = i+1
.head 7 -  ! Call Debug('HexCrtID='||szHexCertID)
.head 7 -  ! Ищем такой HexCertID в базе
.head 7 +  ! If SqlPrepareAndExecute(hSql(),"SELECT count(key_id)
INTO :nKeyCount FROM keys WHERE key_id=:szHexCertID ")
.head 8 +  If SqlFetchNext(hSql(), nFetchRes)
.head 9 +  If nKeyCount=0 ! не нашли такого ключа
.head 10 -  ! надо вставить
.head 10 -  Set szOperID = GetIdOper()
.head 10 +  If not SqlPrepare(hSql(),
"INSERT INTO keys(key_id,user_id,put_date,key)
VALUES(:szHexCertID,:szOperID,SYSDATE,:loc_lsCertificate)")
.head 11 -  Return 0
.head 10 +  If not SqlSetLongBindDatatype(3, BLOB_BYTE)
.head 11 -  Call SqlRollback( hSql() )
.head 11 -  Return 0
.head 10 +  If not SqlExecute(hSql())
.head 11 -  Call SqlRollback( hSql() )
.head 11 -  Return 0
.head 10 -  Call SalMessageBox( 'Сертификат '||szHexCertID||' открытого ключа '||szOperID
||' помещен в БД',
'Сообщение', MB_Ok | MB_IconAsterisk)
.head 7 -  Set nIns = 0
.head 7 -  Set szOperID = GetIdOper()
.head 7 +  If NOT SqlPLSQLCommand( hSql(),"put_cert_to_db(szOperID,szHexCertID,strHexCertificate,nIns)" )
.head 8 -  Call Debug( 'Ошибка при вызове put_cert_to_db()' )
.head 8 -  Return 0
.head 7 +  If nIns=1
.head 8 -  Call SalMessageBox( 'Сертификат '||szHexCertID||' открытого ключа '||szOperID
||' помещен в БД',
'Сообщение', MB_Ok | MB_IconAsterisk)
.head 3 +  Function: DSig_GetHexChar			! __exported
.head 4 -  Description: возвращает символ hex по заданному числу
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  Number: nVal
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: szHexVal
.head 4 +  Actions
.head 5 -  Set szHexVal = ''
.head 5 +  If nVal>=0 AND nVal<=9
.head 6 -  Set szHexVal = SalNumberToStrX( nVal, 0 )
.head 5 +  Else
.head 6 +  Select Case nVal
.head 7 +  Case 10
.head 8 -  Set szHexVal = 'A'
.head 8 -  Break
.head 7 +  Case 11
.head 8 -  Set szHexVal = 'B'
.head 8 -  Break
.head 7 +  Case 12
.head 8 -  Set szHexVal = 'C'
.head 8 -  Break
.head 7 +  Case 13
.head 8 -  Set szHexVal = 'D'
.head 8 -  Break
.head 7 +  Case 14
.head 8 -  Set szHexVal = 'E'
.head 8 -  Break
.head 7 +  Case 15
.head 8 -  Set szHexVal = 'F'
.head 8 -  Break
.head 5 -  Return szHexVal
.head 3 +  Function: DSig_iSignData			! __exported
.head 4 -  Description: Возвращает подписываемую строку для внутренней ЭЦП
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  Number: nRef
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Long String: lsBuf
.head 5 -  String: sBuf
.head 4 +  Actions
.head 5 -  ! Return PadR(sNd,10)||SalFmtFormatDateTime(dDatD,'yyMMdd')||
    PadL(SalNumberToStrX(nDk, 0), 1) ||
    PadL(BankA, 9)||PadL(NlsA, 14)||PadL(SalNumberToStrX(KvA, 0),3)||PadL(SalNumberToStrX(SA, 0),16)||
    PadL(BankB, 9)||PadL(NlsB, 14)||PadL(SalNumberToStrX(KvB, 0),3)||PadL(SalNumberToStrX(SB, 0),16)
.head 5 +  If NOT SqlPLSQLCommand( hSql(),"chk.make_int_docbuf(nRef,lsBuf)" )
.head 6 -  Call SaveErrorToLog('Ошибка выполнения chk.make_int_docbuf()')
.head 6 -  Return STRING_Null
.head 5 -  Set sBuf = lsBuf
.head 5 -  Return sBuf
.head 3 +  Function: DSig_PutVis				! __exported
.head 4 -  Description: Вставка внутренней подписи (новой)
.head 4 -  Returns
.head 4 +  Parameters
.head 5 -  Number: nRef
.head 5 -  String: sTT
.head 5 -  Number: nGrp
.head 5 -  Number: nStat
.head 5 -  String: sKey
.head 5 -  Long String: lsSignIntHex
.head 5 -  Long String: lsSignExtHex
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: lsTempInt
.head 5 -  String: lsTempExt
.head 5 -  String: strKey
.head 4 +  Actions
.head 5 -  ! Call Debug( 'PutVis()' )
.head 5 -  ! Call MessageNoWait( 'Call DSig_PutVis():
nRef='||Str(nRef)||',sTT='||sTT||',nGrp='||Str(nGrp)||',nStat='||Str(nStat)
||',sKey='||sKey
,'DSig_PutVis',35,0
)
.head 5 +  If GetSignOn() = 0 ! ЭЦП отключена?
.head 6 -  Set sKey = STRING_Null
.head 6 -  Set lsSignIntHex = STRING_Null
.head 6 -  Set lsSignExtHex = STRING_Null
.head 5 +  While TRUE
.head 6 +  If SalStrTrimX(SalStrUpperX(GetDBMS()))='ORACLE'
.head 7 +  If not SqlPLSQLCommand(hSql(), "chk.put_visa(nRef,sTT,nGrp,nStat,sKey,lsSignIntHex,lsSignExtHex)")
.head 8 -  ! Call Debug('Ошибка вызова chk.put_visa()')
.head 8 -  Break
.head 6 +  Else
.head 7 -  Return FALSE
.head 6 -  ! Call Debug( 'PutVis() before return TRUE' )
.head 6 -  Return TRUE
.head 5 -  Call SqlRollback(hSql())
.head 5 -  Return FALSE
.head 3 +  Function: DSig_GetDayStrByNum			! __exported
.head 4 -  Description: Возвращает строку 'день', 'дня', 'дней'
в зависимости от кол-ва дней - параметра nDays
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  Number: nDays
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nMod  ! последняя цифра числа
.head 4 +  Actions
.head 5 -  Set nMod = SalNumberMod(nDays,10)
.head 5 +  If nDays>=11 AND nDays<=14  ! Исключение
.head 6 -  Return 'дней'
.head 5 +  Else If nMod=1
.head 6 -  Return 'день'
.head 5 +  Else If nMod>=2 AND nMod<=4
.head 6 -  Return 'дня'
.head 5 +  Else
.head 6 -  Return 'дней'
.head 3 +  Function: DSig_WriteTM				! __exported
.head 4 -  Description: ! Писать на ТМ
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nTmp
.head 5 -  Number: nRes
.head 5 -  String: sTmp
.head 5 -  String: strTMFile
.head 5 -  String: strTMSystem
.head 4 +  Actions
.head 5 -  Set strTMSystem=GetTMSystem()
.head 5 +  If strTMSystem='FILE'  ! TM - файловая система
.head 6 -  Set nRes = TMinit( GetTMAdapter(), GetTMPort() )
.head 5 +  Else If strTMSystem='RAW' ! TM - сырое устройство
.head 6 -  Set nRes = TMinitOwn(GetTMAdapter(),GetTMPort(),GetTMType())
.head 5 +  If not nRes
.head 6 +  If strTMSystem='FILE'  ! TM - файловая система
.head 7 -  Set strTMFile = SalStrMidX ( GetIdOper(), 0, 4 )
|| '.' || SalStrMidX ( GetIdOper(), 4, 2 )
.head 7 -  Set nRes = TMwrite( strTMFile, g_lsSecretKey, VEGA_SKFILE_SIZE )
.head 6 +  Else If strTMSystem='RAW' ! TM - сырое устройство
.head 7 -  Set nRes = TMwriteOwn( g_lsSecretKey,10, VEGA_SKFILE_SIZE )
.head 5 +  If nRes=0
.head 6 -  Return nRes
.head 5 +  If strTMSystem='FILE'  ! TM - файловая система
.head 6 -  Call TMdone()
.head 6 -  Return nRes+600
.head 5 +  Else If strTMSystem='RAW' ! TM - сырое устройство
.head 6 -  Call TMdoneOwn()
.head 6 -  Return nRes+500
.head 3 +  Function: DSig_ReadTM				! __exported
.head 4 -  Description: ! Читать ТМ
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nTmp
.head 5 -  Number: i
.head 5 -  String: sTmp
.head 5 -  String: strTMSystem
.head 5 -  Number: nAdapter
.head 5 -  Number: nPort
.head 5 -  Number: nType
.head 5 -  String: strTMFile
.head 4 +  Actions
.head 5 -  ! Call Debug( 'Работаем с TM - Init, Read, Done' )
.head 5 -  Set strTMSystem = GetTMSystem()
.head 5 -  Set nAdapter = GetTMAdapter()
.head 5 -  Set nPort = GetTMPort()
.head 5 -  Set nType = GetTMType()
.head 5 -  ! Call Debug( 'TMInit('||SalNumberToStrX(nAdapter,0)||','
||SalNumberToStrX(nPort,0)||','||SalNumberToStrX(nType,0)||')')
.head 5 +  If strTMSystem='FILE'  ! TM - файловая система
.head 6 -  Set i = TMinit( GetTMAdapter(), GetTMPort() )
.head 6 +  If i
.head 7 -  Call SaveErrorToLog( 'TouchMemory: '
||'TMinit('||SalNumberToStrX(nAdapter,0)||','
||SalNumberToStrX(nPort,0)||') return '
||SalNumberToStrX(i,0) )
.head 5 +  Else If strTMSystem='RAW' ! TM - сырое устройство
.head 6 -  Set i = TMinitOwn(GetTMAdapter(),GetTMPort(),GetTMType())
.head 6 +  If i
.head 7 -  Call SaveErrorToLog( 'TouchMemory: '
||'TMinitOwn('||SalNumberToStrX(nAdapter,0)||','
||SalNumberToStrX(nPort,0)||','||SalNumberToStrX(nType,0)||') return '
||SalNumberToStrX(i,0) )
.head 5 +  Else
.head 6 -  Call SalMessageBox( 'Unknown TouchMemory System', 'Error',
MB_IconStop|MB_Ok )
.head 6 -  Return FALSE
.head 5 +  If not i
.head 6 -  Call SalStrSetBufferLength( sTmp, 9 )
.head 6 +  If strTMSystem='RAW' ! TM - сырое устройство
.head 7 -  Set i=TMcheckOwn(sTmp,nTmp)
.head 7 +  If i
.head 8 -  ! Call Debug( 'TMcheck() return '||SalNumberToStrX(i,0) )
.head 8 -  Call SaveErrorToLog( 'TouchMemory: '
||'TMcheck() return '||SalNumberToStrX(i,0) )
.head 6 +  If not i
.head 7 -  Call SalStrSetBufferLength( g_lsSecretKey, 513 )
.head 7 -  Call SalStrSetBufferLength( g_lsSecretKeyCopy, 513 )
.head 7 +  If strTMSystem='FILE'  ! TM - файловая система
.head 8 -  Set strTMFile = SalStrMidX ( GetIdOper(), 0, 4 )
|| '.' || SalStrMidX ( GetIdOper(), 4, 2 )
.head 8 -  Set i=TMread( strTMFile, g_lsSecretKey, 360 )
.head 8 +  If i
.head 9 -  ! Call Debug( 'TMread() return '||SalNumberToStrX(i,0) )
.head 9 -  Call SaveErrorToLog( 'TouchMemory: '
||'TMread() return '||SalNumberToStrX(i,0) )
.head 8 -  ! делаем копию секр. ключа
.head 8 +  If not i
.head 9 -  Set i = TMread( strTMFile, g_lsSecretKeyCopy, 360 )
.head 7 +  Else If strTMSystem='RAW' ! TM - сырое устройство
.head 8 -  Set i=TMreadOwn(g_lsSecretKey,10,512-10)
.head 8 +  If i
.head 9 -  ! Call Debug( 'TMread() return '||SalNumberToStrX(i,0) )
.head 9 -  Call SaveErrorToLog( 'TouchMemory: '
||'TMread() return '||SalNumberToStrX(i,0) )
.head 8 -  ! делаем копию секр. ключа
.head 8 +  If not i
.head 9 -  Set i = TMreadOwn(g_lsSecretKeyCopy,10,512-10)
.head 5 +  If i=0
.head 6 -  Return 0
.head 5 +  If strTMSystem='FILE'  ! TM - файловая система
.head 6 -  Call TMdone()
.head 6 -  Return i+600
.head 5 +  Else If strTMSystem='RAW' ! TM - сырое устройство
.head 6 -  Call TMdoneOwn()
.head 6 -  Return i+500
.head 3 +  Function: DSig_ReadToken                        ! __exported
.head 4 -  Description:
.head 4 -  Returns
.head 4 +  Parameters
.head 5 -  Receive String: sPIN
.head 5 -  Receive String: sErr
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sUserKey
.head 5 -  String: sUserPass
.head 5 -  ! String: sUserKeyName
.head 5 -  ! String: sPIN
.head 5 -  ! Number: i
.head 4 +  Actions
.head 5 +  If not (TokenInit() and TokenLogin(sPIN))
.head 6 -  Call SalStrSetBufferLength( sErr, 513 )
.head 6 -  Set sErr = TokenError()
.head 6 -  Set sErr = 'eToken: '|| sErr
.head 6 -  Return 700
.head 5 -  !
.head 5 -  Call SalStrSetBufferLength( sUserPass, 513 )
.head 5 -  Set sUserPass = TokenViewData('Nadra', 'UserPass')
.head 5 +  If sUserPass = STRING_Null
.head 6 -  Set sErr= 'eToken: No Nadra UserPass there'
.head 6 -  Return 700
.head 5 +  Else
.head 6 -  Set sPIN=sUserPass
.head 5 -  !
.head 5 -  Call SalStrSetBufferLength( sUserKey, 1025 )
.head 5 -  Set sUserKey = TokenViewData('Nadra', 'UserKey')
.head 5 +  If sUserKey = STRING_Null
.head 6 -  Set sErr= 'eToken: No Nadra UserKey there'
.head 6 -  Return 700
.head 5 +  Else
.head 6 -  Call SalStrSetBufferLength( g_lsSecretKey, 513 )
.head 6 -  Call ConvertHexToBin(sUserKey, g_lsSecretKey, 513 )  ! HEX --> BIN
.head 5 -  Call TokenLogout()
.head 5 -  Call TokenFinalize()
.head 5 -  Set sErr= STRING_Null
.head 5 -  Return 0
.head 3 +  Function: DSig_sTrace				! __exported
.head 4 -  Description: ! Трассировка подписей в файл
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  String: sString
.head 5 -  Number: nLenS
.head 5 -  Long String: lsSign
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Date/Time: dDatTmp
.head 5 -  File Handle: hFile
.head 5 -  String: sFn
.head 5 -  Long String: lsSignHex
.head 5 -  Number: nSignLen
.head 4 +  Actions
.head 5 -  Set sFn = GetPrnDir() || '\\' || 'SIGNTRAC.TXT'
.head 5 +  If SalFileGetDateTime(sFn, dDatTmp)
.head 6 -  Call SalFileOpen(hFile, sFn, OF_Append | OF_Binary)
.head 5 +  Else
.head 6 -  Call SalFileOpen(hFile, sFn, OF_Create | OF_Write | OF_Binary)
.head 5 -  Call SalFileWrite(hFile, sString, nLenS)
.head 5 -  Set nSignLen = DSig_DefaultSignSize()
.head 5 -  Call SalStrSetBufferLength( lsSignHex, nSignLen * 2 + 1 )
.head 5 -  Call ConvertBinToHex( lsSign, lsSignHex, nSignLen )  ! BIN->HEX
.head 5 -  ! Call Debug( 
'sTrace():'||'
sString='||SalStrLeftX( sString, nLenS )||', 
nLenS='||SalNumberToStrX( nLenS, 0 )||',
lsSignHex='||lsSignHex
)
.head 5 -  Call SalFilePutStr(hFile, '-'||lsSignHex)
.head 5 -  Call SalFileClose(hFile)
.head 3 +  Function: DSig_cDocInt				! __exported
.head 4 -  Description: ! Проверить внутреннюю подпись на документе
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Number: nRef
.head 5 -  String: sTT
.head 5 -  Number: nLev         ! Уровень ЭЦП
.head 5 -  Number: nGrp         ! Код группы визирования
                     (обязательно задавать только для nLev=99)
.head 5 -  String: strSignData
.head 5 -  Receive Boolean: isSignExist ! а была ли ЭЦП в БД ?
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sSignData
.head 5 -  Long String: sBuff
.head 5 -  Number: nLen
.head 5 -  Number: nErrorSign
.head 5 -  Number: nRealSignLen
.head 5 -  String: strErrorSign
.head 5 -  String: sNd
.head 5 -  String: sNama
.head 5 -  String: sNamb
.head 5 -  String: sNazn
.head 5 -  String: sDrec
.head 5 -  String: sDat1
.head 5 -  String: sDat2
.head 5 -  Number: nVob
.head 5 -  String: szTempBuf
.head 5 -  Long String: p_lsBuffer
.head 5 -  Long String: binBuffer
.head 5 -  Long String: binBuff
.head 5 -  Number: nBuffLen
.head 5 -  String: p_KeyID
.head 5 -  Long String: p_lsSign
.head 5 -  Long String: binSign
.head 5 -  Number: p_nSignLen
.head 5 -  Number: p_nRetVal
.head 5 -  String: p_szSignType
.head 5 -  Number: nFetchRes
.head 5 -  Long String: binTempBuf
.head 5 -  Long String: lsTempBuf
.head 5 -  Number: nTmpVal
.head 5 -  Long String: ptrBuf
.head 5 -  Long String: ptrBuf2
.head 5 -  Number: hFile
.head 5 -  String: szCrtID
.head 5 -  Number: nMaxVisaLevel
.head 5 -  String: szID_O_Buf
.head 5 -  Number: min_status
.head 5 -  Number: nSignLen
.head 5 -  Number: nCertLen
.head 5 -  Number: nSignHandle
.head 5 -  Number: nCertHandle
.head 5 -  Number: fsig        ! Вид ЭЦП на визе: 0-Отсут, 1-Внутр, 2-СЭП, 3-Внутр+СЭП
.head 5 -  Long String: loc_lsSignI
.head 4 +  Actions
.head 5 -  ! Call SaveInfoToLog( 'SIGN: DSig_cDocInt():
nRef='||Str(nRef)||',sTT='||sTT||',nLev='||Str(nLev)||',nGrp='||Str(nGrp)
||',strSignData='||strSignData
)
.head 5 -  Set g_nErrorSign = -999
.head 5 -  Set g_strErrorSign = 'Статус не определен'
.head 5 +  If GetSignOn() = 0 ! ЭЦП отключена - вернуть Пусто
.head 6 -  Return TRUE
.head 5 -  ! Set g_InsertCertFlag = FALSE ! НЕ вставлять сертификат ключа в БД
.head 5 -  Set g_InsertCertFlag = TRUE ! вставлять сертификат ключа в БД
.head 5 -  ! Проверим флаг ЭЦП на визе
.head 5 +  If nLev=99 ! уровень визы не определен, проверяем по группе
.head 6 +  If NOT SqlPLSQLCommand( hSql(),"chk.visa_flag4sign(sTT,nGrp,fsig)" )
.head 7 -  Call Debug( 'Ошибка при вызове chk.visa_flag4sign()' )
.head 7 -  Set g_strErrorSign = 'Ошибка при вызове chk.visa_flag4sign()'
.head 7 -  Return FALSE
.head 5 +  Else
.head 6 +  If NOT SqlPLSQLCommand( hSql(),"chk.pvisa_flag4check(nRef,nLev,fsig)" )
.head 7 -  Call Debug( 'Ошибка при вызове chk.pvisa_flag4check()' )
.head 7 -  Set g_strErrorSign = 'Ошибка при вызове chk.pvisa_flag4check()'
.head 7 -  Return FALSE
.head 5 -  ! Call Debug( 'fsig=' || SalNumberToStrX( fsig, 0 ) )
.head 5 +  If not (fsig & DEF_INT_SIGN)
.head 6 -  ! Call Debug( 'Внутр ЭЦП проверяться НЕ БУДЕТ' )
.head 6 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП проверяться не будет. Флаг не установлен.' )
.head 6 -  Set g_strErrorSign = 'SIGN: Внутренняя ЭЦП проверяться не будет. Флаг не установлен.'
.head 6 -  Set isSignExist = FALSE
.head 6 -  Return TRUE
.head 5 +  If DSig_sIni()
.head 6 -  Set sSignData = strSignData
.head 6 -  Set nLen = SalStrLength( sSignData )
.head 6 -  ! Получить буфер для проверки
.head 6 -  ! Call Debug( 'nLev='||SalNumberToStrX( nLev, 0 ) )
.head 6 +  If NOT SqlPLSQLCommand( hSql(),"chk.get_buf_aux( nRef, nLev, sBuff, nRealSignLen )" )
.head 7 -  Call Debug( 'Ошибка при вызове chk.get_buf()' )
.head 7 -  Set g_strErrorSign = 'Ошибка при вызове chk.get_buf()'
.head 7 -  Return FALSE
.head 6 -  Set nBuffLen=SalStrLength(sBuff)/2
.head 6 -  Set nSignLen = DSig_DefaultSignSize()
.head 6 +  If nRealSignLen > 0 and nSignLen != nRealSignLen
.head 7 -  Set nSignLen = nRealSignLen
.head 6 -  ! Call Debug( 'nLev='||SalNumberToStrX( nLev, 0 ) )
.head 6 -  ! Call Debug( 'sBuff='||sBuff )
.head 6 -  ! Call Debug( 'nSignLen='||SalNumberToStrX( nSignLen, 0 ) )
.head 6 -  ! Call Debug( 'nBuffLen='||SalNumberToStrX( nBuffLen, 0 ) )
.head 6 +  If nBuffLen
.head 7 -  Call SalStrSetBufferLength( loc_lsSignI, nSignLen+1 )
.head 7 -  Set p_lsSign = SalStrMidX(sBuff,(nBuffLen-nSignLen)*2,nSignLen*2)
.head 7 -  Call ConvertHexToBin(p_lsSign, loc_lsSignI, nSignLen )  ! HEX --> BIN
.head 7 -  !
.head 7 -  Call SalStrSetBufferLength( binBuff, nBuffLen+1 )
.head 7 -  Call ConvertHexToBin(sBuff, binBuff, nBuffLen )  ! HEX --> BIN
.head 7 -  Call SalStrSetBufferLength( sSignData, nLen+nBuffLen+1 )
.head 7 -  Call ConcatBufs( sSignData, strSignData, nLen, binBuff, nBuffLen )
.head 7 -  Set isSignExist = TRUE
.head 6 +  Else
.head 7 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП проверяться не будет. Буфер пуст.' )
.head 7 -  Set isSignExist = FALSE
.head 7 -  Set g_strErrorSign = 'SIGN: Внутренняя ЭЦП проверяться не будет. Буфер пуст.'
.head 7 -  Return TRUE
.head 6 +  If GetSignType() = 'NBU'
.head 7 -  Set nErrorSign = RSA_ZAH(82,-1,1,sSignData,nLen+nBuffLen-nSignLen-6,0,
                       loc_lsSignI,
                       GetOffset(sSignData,nLen+nBuffLen-nSignLen-6))
.head 7 -  ! Игнорируем предупреждение -78
.head 7 -  ! -78 ЭЦП верна, но сделана старым ключем
.head 7 +  If nErrorSign = -78
.head 8 -  Set nErrorSign = 0
.head 6 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 7 -  Set g_sUidCheck = SalStrMidX ( GetOffset(sSignData,nLen+nBuffLen-nSignLen-6), 0, 6 )
.head 7 -  ! Call Debug( 'sSignData='||sSignData )
.head 7 -  ! Call Debug( 'nLen='||SalNumberToStrX( nLen, 0 ) )
.head 7 -  ! Call Debug( 'nBuffLen='||SalNumberToStrX( nBuffLen, 0 ) )
.head 7 -  ! Call Debug( 'nSignLen='||SalNumberToStrX( nSignLen, 0 ) )
.head 7 -  ! Call Debug( 'g_sUidCheck='||g_sUidCheck )
.head 7 -  Call SalStrSetBufferLength( strErrorSign, 254+1 )
.head 7 -  ! If CheckSign(nErrorSign,strErrorSign,254,sSignData,nLen+nBuffLen-nSignLen-6,loc_lsSignI,nSignLen,g_sUidCheck)<0
.head 6 +  Else If GetSignType() = 'PRX'
.head 7 -  Set g_sUidCheck = SalStrMidX ( GetOffset(sSignData,nLen+nBuffLen-nSignLen-6), 0, 6 )
.head 7 -  Set nErrorSign = PRX_RSA_ZAH(114,-1,1,sSignData,nLen+nBuffLen-nSignLen-6,0,
                       loc_lsSignI,
                       g_sUidCheck)
.head 6 +  Else If GetSignType() = 'VEG'
.head 7 -  Call SalStrSetBufferLength(g_sUidCheck,9)
.head 7 -  Set nErrorSign = VegaCheck(loc_lsSignI,sSignData,nLen+nBuffLen-nSignLen-6,0,g_sUidCheck,0,0,0)
.head 6 +  Else If GetSignType() = 'UNI'
.head 7 -  ! Тут много геморроя с новой ЭЦП НБУ :(
.head 7 -  ! Call SalStrSetBufferLength( m_lsSign, UNI_SIGN_SIZE+1 )
.head 7 -  Call SalStrSetBufferLength( g_lsCertificate, UNI_CERT_SIZE+1 )
.head 7 -  ! Извлекаем ID откр. ключа
.head 7 -  Set szCrtID = SalStrMidX( p_lsSign, 14, 18 )
.head 7 -  Call SqlSetLongBindDatatype( 1, BLOB_BYTE )
.head 7 +  If NOT SqlPrepareAndExecute( hSql(), "select key into :g_lsCertificate from keys where key_id=:szCrtID" )
.head 8 -  Set g_strErrorSign = 'Ошибка при выполнении select key from keys'
.head 8 +  If not g_hideErrorMsg
.head 9 -  Call SalMessageBox( 'Ошибка при выполнении select key from keys', 'Error',
MB_Ok|MB_IconStop )
.head 8 -  Return FALSE
.head 7 -  Call SqlFetchNext( hSql(), nFetchRes )
.head 7 +  If FETCH_Ok = nFetchRes
.head 8 -  Set nCertLen = UNI_CERT_SIZE
.head 8 -  ! Call Debug('Работаем с сертификатом')
.head 7 +  Else
.head 8 -  Set nCertLen = NUMBER_Null
.head 8 -  Set g_lsCertificate = STRING_Null
.head 8 -  ! Call Debug('Работаем с диском')
.head 8 -  ! Set g_strErrorSign = 'Не найден открытый ключ [' || szCrtID || ']'
.head 8 +  ! If not g_hideErrorMsg
.head 9 -  Call SalMessageBox( 'Не найден открытый ключ [' || szCrtID || ']', 'Error',
MB_Ok|MB_IconStop )
.head 8 -  ! Set nErrorSign = 3301
.head 8 -  ! Return FALSE
.head 7 -  ! Проверяем подпись
.head 7 -  Set nErrorSign = NG_VERIFY_SIGN_CRED( min_status,
			g_nCredHandle,
			nLen+nBuffLen-nSignLen-6, sSignData,
			UNI_SIGN_SIZE, loc_lsSignI,
			nCertLen, g_lsCertificate)
.head 6 +  ! Else If GetSignType() = 'SSF'
.head 7 -  Set nErrorSign = F_SsfVerify(sSignData, nLen+nBuffLen-nSignLen-6, loc_lsSignI, nSignLen, GetIdOper()) 
.head 6 +  Else If GetSignType() = 'UKR'
.head 7 -  Call SalMessageBox( 'Проверка ЭЦП "UKR" не реализована', 'Ошибка', MB_Ok | MB_IconStop )
.head 6 -  Call DSig_sTrace(sSignData, nLen+nBuffLen-nSignLen-6, loc_lsSignI)
.head 6 +  If nErrorSign = 0
.head 7 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП верна. Ref='||Str(nRef))
.head 7 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП верна. Ref='||Str(nRef)||PutCrLf()
||'Буфер:'||PutCrLf()
||'"'||strSignData||'"'||PutCrLf()
||'Доп. буфер:'||PutCrLf()
||sBuff||PutCrLf()
||'ЭЦП:'||PutCrLf()
||p_lsSign||PutCrLf()
 )
.head 7 -  Set g_nErrorSign = nErrorSign
.head 7 -  Set g_strErrorSign = 'ЭЦП верна'
.head 7 -  Return TRUE
.head 6 +  Else
.head 7 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП не верна. Ref='||Str(nRef)||' Ошибка '||SalNumberToStrX(nErrorSign,0))
.head 7 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП не верна. Ref='||Str(nRef)||PutCrLf()
||'Буфер:'||PutCrLf()
||'"'||strSignData||'"'||PutCrLf()
||'Доп. буфер:'||PutCrLf()
||sBuff||PutCrLf()
||'ЭЦП:'||PutCrLf()
||p_lsSign||PutCrLf()
 )
.head 7 +  If GetSignType() = 'NBU'
.head 8 -  Set strErrorSign = 'Ошибка снятия ЭЦП НБУ: '
|| NumberToStr(nErrorSign)
|| PutCrLf()||'Ключ='||GetIdOper()||PutCrLf()||DSig_GetSepSignMsg(nErrorSign)
.head 8 +  If not g_hideErrorMsg
.head 9 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 8 -  Set strErrorSign = 'Помилка перевірки підпису '||GetSignType()||': '|| PutCrLf()||
'Ключ='||GetIdOper()||PutCrLf()||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'PRX'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call PRX_ERR_MSG(nErrorSign, strErrorSign, 4095)
.head 8 -  Set strErrorSign = 'Ключ '||GetIdOper()||'.'||PutCrLf()||strErrorSign
.head 8 +  If not g_hideErrorMsg
.head 9 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'VEG'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call VegaGetMsgAux(nErrorSign, strErrorSign, 4096)
.head 8 -  ! Предупреждения обрабатываем отдельно
.head 8 +  If nErrorSign < 32
.head 9 +  If not g_hideErrorMsg
.head 10 -  Call MessageWarning(strErrorSign)
.head 9 -  Set nErrorSign = 0
.head 9 -  Set g_nErrorSign = nErrorSign
.head 9 -  Set g_strErrorSign = strErrorSign
.head 9 -  Return TRUE
.head 8 +  Else
.head 9 +  If not g_hideErrorMsg
.head 10 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'UNI'
.head 8 -  Set strErrorSign = DSig_UNIFormatGSSMessage(min_status, nErrorSign)
.head 8 +  If not g_hideErrorMsg
.head 9 -  Call MessageErrorEx( strErrorSign )
.head 7 +  ! Else If GetSignType() = 'SSF'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call F_SsfGetErrMsg(nErrorSign, strErrorSign, 4096)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'UKR'
.head 8 -  Call nsignMapError2Text(strErrorSign,nErrorSign)
.head 8 -  Call nsignExitOPSign()
.head 8 +  If not g_hideErrorMsg
.head 9 -  Call MessageErrorEx(StrDosToWinX(strErrorSign))
.head 5 -  Set g_nErrorSign = nErrorSign
.head 5 -  Set g_strErrorSign = strErrorSign
.head 5 -  Return FALSE
.head 3 +  Function: DSig_CheckDocSign   			! __exported
.head 4 -  Description: ! Проверить ЭЦП на документ
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Number: nRef   ! Референс документа
.head 5 -  String: szMode ! Режим работы 'CUR' - проверить текущую ЭЦП (nVisaLevel=max)
                              'LVL' - проверить ЭЦП уровня nVisaLevel
.head 5 -  Number: nVisaLevel ! Уровень ЭЦП
.head 5 -  String: pOperId ! ID ключа операциониста
.head 5 -  Long String: pSignData ! Буфер СЭП для проверки ЭЦП
.head 5 -  Receive Number: pnSignErrType  ! Тип ошибки при проверке подписи (1 - док., 2 - виза)
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Long String: sSignData
.head 5 -  Number: nErrorSign
.head 5 -  String: strErrorSign
.head 5 -  String: sNd
.head 5 -  String: sNama
.head 5 -  String: sNamb
.head 5 -  String: sNazn
.head 5 -  String: sDrec
.head 5 -  String: sDat1
.head 5 -  String: sDat2
.head 5 -  Number: nVob
.head 5 -  String: szTempBuf
.head 5 -  Long String: p_lsBuffer
.head 5 -  Long String: binBuffer
.head 5 -  Number: p_nBufferLen
.head 5 -  String: p_KeyID
.head 5 -  Long String: p_lsSign
.head 5 -  Long String: binSign
.head 5 -  Number: p_nSignLen
.head 5 -  Number: p_nRetVal
.head 5 -  String: p_szSignType
.head 5 -  Number: nFetchRes
.head 5 -  Long String: binTempBuf
.head 5 -  Long String: lsTempBuf
.head 5 -  Number: nTmpVal
.head 5 -  Long String: ptrBuf
.head 5 -  Long String: ptrBuf2
.head 5 -  Number: hFile
.head 5 -  String: szCrtID
.head 5 -  Number: nMaxVisaLevel
.head 5 -  String: szID_O_Buf
.head 5 -  Number: min_status
.head 5 -  Number: nSignLen
.head 5 -  Number: nCertLen
.head 5 -  Number: nSignHandle
.head 5 -  Number: nCertHandle
.head 4 +  Actions
.head 5 +  If GetSignOn() = 0 ! ЭЦП отключена - вернуть Пусто
.head 6 -  Return TRUE
.head 5 -  ! Set g_InsertCertFlag = FALSE ! НЕ вставлять сертификат ключа в БД
.head 5 -  Set g_InsertCertFlag = TRUE ! вставлять сертификат ключа в БД
.head 5 +  If DSig_sIni()
.head 6 -  ! Определяемся с уровнем визы
.head 6 +  If nRef=-1 ! референс не задан
.head 7 -  Set nMaxVisaLevel=0
.head 6 +  Else
.head 7 +  If NOT SqlPrepareAndExecute( hSql(),
"select nvl(length(rtrim(chk))/6,0) from oper where ref=:nRef into :nMaxVisaLevel" )
.head 8 -  Call SalMessageBox( 'Не могу получить MAX уровень визы', 'Ошибка', MB_Ok | MB_IconStop )
.head 8 -  Return FALSE
.head 7 -  Call SqlFetchNext( hSql(), nFetchRes )
.head 7 +  If FETCH_Ok != nFetchRes
.head 8 -  Call SalMessageBox( 'Не могу получить MAX уровень визы', 'Ошибка', MB_Ok | MB_IconStop )
.head 8 -  Return FALSE
.head 6 +  If nMaxVisaLevel>0
.head 7 -  Set pnSignErrType = 2
.head 6 +  Else
.head 7 -  Set pnSignErrType = 1
.head 6 -  ! -----------------------------
.head 6 -  Set nTmpVal = SalStrLength( pSignData )
.head 6 -  Set sSignData = pSignData
.head 6 -  ! Здесь должен быть вызов Денисовой процедуры
+ конкатенация полученного буфера с sSignData
.head 6 -  Set p_szSignType = GetSignType()
.head 6 -  Call SalStrSetBufferLength( binBuffer, 8*1024 )
.head 6 -  Call SalStrSetBufferLength( binSign, 8*1024)
.head 6 +  If nRef=-1 ! референс не задан
.head 7 -  ! выставляем параметры по-умолчанию
.head 7 -  ! Set p_nBufferLen = 0
.head 7 -  ! Set p_KeyID = pOperId
.head 7 -  ! Set p_nSignLen = DSig_DefaultSignSize()
.head 7 -  ! Call memmove( binSign, m_lsSign, p_nSignLen )
.head 7 -  Call Debug(' Референс не задан. Может ошибка?')
.head 7 -  Return FALSE
.head 6 +  Else
.head 7 +  If NOT SqlPLSQLCommand( hSql(),
"GetVisaSignAttribute(
  p_nRetVal, nRef, szMode, nVisaLevel,
  p_szSignType, p_lsBuffer, p_nBufferLen, p_KeyID, p_lsSign, p_nSignLen)" )
.head 8 -  Call Debug( 'Ошибка выполнения GetVisaSignAttribute()' )
.head 8 -  Return FALSE
.head 7 +  If p_nSignLen=NUMBER_Null OR p_nSignLen=0 ! ==> нечего проверять
.head 8 -  Call SalMessageBox( 'ЭЦП отсутствует', 'Ошибка', MB_Ok | MB_IconStop )
.head 8 -  Set nErrorSign = 3301
.head 8 -  Return FALSE
.head 7 -  ! Call Debug( 'GetVisaSignAttribute: p_lsBuffer='||p_lsBuffer )
.head 7 -  ! Call Debug( 'GetVisaSignAttribute: p_nBufferLen='||SalNumberToStrX(p_nBufferLen,0) )
.head 7 -  ! Call Debug( 'GetVisaSignAttribute: p_KeyID='||p_KeyID )
.head 7 -  ! Call Debug( 'GetVisaSignAttribute: p_lsSign='||p_lsSign )
.head 7 -  ! Call Debug( 'GetVisaSignAttribute: p_nSignLen='||SalNumberToStrX( p_nSignLen,0 ) )
.head 7 -  ! Преобразование HEX --> BIN
.head 7 -  Set ptrBuf  = p_lsBuffer
.head 7 -  Set ptrBuf2 = binBuffer
.head 7 -  Call ConvertHexToBin( ptrBuf, ptrBuf2, p_nBufferLen )
.head 7 -  Set ptrBuf = p_lsSign
.head 7 -  Set ptrBuf2 = binSign
.head 7 -  Call ConvertHexToBin( p_lsSign, binSign, p_nSignLen )
.head 6 -  ! Set hFile = _sopen( GetPrnDir() || '\\' || 'binBuf.DAT', 0x00008302, 0x00000010, 0x00000180)
.head 6 +  ! If hFile != -1
.head 7 -  Call _write( hFile, binBuffer, p_nBufferLen )
.head 7 -  Call _close( hFile )
.head 6 -  Set hFile = _sopen( GetPrnDir() || '\\' || 'binSign.DAT', 0x00008302, 0x00000010, 0x00000180)
.head 6 +  If hFile != -1
.head 7 -  Call _write( hFile, binSign, p_nSignLen )
.head 7 -  Call _close( hFile )
.head 6 -  ! ------------------------
.head 6 -  Set hFile = _sopen( GetPrnDir() || '\\' || 'signdata.dat', 0x00008302, 0x00000010, 0x00000180)
.head 6 +  If hFile != -1
.head 7 -  Call _write( hFile, sSignData, nTmpVal )
.head 7 -  Call _close( hFile )
.head 6 +  If 0 = strncmp( binSign, 'AUTOTRANSACTION', 15 )
.head 7 -  Return TRUE
.head 6 +  If p_nBufferLen > 0
.head 7 -  Set pnSignErrType = 2
.head 7 -  ! Конкатенация бинарных буферов
.head 7 -  Set binTempBuf = SalStrRepeatX( ' ', 9*1024 )
.head 7 -  Set lsTempBuf =  SalStrRepeatX( ' ', 9*1024 )
.head 7 -  Set lsTempBuf = sSignData
.head 7 -  Set sSignData =  SalStrRepeatX( ' ', 64*1024 )
.head 7 -  Call ConcatBufs( sSignData, lsTempBuf, nTmpVal, binBuffer, p_nBufferLen )
.head 7 -  ! -------------------------------
.head 7 -  Set hFile = _sopen( GetPrnDir() || '\\' || 'SIGNTRAB.DAT', 0x00008302, 0x00000010, 0x00000180)
.head 7 +  If hFile != -1
.head 8 -  Call _write( hFile, sSignData, nTmpVal+p_nBufferLen )
.head 8 -  Call _close( hFile )
.head 6 -  ! ----------------------------
.head 6 +  If GetSignType() = 'NBU'
.head 7 -  Set nErrorSign = RSA_ZAH(82,-1,1,sSignData,nTmpVal+p_nBufferLen,0,binSign,p_KeyID)
.head 6 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 7 -  Call SalStrSetBufferLength( strErrorSign, 255 )
.head 7 -  ! If CheckSign(nErrorSign,strErrorSign,254,sSignData,nTmpVal+p_nBufferLen,binSign,p_nSignLen,p_KeyID)<0
.head 6 +  Else If GetSignType() = 'PRX'
.head 7 -  Set nErrorSign = PRX_RSA_ZAH(114,-1,1,sSignData,nTmpVal+p_nBufferLen,
0,binSign,p_KeyID)
.head 6 +  Else If GetSignType() = 'VEG'
.head 7 -  ! Call SalStrSetBufferLength( m_lsSign, 91 )
.head 7 -  Call SalStrSetBufferLength(g_sUidCheck,9)
.head 7 -  Set nErrorSign = VegaCheck(binSign,sSignData,
nTmpVal+p_nBufferLen,0,g_sUidCheck,0,0,0)
.head 6 +  Else If GetSignType() = 'UNI'
.head 7 -  ! Тут много геморроя с новой ЭЦП НБУ :(
.head 7 -  ! Call SalStrSetBufferLength( m_lsSign, UNI_SIGN_SIZE+1 )
.head 7 -  Call SalStrSetBufferLength( g_lsCertificate, UNI_CERT_SIZE+1 )
.head 7 -  ! Извлекаем ID откр. ключа
.head 7 -  Set szCrtID = SalStrMidX( p_lsSign, 14, 18 )
.head 7 -  Call SqlSetLongBindDatatype( 1, BLOB_BYTE )
.head 7 +  If NOT SqlPrepareAndExecute( hSql(), "select key into :g_lsCertificate from keys where key_id=:szCrtID" )
.head 8 -  Call SalMessageBox( 'Ошибка при выполнении select key from keys', 'Error',
MB_Ok|MB_IconStop )
.head 8 -  Return FALSE
.head 7 -  Call SqlFetchNext( hSql(), nFetchRes )
.head 7 +  If FETCH_Ok = nFetchRes
.head 8 -  Set nCertLen = UNI_CERT_SIZE
.head 7 +  Else
.head 8 -  Set nCertLen = NUMBER_Null
.head 8 -  Set g_lsCertificate = STRING_Null
.head 8 -  ! Call SalMessageBox( 'Не найден открытый ключ [' || szCrtID || ']', 'Error',
MB_Ok|MB_IconStop )
.head 8 -  ! Set nErrorSign = 3301
.head 8 -  ! Return FALSE
.head 7 -  ! Проверяем подпись
.head 7 -  Set nErrorSign = NG_VERIFY_SIGN_CRED( min_status,
			g_nCredHandle,
			nTmpVal+p_nBufferLen, sSignData,
			UNI_SIGN_SIZE, binSign,
			nCertLen, g_lsCertificate)
.head 6 +  ! Else If GetSignType() = 'SSF'
.head 7 -  ! Проверяем подпись
.head 7 -  Set nErrorSign = F_SsfVerify(sSignData, nTmpVal+p_nBufferLen, binSign, p_nSignLen, GetIdOper()) 
.head 6 +  Else If GetSignType() = 'UKR'
.head 7 -  Call SalMessageBox( 'Проверка ЭЦП "UKR" не реализована', 'Ошибка',
MB_Ok | MB_IconStop )
.head 7 -  ! Call SalStrSetBufferLength( m_lsSign, 129 )
.head 7 -  ! Set nErrorSign = nsignPutOPSignOnMemory(sSignData,444,m_lsSign)
.head 6 -  Call DSig_sTrace(sSignData, nTmpVal+p_nBufferLen, binSign)
.head 6 +  If nErrorSign = 0
.head 7 -  Call SaveFInfoToLog( 'SIGN: ЭЦП СЭП верна.'||PutCrLf()
||'Буфер:'||PutCrLf()
||'"'||pSignData||'"'||PutCrLf()
||'Доп. буфер:'||PutCrLf()
||p_lsBuffer||PutCrLf()
||'ЭЦП:'||PutCrLf()
||p_lsSign||PutCrLf()
 )
.head 7 -  Return TRUE
.head 6 +  Else
.head 7 +  If GetSignType() = 'NBU'
.head 8 -  Set strErrorSign = 'Ошибка снятия ЭЦП НБУ: '
|| NumberToStr(nErrorSign)
|| PutCrLf()||'Ключ='||GetIdOper()||PutCrLf()||DSig_GetSepSignMsg(nErrorSign)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 8 -  Set strErrorSign = 'Помилка перевірки підпису '||GetSignType()||': '|| PutCrLf()||
'Ключ='||GetIdOper()||PutCrLf()||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'PRX'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call PRX_ERR_MSG(nErrorSign, strErrorSign, 4095)
.head 8 -  Set strErrorSign = 'Ключ '||GetIdOper()||'.'||PutCrLf()||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'VEG'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call VegaGetMsgAux(nErrorSign, strErrorSign, 4096)
.head 8 -  ! Предупреждения обрабатываем отдельно
.head 8 +  If nErrorSign < 32
.head 9 -  Call MessageWarning(strErrorSign)
.head 9 -  Set nErrorSign = 0
.head 9 -  Return TRUE
.head 8 +  Else
.head 9 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'UNI'
.head 8 -  ! Set szTempBuf = SalStrRepeatX(' ', 256)
.head 8 -  ! Call NBUFormatMessage( nErrorSign, szTempBuf, 256)
.head 8 -  ! Set strErrorSign = 'Ошибка снятия ЭЦП UNI: '||SalNumberToStrX( nErrorSign, 0)
  || PutCrLf()||'Ключ='||GetIdOper()||PutCrLf()||szTempBuf
.head 8 -  ! Call MessageErrorEx(strErrorSign)
.head 8 -  ! ---------------------------------
.head 8 -  Call MessageErrorEx( DSig_UNIFormatGSSMessage(min_status, nErrorSign) )
.head 7 +  ! Else If GetSignType() = 'SSF'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call F_SsfGetErrMsg(nErrorSign, strErrorSign, 4096)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'UKR'
.head 8 -  Call nsignMapError2Text(strErrorSign,nErrorSign)
.head 8 -  Call nsignExitOPSign()
.head 8 -  Call MessageErrorEx(StrDosToWinX(strErrorSign))
.head 5 -  Return FALSE
.head 3 +  Function: DSig_sDocVisa   			! __exported
.head 4 -  Description: ! Подписать документ при  визировании
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Number: nRef
.head 5 -  String: pSignData
.head 5 -  Receive String: psKey
.head 5 -  Receive Long String: plsSignHex
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Long String: sSignData
.head 5 -  Number: nErrorSign
.head 5 -  String: strErrorSign
.head 5 -  String: sNd
.head 5 -  String: sNama
.head 5 -  String: sNamb
.head 5 -  String: sNazn
.head 5 -  String: sDrec
.head 5 -  String: sDat1
.head 5 -  String: sDat2
.head 5 -  Number: nVob
.head 5 -  String: szTempBuf
.head 5 -  Long String: p_lsBuffer
.head 5 -  Long String: binBuffer
.head 5 -  Number: p_nBufferLen
.head 5 -  String: p_KeyID
.head 5 -  Long String: p_lsSign
.head 5 -  Long String: binSign
.head 5 -  Number: p_nSignLen
.head 5 -  Number: p_nRetVal
.head 5 -  String: p_szSignType
.head 5 -  Number: nFetchRes
.head 5 -  Long String: binTempBuf
.head 5 -  Long String: lsTempBuf
.head 5 -  Number: nTmpVal
.head 5 -  Long String: ptrBuf
.head 5 -  Long String: ptrBuf2
.head 5 -  Number: hFile
.head 5 -  String: szCrtID
.head 5 -  String: szID_O_Buf
.head 5 -  Number: min_status
.head 5 -  Number: nSignLen
.head 5 -  Number: nCertLen
.head 5 -  Number: nSignHandle
.head 5 -  Number: nCertHandle
.head 5 -  Number: nSignErrType ! Тип ошибки при проверке подписи (1 - док., 2 - виза)
.head 5 -  Long String: loc_lsSign
.head 4 +  Actions
.head 5 +  If GetSignOn() = 0 ! ЭЦП отключена - вернуть Пусто
.head 6 -  Set plsSignHex = STRING_Null
.head 6 -  Return TRUE
.head 5 -  Set g_InsertCertFlag = TRUE ! вставлять сертификат ключа в БД
.head 5 +  If DSig_sIni()
.head 6 -  Set sSignData = pSignData
.head 6 -  Set nTmpVal = SalStrLength( sSignData )
.head 6 -  ! Здесь должен быть вызов Денисовой процедуры
+ конкатенация полученного буфера с sSignData
.head 6 -  Set p_szSignType = GetSignType()
.head 6 +  If NOT SqlPLSQLCommand( hSql(),
"GetVisaSignAttribute(
  p_nRetVal, nRef, 'NEW', 0,
  p_szSignType, p_lsBuffer, p_nBufferLen, p_KeyID, p_lsSign, p_nSignLen)" )
.head 7 -  Call Debug( 'Ошибка!' )
.head 7 -  Return FALSE
.head 6 -  ! Преобразование HEX --> BIN
.head 6 -  Set binBuffer = SalStrRepeatX( '\0', 8*1024 )
.head 6 -  Set binSign   = SalStrRepeatX( '\0', 1024 )
.head 6 -  Set ptrBuf  = p_lsBuffer
.head 6 -  Set ptrBuf2 = binBuffer
.head 6 -  Call ConvertHexToBin( ptrBuf, ptrBuf2, p_nBufferLen )
.head 6 -  Set ptrBuf = p_lsSign
.head 6 -  Set ptrBuf2 = binSign
.head 6 -  Call ConvertHexToBin( p_lsSign, binSign, p_nSignLen )
.head 6 -  ! Set hFile = _sopen( GetPrnDir() || '\\' || 'binBuf.DAT', 0x00008302, 0x00000010, 0x00000180)
.head 6 +  ! If hFile != -1
.head 7 -  Call _write( hFile, binBuffer, p_nBufferLen )
.head 7 -  Call _close( hFile )
.head 6 +  If p_nBufferLen > 0
.head 7 -  Set nSignErrType = 2
.head 7 -  ! Конкатенация бинарных буферов
.head 7 -  Set binTempBuf = SalStrRepeatX( ' ', 9*1024 )
.head 7 -  Set lsTempBuf =  SalStrRepeatX( ' ', 9*1024 )
.head 7 -  Set lsTempBuf = sSignData
.head 7 -  Set sSignData =  SalStrRepeatX( ' ', 64*1024 )
.head 7 -  Call ConcatBufs( sSignData, lsTempBuf, nTmpVal, binBuffer, p_nBufferLen )
.head 7 -  ! Set hFile = _sopen( GetPrnDir() || '\\' || 'SIGNTRAB.DAT', 0x00008302, 0x00000010, 0x00000180)
.head 7 +  ! If hFile != -1
.head 8 -  Call _write( hFile, sSignData, nTmpVal+p_nBufferLen )
.head 8 -  Call _close( hFile )
.head 6 -  Set p_nSignLen = DSig_DefaultSignSize()
.head 6 -  Set psKey = GetIdOper()
.head 6 +  If GetSignType() = 'NBU'
.head 7 -  Call SalStrSetBufferLength( loc_lsSign, NBU_SIGN_SIZE+1 )
.head 7 -  Set nErrorSign = RSA_ZAH(87,-1,1,
    sSignData,nTmpVal+p_nBufferLen,
    0,loc_lsSign,GetIdOper())
.head 6 +  Else If GetSignType() = 'PRX'
.head 7 -  Call SalStrSetBufferLength( loc_lsSign, NBU_SIGN_SIZE+1 )
.head 7 -  Set nErrorSign = PRX_RSA_ZAH(119,-1,1,
    sSignData,nTmpVal+p_nBufferLen,
    0,loc_lsSign,'')
.head 6 +  Else If GetSignType() = 'VEG'
.head 7 -  Call SalStrSetBufferLength( loc_lsSign, VEG_SIGN_SIZE+1 )
.head 7 -  Set nErrorSign = VegaEnsign(loc_lsSign,sSignData,
    nTmpVal+p_nBufferLen,0,g_sUid,0,0)
.head 6 +  Else If GetSignType() = 'UNI'
.head 7 -  ! --------------------------------
.head 7 -  Call SalStrSetBufferLength( loc_lsSign, UNI_SIGN_SIZE+1 )
.head 7 -  Call SalStrSetBufferLength( g_lsCertificate, UNI_CERT_SIZE+1 )
.head 7 -  Set nErrorSign = NG_CREATE_SIGN_CRED( min_status,
			g_nCredHandle,
			nTmpVal+p_nBufferLen, sSignData,
			nSignLen, nSignHandle,
			nCertLen, nCertHandle)
.head 7 +  If 0=nErrorSign
.head 8 -  Call ConvertHexToBin( NumPtr2HexStr(nSignHandle, nSignLen),
	loc_lsSign, nSignLen )
.head 8 -  Call ConvertHexToBin( NumPtr2HexStr(nCertHandle, nCertLen),
	g_lsCertificate, nCertLen )
.head 8 -  ! чистим память
.head 8 -  Call gss_release_buffer( min_status, nSignLen, nSignHandle )
.head 8 -  Call gss_release_buffer( min_status, nCertLen, nCertHandle )
.head 7 -  ! Set hFile = _sopen( GetPrnDir() || '\\' || 'VisaSign.dat', 0x00008302, 0x00000010, 0x00000180)
.head 7 +  ! If hFile != -1
.head 8 -  Call _write( hFile, m_lsSign, 88 )
.head 8 -  Call _close( hFile )
.head 6 +  ! Else If GetSignType() = 'SSF'
.head 7 -  Call SalStrSetBufferLength( loc_lsSign, p_nSignLen+1 )
.head 7 -  Set nErrorSign = F_SsfSign(sSignData,nTmpVal+p_nBufferLen, loc_lsSign, p_nSignLen, GetIdOper())
.head 6 +  Else
.head 7 -  Call SalMessageBox( 'Наложение ЭЦП "UKR" не реализована', 'Ошибка',
MB_Ok | MB_IconStop )
.head 7 -  ! Call SalStrSetBufferLength( m_lsSign, 129 )
.head 7 -  ! Set nErrorSign = nsignPutOPSignOnMemory(sSignData,444,m_lsSign)
.head 6 +  If nErrorSign = 0
.head 7 -  Call DSig_sTrace(sSignData, nTmpVal+p_nBufferLen, loc_lsSign)
.head 7 -  Call SalStrSetBufferLength( plsSignHex, 2*p_nSignLen+1 )
.head 7 -  Call ConvertBinToHex( loc_lsSign, plsSignHex, p_nSignLen )
.head 7 -  Return TRUE
.head 6 +  Else
.head 7 +  If GetSignType() = 'NBU'
.head 8 -  Set strErrorSign = 'Ошибка наложения ЭЦП НБУ: '
|| NumberToStr(nErrorSign)
|| PutCrLf()||'Ключ='||GetIdOper()||PutCrLf()||DSig_GetSepSignMsg(nErrorSign)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'PRX'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call PRX_ERR_MSG(nErrorSign, strErrorSign, 4095)
.head 8 -  Set strErrorSign = 'Ключ '||GetIdOper()||'.'||PutCrLf()||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'VEG'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call VegaGetMsgAux(nErrorSign, strErrorSign, 4096)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'UNI'
.head 8 -  ! Set szTempBuf = SalStrRepeatX(' ', 256)
.head 8 -  ! Call NBUFormatMessage( nErrorSign, szTempBuf, 256)
.head 8 -  ! Set strErrorSign = 'Ошибка наложения ЭЦП UNI: '||SalNumberToStrX( nErrorSign, 0)
  || PutCrLf()||'KeyID='||GetIdOper()||PutCrLf()||szTempBuf
.head 8 -  ! Call MessageErrorEx(strErrorSign)
.head 8 -  ! ----------------------------
.head 8 -  Call MessageErrorEx( DSig_UNIFormatGSSMessage(min_status, nErrorSign) )
.head 7 +  ! Else If GetSignType() = 'SSF'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call F_SsfGetErrMsg(nErrorSign, strErrorSign, 4096)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else ! обработка ошибок ЭЦП
.head 8 -  Call nsignMapError2Text(strErrorSign,nErrorSign)
.head 8 -  Call nsignExitOPSign()
.head 8 -  Call MessageErrorEx(StrDosToWinX(strErrorSign))
.head 5 -  Return FALSE
.head 3 +  Function: DSig_sDocInt				! __exported
.head 4 -  Description: ! Подписать внутренней подписью (при визировании и вводе)
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Number: nRef
.head 5 -  String: sTT
.head 5 -  Number: nLev
.head 5 -  Number: nGrp         ! Код группы визирования
                     (обязательно задавать только для nLev=99)
.head 5 -  String: strSignData
.head 5 -  Receive String: psKey
.head 5 -  Receive Long String: plsSignIntHex
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sSignType
.head 5 -  Long String: sSignData
.head 5 -  Long String: sBuff
.head 5 -  Number: nErrorSign
.head 5 -  String: strErrorSign
.head 5 -  String: szTempBuf
.head 5 -  Long String: p_lsBuffer
.head 5 -  Long String: binBuff
.head 5 -  Number: nBuffLen
.head 5 -  String: p_KeyID
.head 5 -  Long String: p_lsSign
.head 5 -  Long String: binSign
.head 5 -  Number: p_nSignLen
.head 5 -  Number: nLen
.head 5 -  Number: nFetchRes
.head 5 -  Long String: binTempBuf
.head 5 -  Long String: lsTempBuf
.head 5 -  Number: nTmpVal
.head 5 -  Long String: ptrBuf
.head 5 -  Long String: ptrBuf2
.head 5 -  Number: hFile
.head 5 -  String: szCrtID
.head 5 -  String: szID_O_Buf
.head 5 -  Number: min_status
.head 5 -  Number: nSignLen
.head 5 -  Number: nCertLen
.head 5 -  Number: nSignHandle
.head 5 -  Number: nCertHandle
.head 5 -  Number: fsig        ! Вид ЭЦП на визе: 0-Отсут, 1-Внутр, 2-СЭП, 3-Внутр+СЭП
.head 5 -  Long String: lsSignInt
.head 5 -  Number: loc_nSignLen
.head 4 +  Actions
.head 5 -  ! Call Debug( 'Call sDocInt()' )
.head 5 -  ! Call SaveInfoToLog( 'SIGN: DSig_sDocInt():
nRef='||Str(nRef)||',sTT='||sTT||',nLev='||Str(nLev)||',nGrp='||Str(nGrp)
||',strSignData='||strSignData
)
.head 5 +  If GetSignOn() = 0 ! ЭЦП отключена - вернуть Пусто
.head 6 -  Return TRUE
.head 5 -  Set g_InsertCertFlag = TRUE ! вставлять сертификат ключа в БД
.head 5 +  If NOT SqlPLSQLCommand( hSql(),"chk.visa_flag4sign(sTT,nGrp,fsig)" )
.head 6 -  Call Debug( 'Ошибка!' )
.head 6 -  Return FALSE
.head 5 -  ! Call Debug( 'fsig=' || SalNumberToStrX( fsig, 0 ) )
.head 5 +  If not (fsig & DEF_INT_SIGN)
.head 6 -  ! Call Debug( 'Внутр ЭЦП накладываться НЕ БУДЕТ' )
.head 6 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП накладываться не будет. Флаг не установлен.' )
.head 6 -  Return TRUE
.head 5 +  If DSig_sIni()
.head 6 -  Set sSignData = strSignData
.head 6 -  Set nLen = SalStrLength( sSignData )
.head 6 -  ! Получить буфер для подписывания
.head 6 +  If NOT SqlPLSQLCommand( hSql(),"chk.get_buf( nRef, nLev, sBuff )" )
.head 7 -  Call Debug( 'Ошибка!' )
.head 7 -  Return FALSE
.head 6 -  Set nBuffLen=SalStrLength(sBuff)/2
.head 6 +  If nBuffLen
.head 7 -  Call SalStrSetBufferLength( binBuff, nBuffLen+1 )
.head 7 -  Call ConvertHexToBin(sBuff, binBuff, nBuffLen )  ! HEX --> BIN
.head 7 -  Call SalStrSetBufferLength( sSignData, nLen+nBuffLen+1 )
.head 7 -  Call ConcatBufs( sSignData, strSignData, nLen, binBuff, nBuffLen )
.head 6 -  Set loc_nSignLen = DSig_DefaultSignSize()
.head 6 -  Set psKey = GetIdOper()
.head 6 +  If GetSignType() = 'NBU'
.head 7 -  Call SalStrSetBufferLength( lsSignInt, loc_nSignLen+1 )
.head 7 -  Set nErrorSign = RSA_ZAH(87,-1,1,sSignData,nLen+nBuffLen,0,lsSignInt,GetIdOper())
.head 6 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 7 -  Call SalStrSetBufferLength ( strErrorSign, 254+1 )
.head 7 -  Call SalStrSetBufferLength( lsSignInt, loc_nSignLen+1 )
.head 7 +  ! If PutSign(nErrorSign,strErrorSign,254,sSignData,nLen+nBuffLen,lsSignInt,DSig_DefaultSignSize())<0
.head 8 -  Call Debug(strErrorSign)
.head 6 +  Else If GetSignType() = 'PRX'
.head 7 -  Call SalStrSetBufferLength( lsSignInt, loc_nSignLen+1 )
.head 7 -  Set nErrorSign = PRX_RSA_ZAH(119,-1,1,sSignData,nLen+nBuffLen,0,lsSignInt,'')
.head 6 +  Else If GetSignType() = 'VEG'
.head 7 -  Call SalStrSetBufferLength( lsSignInt, loc_nSignLen+1 )
.head 7 -  Set nErrorSign = VegaEnsign(lsSignInt,sSignData,nLen+nBuffLen,0,g_sUid,0,0)
.head 6 +  Else If GetSignType() = 'UNI'
.head 7 -  Call SalStrSetBufferLength( lsSignInt, loc_nSignLen+1 )
.head 7 -  Call SalStrSetBufferLength( g_lsCertificate, UNI_CERT_SIZE+1 )
.head 7 -  Set nErrorSign = NG_CREATE_SIGN_CRED( min_status,
			g_nCredHandle,
			nLen+nBuffLen, sSignData,
			nSignLen, nSignHandle,
			nCertLen, nCertHandle)
.head 7 +  If 0=nErrorSign
.head 8 -  Call ConvertHexToBin( NumPtr2HexStr(nSignHandle, nSignLen), lsSignInt, nSignLen )
.head 8 -  Call ConvertHexToBin( NumPtr2HexStr(nCertHandle, nCertLen), g_lsCertificate, nCertLen )
.head 8 -  ! чистим память
.head 8 -  Call gss_release_buffer( min_status, nSignLen, nSignHandle )
.head 8 -  Call gss_release_buffer( min_status, nCertLen, nCertHandle )
.head 7 -  ! Set hFile = _sopen( GetPrnDir() || '\\' || 'VisaSign.dat', 0x00008302, 0x00000010, 0x00000180)
.head 7 +  ! If hFile != -1
.head 8 -  Call _write( hFile, m_lsSign, 88 )
.head 8 -  Call _close( hFile )
.head 6 +  Else If GetSignType() = 'UKR'
.head 7 -  Call SalMessageBox( 'Наложение ЭЦП "UKR" не реализована', 'Ошибка',MB_Ok | MB_IconStop )
.head 6 +  ! Else If GetSignType() = 'SSF'
.head 7 -  Call SalStrSetBufferLength( lsSignInt, loc_nSignLen+1 )
.head 7 -  Set nErrorSign = F_SsfSign(sSignData,nLen+nBuffLen, lsSignInt, loc_nSignLen, GetIdOper())
.head 6 +  If nErrorSign = 0
.head 7 -  Call DSig_sTrace( sSignData, nLen+nBuffLen, lsSignInt )
.head 7 -  Call SalStrSetBufferLength( plsSignIntHex, 2*loc_nSignLen+1 )
.head 7 -  Call ConvertBinToHex( lsSignInt, plsSignIntHex, loc_nSignLen )
.head 7 -  Call SaveFInfoToLog( 'SIGN: Внутренняя ЭЦП наложена. Ref='||Str(nRef)||PutCrLf()
||'Буфер:'||PutCrLf()
||'"'||strSignData||'"'||PutCrLf()
||'Доп. буфер:'||PutCrLf()
||sBuff||PutCrLf()
||'ЭЦП:'||PutCrLf()
||plsSignIntHex||PutCrLf()
 )
.head 7 -  Return TRUE
.head 6 +  Else
.head 7 +  If GetSignType() = 'NBU'
.head 8 -  Set strErrorSign = 'Ошибка наложения ЭЦП НБУ: '
|| NumberToStr(nErrorSign)
|| PutCrLf()||'Ключ='||GetIdOper()||PutCrLf()||DSig_GetSepSignMsg(nErrorSign)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 8 -  Set strErrorSign = 'Ошибка наложения ЭЦП '||GetSignType()||': '||PutCrLf()||NumberToStr(nErrorSign)||'-'||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'PRX'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call PRX_ERR_MSG(nErrorSign, strErrorSign, 4095)
.head 8 -  Set strErrorSign = 'Ключ '||GetIdOper()||'.'||PutCrLf()||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'VEG'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call VegaGetMsgAux(nErrorSign, strErrorSign, 4096)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'UNI'
.head 8 -  ! Set szTempBuf = SalStrRepeatX(' ', 256)
.head 8 -  ! Call NBUFormatMessage( nErrorSign, szTempBuf, 256)
.head 8 -  ! Set strErrorSign = 'Ошибка наложения ЭЦП UNI: '||SalNumberToStrX( nErrorSign, 0)
  || PutCrLf()||'KeyID='||GetIdOper()||PutCrLf()||szTempBuf
.head 8 -  ! Call MessageErrorEx(strErrorSign)
.head 8 -  ! ----------------------------
.head 8 -  Call MessageErrorEx( DSig_UNIFormatGSSMessage(min_status, nErrorSign) )
.head 7 +  Else If GetSignType() = 'UKR'
.head 8 -  Call nsignMapError2Text(strErrorSign,nErrorSign)
.head 8 -  Call nsignExitOPSign()
.head 8 -  Call MessageErrorEx(StrDosToWinX(strErrorSign))
.head 7 +  ! Else If GetSignType() = 'SSF'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call F_SsfGetErrMsg(nErrorSign, strErrorSign, 4096)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 5 -  Return FALSE
.head 3 +  Function: DSig_MakeSepBuf                       ! __exported
.head 4 -  Description: формирует буфер СЭП для проверки/наложения ЭЦП по входящим полям
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  String: BankA
.head 5 -  String: NlsA
.head 5 -  String: BankB
.head 5 -  String: NlsB
.head 5 -  Number: Dk
.head 5 -  Number: S
.head 5 -  Number: Vob
.head 5 -  String: Nd
.head 5 -  Number: Kv
.head 5 -  Date/Time: DatD
.head 5 -  Date/Time: DatP
.head 5 -  String: NamA
.head 5 -  String: NamB
.head 5 -  String: Nazn
.head 5 -  String: Drec
.head 5 -  String: NaznK
.head 5 -  String: NaznS
.head 5 -  String: OkpoA
.head 5 -  String: OkpoB
.head 5 -  String: RefA
.head 5 -  String: OperId
.head 5 -  Number: Bis
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sSignData
.head 5 -  String: sNd
.head 5 -  String: sNama
.head 5 -  String: sNamb
.head 5 -  String: sNazn
.head 5 -  String: sDrec
.head 5 -  String: sDat1
.head 5 -  String: sDat2
.head 5 -  Number: nVob
.head 5 -  String: sSepVobList
.head 4 +  Actions
.head 5 +  If GetGlobalOptionEx('SEPNUM')=2
.head 6 -  Set sNd   = Nd
.head 6 -  Set sNama = NamA
.head 6 -  Set sNamb = NamB
.head 6 -  Set sNazn = Nazn
.head 6 -  Set sDrec = Drec
.head 5 +  Else
.head 6 -  Set sNd = StrWinToDosX(Nd)
.head 6 -  Set sNama = StrWinToDosX(NamA)
.head 6 -  Set sNamb = StrWinToDosX(NamB)
.head 6 -  Set sNazn = StrWinToDosX(Nazn)
.head 6 -  Set sDrec = StrWinToDosX(Drec)
.head 5 -  Set sDat1 = SalFmtFormatDateTime(DatD,'yyMMdd')
.head 5 -  Set sDat2 = SalFmtFormatDateTime(DatP,'yyMMdd')
.head 5 -  Set sSepVobList=SalStrTrimX(GetGlobalOption('VOB2SEP2'))
.head 5 +  If sSepVobList
.head 6 +  If SalStrScan ( ','||sSepVobList||',', ','||Str(Vob)||',' )>=0
.head 7 -  Set nVob = Vob
.head 6 +  Else
.head 7 -  Set nVob = GetVobForBadVob()
.head 5 +  Else
.head 6 +  If Vob=1 or  Vob=2 or Vob=6 or Vob=33 or Vob=81
.head 7 -  Set nVob = Vob
.head 6 +  Else
.head 7 -  Set nVob = GetVobForBadVob()
.head 5 -  Set sSignData = PadL(BankA, 9) || PadL(NlsA, 14) ||
                PadL(BankB, 9) || PadL(NlsB, 14) ||
    PadL(SalNumberToStrX(Dk, 0), 1) || PadL(SalNumberToStrX(S, 0), 16) ||
    PadL(SalNumberToStrX(nVob,0), 2) || PadR(sNd, 10)  ||
    PadL(SalNumberToStrX(Kv, 0), 3) || sDat1 || sDat2 ||
    PadR(sNama, 38)  || PadR(sNamb,38) ||
    PadR(sNazn, 160) || PadR(sDrec,60) || PadR(NaznK, 3) || PadR(NaznS, 2) ||
    PadL(OkpoA, 14) || PadL(OkpoB, 14)  ||
    PadL(RefA,9) || PadR(OperId, 6) ||
    PadL(SalNumberToStrX(Bis,0),2)  || PadL(' ', 8)
.head 5 -  Return sSignData
.head 3 +  Function: DSig_sDoc       			! __exported
.head 4 -  Description: ! Подписать документ ЭЦП СЭП
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Long String: lsSignData ! Буфер СЭП для наложения ЭЦП
.head 5 -  Receive String: psKey
.head 5 -  Receive Long String: plsSignHex
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sSignData
.head 5 -  Number: nErrorSign
.head 5 -  String: strErrorSign
.head 5 -  String: sNd
.head 5 -  String: sNama
.head 5 -  String: sNamb
.head 5 -  String: sNazn
.head 5 -  String: sDrec
.head 5 -  String: sDat1
.head 5 -  String: sDat2
.head 5 -  Number: nVob
.head 5 -  String: szTempBuf
.head 5 -  ! Date/Time: dtSomeDate
.head 5 -  Number: nInd
.head 5 -  Number: min_status
.head 5 -  Number: nSignLen
.head 5 -  Number: nCertLen
.head 5 -  Number: nSignHandle
.head 5 -  Number: nCertHandle
.head 5 -  Long String: lsSign
.head 4 +  Actions
.head 5 -  ! Call Debug( 'Call sDoc()' )
.head 5 +  If GetSignOn() = 0 ! ЭЦП отключена - вернуть Пусто
.head 6 -  Set plsSignHex = STRING_Null
.head 6 -  Return TRUE
.head 5 -  Set g_InsertCertFlag = TRUE ! вставлять сертификат ключа в БД
.head 5 +  If DSig_sIni()
.head 6 -  ! Выделение памяти под буфер ЭЦП
.head 6 -  Call SalStrSetBufferLength( lsSign, DSig_DefaultSignSize()+1 )
.head 6 -  Set sSignData = lsSignData
.head 6 -  ! Наложение ЭЦП
.head 6 -  Set psKey = GetIdOper()
.head 6 +  If GetSignType() = 'NBU'
.head 7 -  Set nErrorSign = RSA_ZAH(87,-1,1,sSignData,444,0,lsSign,GetIdOper())
.head 6 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 7 -  Call SalStrSetBufferLength ( strErrorSign, 254+1 )
.head 7 +  ! If PutSign(nErrorSign,strErrorSign,254,sSignData,444,lsSign,DSig_DefaultSignSize())<0
.head 8 -  Call Debug(strErrorSign)
.head 6 +  Else If GetSignType() = 'PRX'
.head 7 -  Set nErrorSign = PRX_RSA_ZAH(119,-1,1,sSignData,444,0,lsSign,'')
.head 6 +  Else If GetSignType() = 'VEG'
.head 7 -  Set nErrorSign = VegaEnsign(lsSign,sSignData,444,0,g_sUid,0,0)
.head 6 +  Else If GetSignType() = 'UNI'
.head 7 -  ! ------------------------------
.head 7 -  Call SalStrSetBufferLength( g_lsCertificate, UNI_CERT_SIZE+1 )
.head 7 -  Set nErrorSign = NG_CREATE_SIGN_CRED( min_status,
			g_nCredHandle,
			444, sSignData,
			nSignLen, nSignHandle,
			nCertLen, nCertHandle)
.head 7 +  If 0=nErrorSign
.head 8 -  Call ConvertHexToBin( NumPtr2HexStr(nSignHandle, nSignLen),
	lsSign, nSignLen )
.head 8 -  Call ConvertHexToBin( NumPtr2HexStr(nCertHandle, nCertLen),
	g_lsCertificate, nCertLen )
.head 8 -  ! чистим память
.head 8 -  Call gss_release_buffer( min_status, nSignLen, nSignHandle )
.head 8 -  Call gss_release_buffer( min_status, nCertLen, nCertHandle )
.head 6 +  Else If GetSignType() = 'UKR'
.head 7 -  Set nErrorSign = nsignPutOPSignOnMemory(sSignData,444,lsSign)
.head 6 +  ! Else If GetSignType() = 'SSF'
.head 7 -  Set nErrorSign = F_SsfSign(sSignData,444, lsSign, nSignLen, psKey)
.head 6 +  If nErrorSign = 0
.head 7 -  Call DSig_sTrace(sSignData, 444, lsSign)
.head 7 -  Call SalStrSetBufferLength( plsSignHex, 2*DSig_DefaultSignSize()+1 )
.head 7 -  Call ConvertBinToHex( lsSign, plsSignHex, DSig_DefaultSignSize() )
.head 7 -  Call SaveFInfoToLog( 'SIGN: Наложена ЭЦП СЭП.'||PutCrLf()
||'Буфер:'||PutCrLf()
||'"'||sSignData||'"'||PutCrLf()
||'ЭЦП:'||PutCrLf()
||plsSignHex||PutCrLf()
 )
.head 7 -  ! Call Debug( 'sDoc(): before return TRUE' )
.head 7 -  Return TRUE
.head 6 +  Else ! обработка ошибок ЭЦП
.head 7 +  If GetSignType() = 'NBU'
.head 8 -  Set strErrorSign = 'Ошибка наложения ЭЦП НБУ: '||NumberToStr(nErrorSign)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'PRX'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call PRX_ERR_MSG(nErrorSign, strErrorSign, 4095)
.head 8 -  Set strErrorSign = 'Ключ '||GetIdOper()||'.'||PutCrLf()||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'VEG'
.head 8 -  Set strErrorSign = 'Ошибка наложения ЭЦП VEGA: '
||SalNumberToStrX(SalNumberMod( nErrorSign, 4096 ),0)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'UNI'
.head 8 -  ! Set szTempBuf = SalStrRepeatX(' ', 256)
.head 8 -  ! Call NBUFormatMessage( nErrorSign, szTempBuf, 256)
.head 8 -  ! Set strErrorSign = 'Ошибка наложения ЭЦП UNI: '||SalNumberToStrX( nErrorSign, 0)
  || PutCrLf()||'KeyID='||GetIdOper()||PutCrLf()||szTempBuf
.head 8 -  ! Call MessageErrorEx(strErrorSign)
.head 8 -  ! -------------------------------------
.head 8 -  Call MessageErrorEx( DSig_UNIFormatGSSMessage(min_status, nErrorSign) )
.head 7 +  Else If GetSignType() = 'UKR'
.head 8 -  Call nsignMapError2Text(strErrorSign,nErrorSign)
.head 8 -  Call nsignExitOPSign()
.head 8 -  Call MessageErrorEx(StrDosToWinX(strErrorSign))
.head 7 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 8 -  Set strErrorSign = 'Ошибка наложения ЭЦП '||GetSignType()||': '||PutCrLf()||NumberToStr(nErrorSign)||'-'||strErrorSign
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  ! Else If GetSignType() = 'SSF'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call F_SsfGetErrMsg(nErrorSign, strErrorSign, 4096)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 5 -  Return FALSE
.head 3 +  Function: DSig_sIni				! __exported
.head 4 -  Description: Инициализировать ЭЦП
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 -  Parameters
.head 4 +  Static Variables
.head 5 -  Number: nTim
.head 5 -  Number: nCredLifeSec
.head 5 -  Number: nCredLifeDays
.head 5 -  Boolean: inProgress
.head 4 +  Local variables
.head 5 -  ! String: strUxDateTime
.head 5 -  String: strDay
.head 5 -  Number: nDay
.head 5 -  Number: nErrorSign
.head 5 -  String: strErrorSign
.head 5 -  String: strPinCode
.head 5 -  Number: lTim
.head 5 -  Number: nDaysLeft
.head 5 -  String: strDaysLeftMsg
.head 5 -  String: strFullMsg
.head 5 -  String: strFileName
.head 5 -  Number: nTmpNum
.head 5 -  Number: nBufAddress
.head 5 -  Number: message_context
.head 5 -  Number: maj_status
.head 5 -  Number: min_status
.head 5 -  Number: nMsgSize
.head 5 -  String: strBuf
.head 5 -  String: strIDOperBuf
.head 5 -  Number: nIDOperLength
.head 5 -  Number: nPinResult
.head 5 -  String: strIconPath
.head 5 -  String: strCRPin
.head 5 -  Number: nSignLen
.head 4 +  Actions
.head 5 -  ! Имитируем блокировку метода с помощью статической переменной
.head 5 +  If not inProgress
.head 6 -  Set inProgress = TRUE
.head 5 +  Else
.head 6 -  Call MessageErrorEx('Ініціалізація системи безпеки виконується в іншому потоці.'
||PutCrLf()||'Зевершіть роботу іншого потоку.')
.head 6 -  Return FALSE
.head 5 -  Set lTim = nTim
.head 5 -  Set nTim = SalDateHour(SalDateCurrent())*60 + SalDateMinute(SalDateCurrent())
.head 5 +  If g_bSignInited and nTim-lTim < g_nTim
.head 6 -  Set inProgress = FALSE
.head 6 -  Return TRUE
.head 5 +  If GetSignType() = 'UKR'
or GetSignType() = 'NBU'
or GetSignType() = 'KAZ'
or GetSignType() = 'HCB'
or GetSignType() = 'VEG'
or GetSignType() = 'UNI'
or GetSignType() = 'PRX'
or GetSignType() = 'SSF'
.head 6 -  Set nErrorSign = NUMBER_Null
.head 6 -  Set strPinCode = ''
.head 6 -  Call WaitCursorOff(  )
.head 6 +  While TRUE
.head 7 +  If GetSignType() = 'UNI' or GetSignType() = 'SSF' ! Внутренняя ЭЦП НБУ -
			   диалог пароля показывать не надо
.head 8 -  Set nPinResult = 1
.head 7 +  Else ! для остальных - показать диалог
.head 8 -  ! Для Петрокомерца - ввод пароля на ключ не показывает - пароль стандартный для всех ключей 
.head 8 +  If GetSecretKeyDrv()='JCA:'
.head 9 -  Set nPinResult = 1
.head 9 -  Set strPinCode = 'pertojca'
.head 8 +  Else
.head 9 -  Set nPinResult = SalModalDialog(dlgAskPinCode, hWndForm, strPinCode)
.head 7 +  If nPinResult
.head 8 -  Set nSignLen = DSig_DefaultSignSize()
.head 8 +  If GetSignType() = 'NBU'
.head 9 +  If g_bSignInited
.head 10 -  Set nErrorSign = CLOSE_ZAH()
.head 10 -  Set g_bSignInited = FALSE
.head 9 -  Set nErrorSign = INIT_ZAH(GetOpenKeyDir(),GetSecretKeyDrv(),GetIdOper(),GetKeyDate(), strPinCode)
.head 9 +  If nErrorSign = -70
.head 10 -  Call MessageErrorEx('Последний день действия секретного ключа '||GetIdOper())
.head 9 +  Else If nErrorSign > -77 And nErrorSign < -70
.head 10 -  Set nDay = - nErrorSign - 70
.head 10 -  Call MessageErrorEx('Действие ключа '||GetIdOper()||' прекращается через ' ||NumberToStr(nDay) || ' ' || DSig_GetDayStrByNum(nDay))
.head 9 +  Else If nErrorSign
.head 10 -  Break
.head 8 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 9 +  If g_bSignInited
.head 10 -  Call SalStrSetBufferLength ( strErrorSign, 254+1 )
.head 10 +  ! If DeinitSecurity(nErrorSign,strErrorSign,254)<0
.head 11 -  Call MessageErrorEx('Помилка вигрузки б-ки')
.head 10 -  Set g_bSignInited = FALSE
.head 9 -  ! Загрузити потрібну б-ку
.head 9 -  Call SalStrSetBufferLength ( strErrorSign, 254+1 )
.head 9 +  ! If LoadSecLibraryEx(nErrorSign,strErrorSign,254,GetDir()||'\\BIN\\'||
IifS(GetSignType() = 'KAZ','avhl2cki.dll','zah_cb.dll'))<0
.head 10 -  Call MessageErrorEx('Неможливо загрузити бібліотеку захисту '||GetDir()||'\\BIN\\avhl2cki.dll'||PutCrLf()||strErrorSign)
.head 10 -  Break 
.head 9 -  ! Ініціалізувати систему захисту
.head 9 -  Call SalStrSetBufferLength ( strErrorSign, 254+1 )
.head 9 +  ! If InitSecurity(nErrorSign,strErrorSign,254,'',GetOpenKeyDir(),GetIdOper(),GetKeyDate(),strPinCode,'','','','','','')<0
.head 10 -  Break 
.head 8 +  Else If GetSignType() = 'PRX'
.head 9 +  If g_bSignInited
.head 10 -  Set nErrorSign = PRX_CLOSE_ZAH()
.head 10 -  Set g_bSignInited = FALSE
.head 9 -  Set nErrorSign = PRX_CLOSE_ZAH()
.head 9 -  Set nErrorSign = PRX_INIT_ZAH(GetOpenKeyDir(),GetSecretKeyDrv(),GetIdOper(),GetKeyDate(), strPinCode)
.head 9 +  If nErrorSign >= 70 And nErrorSign <= 77
.head 10 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 10 -  Call PRX_ERR_MSG(nErrorSign, strErrorSign, 4095)
.head 10 -  Call MessageErrorEx( strErrorSign||PutCrLf()||'Ключ '||GetIdOper()||'.' )
.head 9 +  Else If nErrorSign
.head 10 -  Break
.head 8 +  Else If GetSignType() = 'VEG'
.head 9 +  If g_bSignInited
.head 10 -  Set nErrorSign = VegaClose (0)
.head 10 -  Set g_bSignInited = FALSE
.head 9 -  Call SalStrSetBufferLength( g_sBuf, 11024+4104+1)
.head 9 -  Set nErrorSign = VegaSetBuf(g_sBuf, 11024+4104)
.head 9 +  If nErrorSign
.head 10 -  ! Call Debug('VegaSetBuf Err '||SalNumberToStrX(nErrorSign,0))
.head 10 -  Break
.head 9 -  ! VegaSetDate() делать не будем
.head 9 -  ! Set nErrorSign = VegaSetDate(SalFmtFormatDateTime(GetBankDate(),'dd/MM/yyyy'))
.head 9 +  ! If nErrorSign
.head 10 -  ! Call Debug('VegaSetDate Err '||SalNumberToStrX(nErrorSign,0))
.head 10 -  Break
.head 9 -  Set nErrorSign = VegaOpen(GetOpenKeyDir()||'\\Vega.cfg',GetOpenKeyDir()||'\\',0)
.head 9 +  If nErrorSign
.head 10 -  ! Call Debug('VegaOpen Err '||SalNumberToStrX(nErrorSign,0))
.head 10 -  Break
.head 9 -  ! Устанавливаем режим раздельного ведения протокола ВЕГА по идентификаторам ключей
.head 9 -  Call VegaSetPmode(1, 0)
.head 9 -  !
.head 9 -  Call SalStrSetBufferLength(g_sUid,9)
.head 9 -  Call SalStrSetBufferLength(g_sUidCheck,9)
.head 9 +  If GetSecretKeyDrv()='@'  ! устройство типа CardReader фирмы "АВТОР"
.head 10 -  ! Call Debug( 'CardReaderName='||GetCardReaderName() )
.head 10 -  ! Call Debug( 'CardReaderPin='||GetCardReaderPin() )
.head 10 +  ! If GetCardReaderPin()=STRING_Null or
   Len(GetCardReaderPin())=0
.head 11 -  Set strCRPin = Subs( PadR(strPinCode,32),1,8 )
.head 10 +  ! Else
.head 11 -  Set strCRPin = GetCardReaderPin()
.head 10 -  ! Call Debug( 'strCRPin=&'||strCRPin||'&' )
.head 10 -  Set nErrorSign = VegaLoadSecKeyCC(
SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.KEY',
PadR(strPinCode,32),g_sUid,0,
GetCardReaderName())
.head 9 +  Else If GetSecretKeyDrv()='TM'  ! Touch Memory
.head 10 -  Set nErrorSign=DSig_ReadTM()
.head 10 +  If nErrorSign
.head 11 -  ! Call Debug('ReadTM Err '||SalNumberToStrX(nErrorSign,0))
.head 11 -  Break
.head 10 -  Call VegaSetFmode(1,0)
.head 10 -  Set nErrorSign = VegaLoadSecKey(g_lsSecretKey,PadR(strPinCode,32),g_sUid,0)
.head 10 -  Call VegaSetFmode(0,0)
.head 9 +  Else If GetSecretKeyDrv()='ALDN:'  ! Аладиновский токен Надра
.head 10 -  Set nErrorSign=DSig_ReadToken(strPinCode,strErrorSign)
.head 10 +  If nErrorSign
.head 11 -  Break
.head 10 -  Call VegaSetFmode(1,0)
.head 10 -  Set nErrorSign = VegaLoadSecKey(g_lsSecretKey,PadR(strPinCode,32),g_sUid,0)
.head 10 -  Call VegaSetFmode(0,0)
.head 9 +  Else If GetSecretKeyDrv()='JCA:'  ! JCA карта для Петрокомерца
.head 10 -  ! Call Debug(GetSecretKeyDrv()||SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.KEY')
.head 10 -  Set nErrorSign = VegaLoadSecKey(GetSecretKeyDrv()||SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.KEY',PadR(strPinCode,32),g_sUid,0)
.head 9 +  Else ! Floppy Disk
.head 10 -  Set nErrorSign = VegaLoadSecKey(GetSecretKeyDrv()||'\\'||SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.KEY',PadR(strPinCode,32),g_sUid,0)
.head 9 -  ! Обрабатываем все предупреждения от VegaLoadSecKey - SERG
.head 9 +  If nErrorSign>=1 AND  nErrorSign<=8
.head 10 -  Set strErrorSign = SalStrRepeatX(' ', 129)
.head 10 -  Call VegaGetMsgAux(nErrorSign, strErrorSign, 128 )
.head 10 +  If nErrorSign=1 OR nErrorSign=2
.head 11 -  Set nDaysLeft = VegaDaysLeft(0)
.head 11 -  Set strDaysLeftMsg = 'До истечения срока действия секретного ключа осталось '
||SalNumberToStrX(nDaysLeft,0) || ' ' || DSig_GetDayStrByNum(nDaysLeft)
.head 10 +  Else If nErrorSign=4
.head 11 -  Set nDaysLeft = VegaDaysLeftA(0)
.head 11 -  Set strDaysLeftMsg = 'До истечения срока действия ключа администратора осталось '
||SalNumberToStrX(nDaysLeft,0) || ' ' || DSig_GetDayStrByNum(nDaysLeft)
.head 10 -  Set strFullMsg = SalStrLeftX(strErrorSign, SalStrLength(strErrorSign)) || SalNumberToChar(13) ||
	strDaysLeftMsg || SalNumberToChar(13) || 'Продолжите работу'
.head 10 -  ! Операционисты должны видеть только предупреждения
с кодом 1 или 2 - остальные пока игнорируем
4 - касается администратора
8 - возникать не должно
.head 10 +  If nErrorSign=1 OR nErrorSign=2
.head 11 -  Call SalMessageBox(strFullMsg , 'Предупреждение', MB_Ok | MB_IconExclamation )
.head 10 -  ! Обнуляем переменную с кодом ошибки
.head 10 -  Set nErrorSign=0
.head 9 +  If nErrorSign
.head 10 -  ! Call Debug('VegaLoadSecKey Err '||SalNumberToStrX(nErrorSign,0))
.head 10 -  Break
.head 9 +  If SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper() != g_sUid
.head 10 -  Set nErrorSign=202
.head 10 -  Break
.head 9 -  ! Проверим соответствие идентификатора ключа
.head 9 -  ! Обрабатываем ситуацию обновления ключа для TouchMemory
.head 9 +  If GetSecretKeyDrv()='TM'
.head 10 +  If VegaSecKeyUpdate(0)  ! было изменение ключа
.head 11 -  ! дампим старый ключ на диск C и прописываем новый на ТМ
.head 11 -  ! Call Debug('Обновление ключа')
.head 11 -  ! Дампить СК на лок. диск запрещается !!!
.head 11 -  ! Set strFileName = 'C:\\' || SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.KEY'
.head 11 +  ! If SalFileOpen(hFileKeyBackup, strFileName, OF_Create | OF_Write | OF_Binary )
.head 12 -  Call SalFileWrite(hFileKeyBackup, g_lsSecretKeyCopy, VEGA_SKFILE_SIZE)
.head 12 -  Call SalFileClose(hFileKeyBackup)
.head 12 -  Call SalMessageBox( 'Старый ключ сохранен в файле ' || strFileName ,
'Сообщение',  MB_Ok | MB_IconAsterisk )
.head 11 +  ! Else
.head 12 -  Call SalMessageBox( 'Ошибка открытия файла '|| strFileName ||
' для записи' || SalNumberToChar(13) || 'Старый ключ сохранен не будет',
'Предупреждение', MB_Ok | MB_IconExclamation )
.head 11 -  Set nErrorSign =  DSig_WriteTM()
.head 11 +  If nErrorSign = 0
.head 12 -  Call SalMessageBox( 'Секретный ключ успешно обновлен на TouchMemory',
 'Сообщение', MB_Ok | MB_IconAsterisk )
.head 12 -  Call SaveInfoToLog('СК ' || SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper() ||
' успешно обновлен на TouchMemory')
.head 10 +  ! Else
.head 11 -  Call Debug('Ключ не менялся ')
.head 11 -  Set strFileName = 'C:\\' || SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.KEY'
.head 11 -  Call Debug( strFileName )
.head 8 +  Else If GetSignType() = 'UNI' ! Внутренняя ЭЦП НБУ
.head 9 -  ! Устанавливаем ссылку на родительское окно для привязки модальных диалогов
.head 9 -  Call F_SetParentWindowHandle( hWndForm )
.head 9 -  ! --
.head 9 +  If g_bSignInited
.head 10 -  ! Set nErrorSign = OL_CLOSE_ZAH(m_nNullContext)
.head 10 -  ! сначала удаляем удостоверение
.head 10 -  Call gss_release_cred( min_status,
  g_nCredHandle )
.head 10 -  ! деинициализация ЭЦП
.head 10 -  ! Call NG_CLOSE_ZAH()
.head 10 -  ! Set nErrorSign = F_DeinitCred( GetIdOper() )
.head 10 +  ! If nErrorSign!=0 AND nErrorSign!=2
.head 11 -  Set strErrorSign = CredFormatMessage(nErrorSign)
.head 11 -  Call SalMessageBox( strErrorSign, 'DeinitCred()',
MB_Ok|MB_IconStop )
.head 10 -  Set g_bSignInited = FALSE
.head 9 +  ! If nErrorSign
.head 10 -  Set strErrorSign = UNIFormatMessage(nErrorSign)
.head 10 -  Break
.head 9 -  Set strIDOperBuf = GetIdOper()
.head 9 -  Set nIDOperLength = SalStrLength( GetIdOper() )+1
.head 9 -  Set strIconPath = GetIconPath()
.head 9 +  If '' = strIconPath
.head 10 -  Set strIconPath = STRING_Null
.head 9 -  Set nErrorSign = F_ReinitCred(
	strIDOperBuf,
	'АБС БАРС Міленіум',
	strIconPath,
	0xFFFFFFFF
	)
.head 9 -  ! Call Debug( 'nErrorSign=' || SalNumberToStrX( nErrorSign, 0 ))
.head 9 +  If nErrorSign
.head 10 -  Set strErrorSign = DSig_CredFormatMessage(nErrorSign)
.head 10 -  Break
.head 9 -  Set nErrorSign = gss_acquire_cred(
  min_status,
  GetIdOper(),
  0xffffffff,
  0,
  0,
  g_nCredHandle,
  NUMBER_Null,
  nCredLifeSec
)
.head 9 +  If nErrorSign
.head 10 -  Set strErrorSign = DSig_UNIFormatGSSMessage(min_status, nErrorSign)
.head 10 -  Break
.head 9 -  ! проверка: сколько удостоверению осталось жить ?
.head 9 -  Set nCredLifeDays = nCredLifeSec / (24*60*60)
.head 9 +  If nCredLifeDays<8
.head 10 -  Set nCredLifeDays = SalNumberTruncate ( nCredLifeDays, 1, 0 )
.head 10 +  If nCredLifeDays<=7 AND nCredLifeDays>=5
.head 11 -  Set strErrorSign = 'До истечения срока действия ключа осталось '
||SalNumberToStrX( nCredLifeDays, 0 ) || ' дней'
.head 10 +  Else If nCredLifeDays<=4 AND nCredLifeDays>=2
.head 11 -  Set strErrorSign = 'До истечения срока действия ключа осталось '
||SalNumberToStrX( nCredLifeDays, 0 ) || ' дня'
.head 10 +  Else If 1=nCredLifeDays
.head 11 -  Set strErrorSign = 'До истечения срока действия ключа осталось '
||SalNumberToStrX( nCredLifeDays, 0 ) || ' день'
.head 10 +  Else
.head 11 -  Set strErrorSign = 'Срок действия ключа заканчивается сегодня'
.head 10 -  Call SalMessageBox('UNI: KeyID='||GetIdOper()||PutCrLf()
||strErrorSign,	'Предупреждение', MB_Ok | MB_IconExclamation )
.head 9 -  Call DSig_InsertCert2DB()
.head 8 +  Else If GetSignType() = 'SSF' ! Внутренняя ЭЦП НБУ - библиотека libSSF 
.head 9 -  ! Устанавливаем ссылку на родительское окно для привязки модальных диалогов
.head 9 -  Call F_SetParentWindowHandle( hWndForm )
.head 9 -  ! --
.head 9 +  If g_bSignInited
.head 10 -  ! Set nErrorSign = OL_CLOSE_ZAH(m_nNullContext)
.head 10 -  ! сначала удаляем удостоверение
.head 10 -  Call gss_release_cred( min_status,
  g_nCredHandle )
.head 10 -  ! деинициализация ЭЦП
.head 10 -  ! Call NG_CLOSE_ZAH()
.head 10 -  ! Set nErrorSign = F_DeinitCred( GetIdOper() )
.head 10 +  ! If nErrorSign!=0 AND nErrorSign!=2
.head 11 -  Set strErrorSign = CredFormatMessage(nErrorSign)
.head 11 -  Call SalMessageBox( strErrorSign, 'DeinitCred()',
MB_Ok|MB_IconStop )
.head 10 -  Set g_bSignInited = FALSE
.head 9 +  ! If nErrorSign
.head 10 -  Set strErrorSign = UNIFormatMessage(nErrorSign)
.head 10 -  Break
.head 9 -  Set strIDOperBuf = GetIdOper()
.head 9 -  Set nIDOperLength = SalStrLength( GetIdOper() )+1
.head 9 -  Set strIconPath = GetIconPath()
.head 9 +  If '' = strIconPath
.head 10 -  Set strIconPath = STRING_Null
.head 9 -  Set nErrorSign = F_ReinitCred(
	strIDOperBuf,
	'АБС БАРС Міленіум',
	strIconPath,
	0xFFFFFFFF
	)
.head 9 -  ! Call Debug( 'nErrorSign=' || SalNumberToStrX( nErrorSign, 0 ))
.head 9 +  If nErrorSign
.head 10 -  Set strErrorSign = DSig_CredFormatMessage(nErrorSign)
.head 10 -  Break
.head 9 -  Set nErrorSign = gss_acquire_cred(
  min_status,
  GetIdOper(),
  0xffffffff,
  0,
  0,
  g_nCredHandle,
  NUMBER_Null,
  nCredLifeSec
)
.head 9 +  If nErrorSign
.head 10 -  Set strErrorSign = DSig_UNIFormatGSSMessage(min_status, nErrorSign)
.head 10 -  Break
.head 9 -  ! проверка: сколько удостоверению осталось жить ?
.head 9 -  Set nCredLifeDays = nCredLifeSec / (24*60*60)
.head 9 +  If nCredLifeDays<8
.head 10 -  Set nCredLifeDays = SalNumberTruncate ( nCredLifeDays, 1, 0 )
.head 10 +  If nCredLifeDays<=7 AND nCredLifeDays>=5
.head 11 -  Set strErrorSign = 'До истечения срока действия ключа осталось '
||SalNumberToStrX( nCredLifeDays, 0 ) || ' дней'
.head 10 +  Else If nCredLifeDays<=4 AND nCredLifeDays>=2
.head 11 -  Set strErrorSign = 'До истечения срока действия ключа осталось '
||SalNumberToStrX( nCredLifeDays, 0 ) || ' дня'
.head 10 +  Else If 1=nCredLifeDays
.head 11 -  Set strErrorSign = 'До истечения срока действия ключа осталось '
||SalNumberToStrX( nCredLifeDays, 0 ) || ' день'
.head 10 +  Else
.head 11 -  Set strErrorSign = 'Срок действия ключа заканчивается сегодня'
.head 10 -  Call SalMessageBox('UNI: KeyID='||GetIdOper()||PutCrLf()
||strErrorSign,	'Предупреждение', MB_Ok | MB_IconExclamation )
.head 9 -  Call DSig_InsertCert2DB()
.head 8 +  Else If GetSignType() = 'UKR'
.head 9 +  If g_bSignInited
.head 10 -  Set nErrorSign = nsignExitOPSign()
.head 10 -  Set g_bSignInited = FALSE
.head 9 -  Set nErrorSign = nsignInitOPSign(GetOpenKeyDir(),GetSecretKeyDrv(),strPinCode,GetBankMfo(),GetIdOper())
.head 9 +  If nErrorSign
.head 10 -  Break
.head 8 -  Call SaveFInfoToLog('SIGN: Инициализация ЭЦП - OK')
.head 8 -  Set g_bSignInited = TRUE
.head 8 -  ! Set m_bEscPin = TRUE
.head 8 -  Set inProgress = FALSE
.head 8 -  Return TRUE
.head 7 +  Else
.head 8 -  Set g_bSignInited = FALSE
.head 8 -  ! Set m_bEscPin = FALSE
.head 8 -  Break
.head 6 +  If nErrorSign                 ! обработка ошибок ЭЦП
.head 7 +  If GetSignType() = 'NBU'
.head 8 -  Set strErrorSign =
'Ошибка '||NumberToStr(nErrorSign)
|| ' инициализации ЭЦП НБУ. Ключ '||GetIdOper()
|| PutCrLf() || DSig_GetSepSignMsg(nErrorSign)
.head 8 -  Call MessageErrorEx(strErrorSign)
.head 7 +  Else If GetSignType() = 'PRX'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  Call PRX_ERR_MSG(nErrorSign, strErrorSign, 4095)
.head 8 -  Call MessageErrorEx( 'Ключ '||GetIdOper()||'.'||PutCrLf()||strErrorSign )
.head 7 +  Else If GetSignType() = 'VEG'
.head 8 -  ! Строку сообщения для ошибок VEGA и TM предоставляет библ. ф-ция VegaGetMsgAux - SERG
.head 8 -  ! Set strErrorSign = 'Ошибка '||SalNumberToStrX( (nErrorSign - SalNumberMod( nErrorSign, 4096 ))/4095, 0 )||'-'||
                SalNumberToStrX(SalNumberMod( nErrorSign, 4096 ),0) || ' инициализации ЭЦП VEGA. '||GetIdOper()
.head 8 +  If nErrorSign=700 
.head 9 -  Call MessageErrorEx('Ошибка инициализации ЭЦП ВЕГА. Ключ '
||SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.'
||PutCrLf()||PutCrLf()
||strErrorSign)
.head 8 +  Else
.head 9 -  Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 9 -  Call VegaGetMsgAux(nErrorSign, strErrorSign, 4096)
.head 9 -  Call MessageErrorEx('Ошибка инициализации ЭЦП ВЕГА. Ключ '
||SalStrRightX('00'||GetGlobalOption('REGNCODE'),2)||GetIdOper()||'.'
||PutCrLf()
||strErrorSign)
.head 7 +  Else If GetSignType() = 'UNI'
.head 8 -  ! Set strErrorSign = SalStrRepeatX(' ', 4096)
.head 8 -  ! Call NBUFormatMessage(nErrorSign,strErrorSign,4096)
.head 8 -  ! Call MessageErrorEx('UNI: KeyID='||GetIdOper()||PutCrLf()||strErrorSign)
.head 8 -  ! ------------------------------------------------
.head 8 -  Call MessageErrorEx( strErrorSign )
.head 7 +  Else If GetSignType() = 'KAZ' or GetSignType() = 'HCB'
.head 8 -  ! ------------------------------------------------
.head 8 -  Call MessageErrorEx('Помилка ініціалізації '||GetSignType()||': KeyID='||GetIdOper()||PutCrLf()||strErrorSign)
.head 7 +  Else If GetSignType() = 'UKR'
.head 8 -  Set strErrorSign = SalStrRepeatX(' ', 129)
.head 8 -  Call nsignMapError2Text(strErrorSign, nErrorSign)
.head 8 -  Call MessageErrorEx( StrDosToWinX(strErrorSign) )
.head 8 -  Call nsignExitOPSign()
.head 6 -  Set inProgress = FALSE
.head 6 -  Return FALSE
.head 5 +  Else
.head 6 -  Set inProgress = FALSE
.head 6 -  Return MessageErrorEx('Неизвестная система ЭЦП: '|| GetSignType())
.head 5 +  ! Комментарий
.head 6 -  ! 'NBU' -- используется ЭЦП НБУ
.head 6 -  ! 'KAZ' -- используется ЭЦП Казначейства Автор-НоваЛиб
.head 6 -  ! 'HCB' -- используется ЭЦП Казначейства НБУ-Аладин
.head 6 -  ! 'UKR' -- используется ЭЦП Банка 'Украина'
.head 6 -  ! 'VEG' -- используется ЭЦП NOKK 'VEGA'
.head 6 -  ! 'UNI' -- используется внутр. ЭЦП НБУ
.head 2 -  Named Menus
.head 2 -  Class Definitions
.head 2 +  Default Classes
.head 3 -  MDI Window: cBaseMDI
.head 3 -  Form Window:
.head 3 -  Dialog Box:
.head 3 -  Table Window:
.head 3 -  Quest Window:
.head 3 -  Data Field:
.head 3 -  Spin Field:
.head 3 -  Multiline Field:
.head 3 -  Pushbutton: cpbPlainButton
.head 3 -  Radio Button:
.head 3 -  Option Button:
.head 3 -  Check Box:
.head 3 -  Child Table:
.head 3 -  Quest Child Window: cQuickDatabase
.head 3 -  List Box:
.head 3 -  Combo Box:
.head 3 -  Picture:
.head 3 -  Vertical Scroll Bar:
.head 3 -  Horizontal Scroll Bar:
.head 3 -  Column:
.head 3 -  Background Text:
.head 3 -  Group Box:
.head 3 -  Line:
.head 3 -  Frame:
.head 3 -  Custom Control:
.head 2 -  Application Actions
.head 1 +  Dialog Box: dlgAskPinCode   ! __exported
.head 2 -  Class:
.head 2 -  Property Template:
.head 2 -  Class DLL Name:
.head 2 -  Title: Ввод PIN-кода пользователя
.head 2 -  Accesories Enabled? No
.head 2 -  Visible? Yes
.head 2 -  Display Settings
.head 3 -  Display Style? Default
.head 3 -  Visible at Design time? No
.head 3 -  Type of Dialog: Modal
.head 3 -  Window Location and Size
.head 4 -  Left:   1.588"
.head 4 -  Top:    1.646"
.head 4 -  Width:  4.467"
.head 4 -  Width Editable? Yes
.head 4 -  Height: 1.643"
.head 4 -  Height Editable? Yes
.head 3 -  Absolute Screen Location? Yes
.head 3 -  Font Name: MS Sans Serif
.head 3 -  Font Size: 8
.head 3 -  Font Enhancement: Default
.head 3 -  Text Color: Default
.head 3 -  Background Color: Default
.head 2 -  Description: Ввод PIN-кода пользователя
.head 2 +  Tool Bar
.head 3 -  Display Settings
.head 4 -  Display Style? Default
.head 4 -  Location? Top
.head 4 -  Visible? No
.head 4 -  Size: Default
.head 4 -  Size Editable? Yes
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 -  Contents
.head 2 +  Contents
.head 3 -  Frame
.head 4 -  Resource Id: 24289
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left:   0.1"
.head 5 -  Top:    0.06"
.head 5 -  Width:  4.15"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 1.143"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Corners: Square
.head 4 -  Border Style: Etched
.head 4 -  Border Thickness: 1
.head 4 -  Border Color: 3D Shadow Color
.head 4 -  Background Color: 3D Face Color
.head 3 -  Background Text: PIN-Код:
.head 4 -  Resource Id: 24290
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Window Location and Size
.head 5 -  Left:   0.617"
.head 5 -  Top:    0.524"
.head 5 -  Width:  1.1"
.head 5 -  Width Editable? Yes
.head 5 -  Height: 0.167"
.head 5 -  Height Editable? Yes
.head 4 -  Visible? Yes
.head 4 -  Justify: Right
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 3 +  Data Field: dfPinCode
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: 16
.head 5 -  Data Type: String
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left:   1.867"
.head 6 -  Top:    0.488"
.head 6 -  Width:  1.586"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Invisible
.head 5 -  Country: Default
.head 5 -  Font Name: Arial
.head 5 -  Font Size: 12
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.head 4 +  Message Actions
.head 5 +  On SAM_AnyEdit
.head 6 -  Set strPinCode = dfPinCode
.head 3 +  Data Field: dfFiller
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Data
.head 5 -  Maximum Data Length: Default
.head 5 -  Data Type: String
.head 5 -  Editable? Yes
.head 4 -  Display Settings
.head 5 -  Window Location and Size
.head 6 -  Left:   1.867"
.head 6 -  Top:    0.488"
.head 6 -  Width:  1.583"
.head 6 -  Width Editable? Yes
.head 6 -  Height: 0.25"
.head 6 -  Height Editable? Yes
.head 5 -  Visible? Yes
.head 5 -  Border? Yes
.head 5 -  Justify: Left
.head 5 -  Format: Unformatted
.head 5 -  Country: Default
.head 5 -  Font Name: Default
.head 5 -  Font Size: Default
.head 5 -  Font Enhancement: Default
.head 5 -  Text Color: Default
.head 5 -  Background Color: Default
.head 5 -  Input Mask: Unformatted
.head 4 +  Message Actions
.head 5 +  On SAM_SetFocus
.head 6 -  Call SalEndDialog(hWndForm, TRUE)
.head 3 +  Pushbutton: bEsc
.head 4 -  Class Child Ref Key: 0
.head 4 -  Class ChildKey: 0
.head 4 -  Class:
.head 4 -  Property Template:
.head 4 -  Class DLL Name:
.head 4 -  Title:
.head 4 -  Window Location and Size
.head 5 -  Left:   Default
.head 5 -  Top:    Default
.head 5 -  Width:  Default
.head 5 -  Width Editable? Yes
.head 5 -  Height: Default
.head 5 -  Height Editable? Yes
.head 4 -  Visible? No
.head 4 -  Keyboard Accelerator: Esc
.head 4 -  Font Name: Default
.head 4 -  Font Size: Default
.head 4 -  Font Enhancement: Default
.head 4 -  Picture File Name:
.head 4 -  Picture Transparent Color: None
.head 4 -  Image Style: Single
.head 4 -  Text Color: Default
.head 4 -  Background Color: Default
.head 4 +  Message Actions
.head 5 +  On SAM_Click
.head 6 -  Call SalEndDialog(hWndForm, FALSE)
.head 2 -  Functions
.head 2 +  Window Parameters
.head 3 -  Receive String: strPinCode
.head 2 -  Window Variables
.head 2 +  Message Actions
.head 3 +  On SAM_Create
.head 4 -  Call SalCenterWindow(hWndForm)
.head 4 -  Set strPinCode = ''
.head 4 -  Call SalSetFocus(dfPinCode)
.head 4 -  Call SalMapEnterToTab(TRUE)
.head 3 +  On SAM_Destroy
.head 4 -  Call SalMapEnterToTab(FALSE)
.head 3 +  On SAM_Close
.head 4 -  Call SalEndDialog(hWndForm, FALSE)
